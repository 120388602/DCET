using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace DCET.Tool
{
    internal class OpcodeInfo
    {
        public string Name;
        public int Opcode;
        public string ParentInterface;
    }

    public static class Program
    {
        private const string hotfixMessagePath = "../Unity/Assets/Hotfix/Message/AutoGeneratedCode/";
        private const string serverMessagePath = "../Server/Assets/Runtime/Message/AutoGeneratedCode/";
        private const string frameMessagePath = "../Server/Packages/DCET.Message/Actor/AutoGeneratedCode/";
        private const string protoPath = "../Proto/";
        private static readonly char[] splitChars = { ' ', '\t' };
        private static readonly List<OpcodeInfo> msgOpcode = new List<OpcodeInfo>();

        public static void Main()
        {
            //Proto2CS("DCET", "FrameMessage.proto", frameMessagePath, "FrameOpcode", 100, true);
           // Proto2CS("DCET", "InnerMessage.proto", serverMessagePath, "InnerOpcode", 1000, true);
            Proto2CS("DCET", "OuterMessage.proto", hotfixMessagePath, "OuterOpcode", 10000, false);
            
            Console.WriteLine("proto2cs succeed!");
        }

        public static void Proto2CS(string ns, string protoName, string outputPath, string opcodeClassName, int startOpcode, bool isServer)
        {
            if (!Directory.Exists(outputPath))
            {
                Directory.CreateDirectory(outputPath);
            }

            msgOpcode.Clear();
            string proto = Path.Combine(protoPath, protoName);
            string csPath = Path.Combine(outputPath, Path.GetFileNameWithoutExtension(proto) + ".cs");

            string s = File.ReadAllText(proto);

            StringBuilder sb = new StringBuilder();
            sb.Append("using ProtoBuf;\n");
            sb.Append("using System.Collections.Generic;\n\n");
            sb.Append($"namespace {ns}\n");
            sb.Append("{\n");

            bool isMsgStart = false;
            string parentClass = "";
            var currentOrder = 0;
            foreach (string line in s.Split('\n'))
            {
                string newline = line.Trim();

                if (newline == "")
                {
                    continue;
                }

                if (newline.StartsWith("//"))
                {
                    sb.Append($"{newline}\n");
                }

                if (newline.StartsWith("message"))
                {
                    parentClass = "";
                    isMsgStart = true;
                    string msgName = newline.Split(splitChars, StringSplitOptions.RemoveEmptyEntries)[1];
                    string[] ss = newline.Split(new[] { "//" }, StringSplitOptions.RemoveEmptyEntries);

                    if (ss.Length == 2)
                    {
                        parentClass = ss[1].Trim();
                    }

                    msgOpcode.Add(new OpcodeInfo() { Name = msgName, Opcode = ++startOpcode, ParentInterface = parentClass });

                    sb.Append($"\t[Message({opcodeClassName}.{msgName})]\n");
                    sb.Append($"\t[ProtoContract]\n");
                    sb.Append($"\tpublic partial class {msgName}");

                    if (!string.IsNullOrWhiteSpace(parentClass))
                    {
                        sb.Append($": {parentClass}\n");
                    }
                    else
                    {
                        sb.Append($"\n");
                    }
                }

                if (isMsgStart && newline == "{")
                {
                    sb.Append("\t{\n");
                }

                // 成员
                if (newline.StartsWith("required"))
                {
                    var order = Members(sb, newline, true);

                    if(order > currentOrder)
                    {
                        currentOrder = order;
                    }
                }

                if (newline.StartsWith("optional"))
                {
                    var order = Members(sb, newline, false);

                    if (order > currentOrder)
                    {
                        currentOrder = order;
                    }
                }

                if (newline.StartsWith("repeated"))
                {
                    var order = Repeated(sb, newline);

                    if (order > currentOrder)
                    {
                        currentOrder = order;
                    }
                }

                if (isMsgStart && newline == "}")
                {
                    isMsgStart = false;

					if (isServer)
					{
						if (parentClass == "IRequest" || parentClass == "IActorRequest" || parentClass == "IActorMessage")
						{
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int RpcId { get; set; }\n");
						}

						if (parentClass == "IResponse" || parentClass == "IActorResponse")
						{
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int RpcId { get; set; }\n");
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int Error { get; set; }\n");
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic string Message { get; set; }\n");
						}

						if (parentClass == "IActorRequest" || parentClass == "IActorMessage")
						{
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic long ActorId { get; set; }\n");
						}

						if (parentClass == "IActorLocationRequest" || parentClass == "IActorLocationMessage")
						{
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic long ActorId { get; set; }\n");
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int RpcId { get; set; }\n");
						}

						if (parentClass == "IActorLocationResponse")
						{
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int Error { get; set; }\n");
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic string Message { get; set; }\n");
							sb.AppendLine($"\t\t[ProtoMember({++currentOrder}, IsRequired = true)]");
							sb.AppendLine("\t\tpublic int RpcId { get; set; }\n");
						}
					}

                    sb.Append("\t}\n\n");
                    currentOrder = 0;
                }
            }
            sb.Append("}\n");

            File.WriteAllText(csPath, sb.ToString());

            GenerateOpcode(ns, opcodeClassName, outputPath);
        }

        private static void GenerateOpcode(string ns, string opcodeClassName, string outputPath)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");

            foreach (OpcodeInfo info in msgOpcode)
            {
                if (!string.IsNullOrWhiteSpace(info.ParentInterface))
                {
                    sb.Append($"\t[Message({opcodeClassName}.{info.Name})]\n");
                    sb.AppendLine($"\tpublic partial class {info.Name} : {info.ParentInterface}");
                    sb.AppendLine("\t{");
                    sb.AppendLine("\t}");
                }
            }

            sb.AppendLine($"\tpublic static partial class {opcodeClassName}");
            sb.AppendLine("\t{");
            foreach (OpcodeInfo info in msgOpcode)
            {
                sb.AppendLine($"\t\t public const ushort {info.Name} = {info.Opcode};");
            }
            sb.AppendLine("\t}");
            sb.AppendLine("}");

            string csPath = Path.Combine(outputPath, opcodeClassName + ".cs");
            File.WriteAllText(csPath, sb.ToString());
        }

        private static int Repeated(StringBuilder sb, string newline)
        {
            try
            {
                int index = newline.IndexOf(";");
                newline = newline.Remove(index);
                string[] ss = newline.Split(splitChars, StringSplitOptions.RemoveEmptyEntries);
                string type = ss[1];
                type = ConvertType(type);
                string name = ss[2];
                int order = int.Parse(ss[4]);

                sb.Append($"\t\t[ProtoMember({order}, IsRequired = true)]\n");

                sb.Append($"\t\tpublic List<{type}> {name} "+ "{ get; set; }" + $" = new List<{type}>();\n\n");

                return order;
            }
            catch (Exception e)
            {
                Console.WriteLine($"{newline}\n {e}");
            }

            return 0;
        }

        private static string ConvertType(string type)
        {
            string typeCs = "";
            switch (type)
            {
                case "int16":
                    typeCs = "short";
                    break;
                case "int32":
                    typeCs = "int";
                    break;
                case "bytes":
                    typeCs = "byte[]";
                    break;
                case "uint32":
                    typeCs = "uint";
                    break;
                case "long":
                    typeCs = "long";
                    break;
                case "int64":
                    typeCs = "long";
                    break;
                case "uint64":
                    typeCs = "ulong";
                    break;
                case "uint16":
                    typeCs = "ushort";
                    break;
                default:
                    typeCs = type;
                    break;
            }
            return typeCs;
        }

        private static int Members(StringBuilder sb, string newline, bool isRequired)
        {
            try
            {
                int index = newline.IndexOf(";");
                newline = newline.Remove(index);
                string[] ss = newline.Split(splitChars, StringSplitOptions.RemoveEmptyEntries);
                string type = ss[1];
                string name = ss[2];
                int order = int.Parse(ss[4]);
                sb.Append($"\t\t[ProtoMember({order}, IsRequired = {isRequired.ToString().ToLower()})]\n");
                string typeCs = ConvertType(type);

                sb.Append($"\t\tpublic {typeCs} {name} " + "{ get; set; }\n\n");

                return order;
            }
            catch (Exception e)
            {
                Console.WriteLine($"{newline}\n {e}");
            }

            return 0;
        }
    }
}
