-- Generated by CSharp.lua Compiler
--#region Copyright notice and license
-- Protocol Buffers - Google's data interchange format
-- Copyright 2008 Google Inc.  All rights reserved.
-- https://developers.google.com/protocol-buffers/
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     * Redistributions of source code must retain the above copyright
-- notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above
-- copyright notice, this list of conditions and the following disclaimer
-- in the documentation and/or other materials provided with the
-- distribution.
--     * Neither the name of Google Inc. nor the names of its
-- contributors may be used to endorse or promote products derived from
-- this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--#endregion
local System = System
local SystemIO = System.IO
local ArrayByte = System.Array(System.Byte)
local ListArrayByte = System.List(ArrayByte)
local GoogleProtobuf
System.import(function (out)
  GoogleProtobuf = Google.Protobuf
end)
System.namespace("Google.Protobuf", function (namespace)
  -- <summary>
  -- Reads and decodes protocol message fields.
  -- </summary>
  -- <para>
  -- This class is generally used by generated code to read appropriate
  -- primitives from the stream. It effectively encapsulates the lowest
  -- levels of protocol buffer format.
  -- </para>
  -- <para>
  -- Repeated fields and map fields are not handled by this class; use <see cref="RepeatedField{T}"/>
  -- and <see cref="MapField{TKey, TValue}"/> to serialize such fields.
  -- </para>
  -- </remarks>
  namespace.class("CodedInputStream", function (namespace)
    local Reset, CreateWithLimits, getPosition, getLastTag, getSizeLimit, getRecursionLimit, Dispose, CheckReadEndOfStreamTag, 
    PeekTag, ReadTag, SkipLastField, SkipGroup, ReadDouble, ReadFloat, ReadUInt64, ReadInt64, 
    ReadInt32, ReadFixed64, ReadFixed32, ReadBool, ReadString, ReadMessage, ReadBytes, ReadUInt32, 
    ReadEnum, ReadSFixed32, ReadSFixed64, ReadSInt32, ReadSInt64, ReadLength, MaybeConsumeTag, SlowReadRawVarint32, 
    ReadRawVarint32, ReadRawVarint321, ReadRawVarint64, ReadRawLittleEndian32, ReadRawLittleEndian64, DecodeZigZag32, DecodeZigZag64, PushLimit, 
    RecomputeBufferSizeAfterLimit, PopLimit, getReachedLimit, getIsAtEnd, RefillBuffer, ReadRawByte, ReadRawBytes, SkipRawBytes, 
    SkipImpl, class, __ctor1__, __ctor2__, __ctor3__, __ctor4__, __ctor5__, __ctor6__
    -- <summary>
    -- Creates a new CodedInputStream reading data from the given byte array.
    -- </summary>
    __ctor1__ = function (this, buffer)
      __ctor5__(this, nil, GoogleProtobuf.ProtoPreconditions.CheckNotNull(buffer, "buffer", ArrayByte), 0, #buffer, true)
    end
    -- <summary>
    -- Creates a new <see cref="CodedInputStream"/> that reads from the given byte array slice.
    -- </summary>
    __ctor2__ = function (this, buffer, offset, length)
      __ctor5__(this, nil, GoogleProtobuf.ProtoPreconditions.CheckNotNull(buffer, "buffer", ArrayByte), offset, offset + length, true)
      if offset < 0 or offset > #buffer then
        System.throw(System.ArgumentOutOfRangeException("offset", "Offset must be within the buffer"))
      end
      if length < 0 or offset + length > #buffer then
        System.throw(System.ArgumentOutOfRangeException("length", "Length must be non-negative and within the buffer"))
      end
    end
    -- <summary>
    -- Creates a new <see cref="CodedInputStream"/> reading data from the given stream, which will be disposed
    -- when the returned object is disposed.
    -- </summary>
    __ctor3__ = function (this, input)
      __ctor4__(this, input, false)
    end
    -- <summary>
    -- Creates a new <see cref="CodedInputStream"/> reading data from the given stream.
    -- </summary>
    -- <param name="leaveOpen"><c>true</c> to leave <paramref name="input"/> open when the returned
    -- <c cref="CodedInputStream"/> is disposed; <c>false</c> to dispose of the given stream when the
    -- returned object is disposed.</param>
    __ctor4__ = function (this, input, leaveOpen)
      __ctor5__(this, GoogleProtobuf.ProtoPreconditions.CheckNotNull(input, "input", SystemIO.Stream), ArrayByte:new(4096 --[[CodedInputStream.BufferSize]]), 0, 0, leaveOpen)
    end
    -- <summary>
    -- Creates a new CodedInputStream reading data from the given
    -- stream and buffer, using the default limits.
    -- </summary>
    __ctor5__ = function (this, input, buffer, bufferPos, bufferSize, leaveOpen)
      this.input = input
      this.buffer = buffer
      this.bufferPos = bufferPos
      this.bufferSize = bufferSize
      this.sizeLimit = 67108864 --[[CodedInputStream.DefaultSizeLimit]]
      this.recursionLimit = 64 --[[CodedInputStream.DefaultRecursionLimit]]
      this.leaveOpen = leaveOpen
    end
    -- <summary>
    -- Creates a new CodedInputStream reading data from the given
    -- stream and buffer, using the specified limits.
    -- </summary>
    -- This chains to the version with the default limits instead of vice versa to avoid
    -- having to check that the default values are valid every time.
    -- </remarks>
    __ctor6__ = function (this, input, buffer, bufferPos, bufferSize, sizeLimit, recursionLimit, leaveOpen)
      __ctor5__(this, input, buffer, bufferPos, bufferSize, leaveOpen)
      if sizeLimit <= 0 then
        System.throw(System.ArgumentOutOfRangeException("sizeLimit", "Size limit must be positive"))
      end
      if recursionLimit <= 0 then
        System.throw(System.ArgumentOutOfRangeException("recursionLimit!", "Recursion limit must be positive"))
      end
      this.sizeLimit = sizeLimit
      this.recursionLimit = recursionLimit
    end
    Reset = function (this, buf, offset, length)
      this.buffer = buf
      this.bufferPos = offset
      this.bufferSize = length
      this.sizeLimit = 67108864 --[[CodedInputStream.DefaultSizeLimit]]
      this.recursionLimit = 64 --[[CodedInputStream.DefaultRecursionLimit]]
      this.leaveOpen = true

      this.bufferSizeAfterLimit = 0
      this.lastTag = 0
      this.nextTag = 0
      this.hasNextTag = false
      this.totalBytesRetired = 0
      this.currentLimit = 2147483647 --[[Int32.MaxValue]]
      this.sizeLimit = 0
      this.recursionDepth = 0
    end
    -- <summary>
    -- Creates a <see cref="CodedInputStream"/> with the specified size and recursion limits, reading
    -- from an input stream.
    -- </summary>
    -- This method exists separately from the constructor to reduce the number of constructor overloads.
    -- It is likely to be used considerably less frequently than the constructors, as the default limits
    -- are suitable for most use cases.
    -- </remarks>
    -- <param name="input">The input stream to read from</param>
    -- <param name="sizeLimit">The total limit of data to read from the stream.</param>
    -- <param name="recursionLimit">The maximum recursion depth to allow while reading.</param>
    -- <returns>A <c>CodedInputStream</c> reading from <paramref name="input"/> with the specified size
    -- and recursion limits.</returns>
    CreateWithLimits = function (input, sizeLimit, recursionLimit)
      -- Note: we may want an overload accepting leaveOpen
      return System.new(class, 6, input, ArrayByte:new(4096 --[[CodedInputStream.BufferSize]]), 0, 0, sizeLimit, recursionLimit, false)
    end
    getPosition = function (this)
      if this.input ~= nil then
        return this.input:getPosition() - ((this.bufferSize + this.bufferSizeAfterLimit) - this.bufferPos)
      end
      return this.bufferPos
    end
    getLastTag = function (this)
      return this.lastTag
    end
    getSizeLimit = function (this)
      return this.sizeLimit
    end
    getRecursionLimit = function (this)
      return this.recursionLimit
    end
    -- <summary>
    -- Disposes of this instance, potentially closing any underlying stream.
    -- </summary>
    -- As there is no flushing to perform here, disposing of a <see cref="CodedInputStream"/> which
    -- was constructed with the <c>leaveOpen</c> option parameter set to <c>true</c> (or one which
    -- was constructed to read from a byte array) has no effect.
    -- </remarks>
    Dispose = function (this)
      if not this.leaveOpen then
        this.input:Dispose()
      end
    end
    -- <summary>
    -- Verifies that the last call to ReadTag() returned tag 0 - in other words,
    -- we've reached the end of the stream when we expected to.
    -- </summary>
    -- tag read was not the one specified</exception>
    CheckReadEndOfStreamTag = function (this)
      if this.lastTag ~= 0 then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.MoreDataAvailable())
      end
    end
    -- <summary>
    -- Peeks at the next field tag. This is like calling <see cref="ReadTag"/>, but the
    -- tag is not consumed. (So a subsequent call to <see cref="ReadTag"/> will return the
    -- same value.)
    -- </summary>
    PeekTag = function (this)
      if this.hasNextTag then
        return this.nextTag
      end

      local savedLast = this.lastTag
      this.nextTag = ReadTag(this)
      this.hasNextTag = true
      this.lastTag = savedLast
      -- Undo the side effect of ReadTag
      return this.nextTag
    end
    -- <summary>
    -- Reads a field tag, returning the tag of 0 for "end of stream".
    -- </summary>
    -- If this method returns 0, it doesn't necessarily mean the end of all
    -- the data in this CodedInputStream; it may be the end of the logical stream
    -- for an embedded message, for example.
    -- </remarks>
    -- <returns>The next field tag, or 0 for end of stream. (0 is never a valid tag.)</returns>
    ReadTag = function (this)
      if this.hasNextTag then
        this.lastTag = this.nextTag
        this.hasNextTag = false
        return this.lastTag
      end

      -- Optimize for the incredibly common case of having at least two bytes left in the buffer,
      -- and those two bytes being enough to get the tag. This will be true for fields up to 4095.
      if this.bufferPos + 2 <= this.bufferSize then
        local default = this.bufferPos
        this.bufferPos = default + 1
        local tmp = this.buffer:get(default)
        if tmp < 128 then
          this.lastTag = System.toUInt32(tmp)
        else
          local result = System.band(tmp, 0x7f)
          local extern = this.bufferPos
          this.bufferPos = extern + 1
          tmp = this.buffer:get(extern)
          if tmp < 128 then
            result = System.bor(result, System.sl(tmp, 7))
            this.lastTag = System.toUInt32(result)
          else
            -- Nope, rewind and go the potentially slow route.
            this.bufferPos = this.bufferPos - 2
            this.lastTag = ReadRawVarint32(this)
          end
        end
      else
        if getIsAtEnd(this) then
          this.lastTag = 0
          return 0
          -- This is the only case in which we return 0.
        end

        this.lastTag = ReadRawVarint32(this)
      end
      if this.lastTag == 0 then
        -- If we actually read zero, that's not a valid tag.
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.InvalidTag())
      end
      return this.lastTag
    end
    -- <summary>
    -- Skips the data for the field with the tag we've just read.
    -- This should be called directly after <see cref="ReadTag"/>, when
    -- the caller wishes to skip an unknown field.
    -- </summary>
    -- This method throws <see cref="InvalidProtocolBufferException"/> if the last-read tag was an end-group tag.
    -- If a caller wishes to skip a group, they should skip the whole group, by calling this method after reading the
    -- start-group tag. This behavior allows callers to call this method on any field they don't understand, correctly
    -- resulting in an error if an end-group tag has not been paired with an earlier start-group tag.
    -- </remarks>
    -- <exception cref="InvalidProtocolBufferException">The last tag was an end-group tag</exception>
    -- <exception cref="InvalidOperationException">The last read operation read to the end of the logical stream</exception>
    SkipLastField = function (this)
      if this.lastTag == 0 then
        System.throw(System.InvalidOperationException("SkipLastField cannot be called at the end of a stream"))
      end
      repeat
        local default = GoogleProtobuf.WireFormat.GetTagWireType(this.lastTag)
        if default == 3 --[[WireType.StartGroup]] then
          SkipGroup(this, this.lastTag)
          break
        elseif default == 4 --[[WireType.EndGroup]] then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException("SkipLastField called on an end-group tag, indicating that the corresponding start-group was missing"))
        elseif default == 5 --[[WireType.Fixed32]] then
          ReadFixed32(this)
          break
        elseif default == 1 --[[WireType.Fixed64]] then
          ReadFixed64(this)
          break
        elseif default == 2 --[[WireType.LengthDelimited]] then
          local length = ReadLength(this)
          SkipRawBytes(this, length)
          break
        elseif default == 0 --[[WireType.Varint]] then
          ReadRawVarint32(this)
          break
        end
      until 1
    end
    SkipGroup = function (this, startGroupTag)
      -- Note: Currently we expect this to be the way that groups are read. We could put the recursion
      -- depth changes into the ReadTag method instead, potentially...
      this.recursionDepth = this.recursionDepth + 1
      if this.recursionDepth >= this.recursionLimit then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.RecursionLimitExceeded())
      end
      local tag
      while true do
        tag = ReadTag(this)
        if tag == 0 then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
        end
        -- Can't call SkipLastField for this case- that would throw.
        if GoogleProtobuf.WireFormat.GetTagWireType(tag) == 4 --[[WireType.EndGroup]] then
          break
        end
        -- This recursion will allow us to handle nested groups.
        SkipLastField(this)
      end
      local startField = GoogleProtobuf.WireFormat.GetTagFieldNumber(startGroupTag)
      local endField = GoogleProtobuf.WireFormat.GetTagFieldNumber(tag)
      if startField ~= endField then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException("Mismatched end-group tag. Started with field " .. startField .. "; ended with field " .. endField))
      end
      this.recursionDepth = this.recursionDepth - 1
    end
    -- <summary>
    -- Reads a double field from the stream.
    -- </summary>
    ReadDouble = function (this)
      return System.BitConverter.Int64BitsToDouble(System.toInt64(ReadRawLittleEndian64(this)))
    end
    -- <summary>
    -- Reads a float field from the stream.
    -- </summary>
    ReadFloat = function (this)
      if System.BitConverter.IsLittleEndian and 4 <= this.bufferSize - this.bufferPos then
        local ret = System.BitConverter.ToSingle(this.buffer, this.bufferPos)
        this.bufferPos = this.bufferPos + 4
        return ret
      else
        local rawBytes = ReadRawBytes(this, 4)
        if not System.BitConverter.IsLittleEndian then
          GoogleProtobuf.ByteArray.Reverse(rawBytes)
        end
        return System.BitConverter.ToSingle(rawBytes, 0)
      end
    end
    -- <summary>
    -- Reads a uint64 field from the stream.
    -- </summary>
    ReadUInt64 = function (this)
      return ReadRawVarint64(this)
    end
    -- <summary>
    -- Reads an int64 field from the stream.
    -- </summary>
    ReadInt64 = function (this)
      return System.toInt64(ReadRawVarint64(this))
    end
    -- <summary>
    -- Reads an int32 field from the stream.
    -- </summary>
    ReadInt32 = function (this)
      return System.toInt32(ReadRawVarint32(this))
    end
    -- <summary>
    -- Reads a fixed64 field from the stream.
    -- </summary>
    ReadFixed64 = function (this)
      return ReadRawLittleEndian64(this)
    end
    -- <summary>
    -- Reads a fixed32 field from the stream.
    -- </summary>
    ReadFixed32 = function (this)
      return ReadRawLittleEndian32(this)
    end
    -- <summary>
    -- Reads a bool field from the stream.
    -- </summary>
    ReadBool = function (this)
      return ReadRawVarint32(this) ~= 0
    end
    -- <summary>
    -- Reads a string field from the stream.
    -- </summary>
    ReadString = function (this)
      local length = ReadLength(this)
      -- No need to read any data for an empty string.
      if length == 0 then
        return ""
      end
      if length <= this.bufferSize - this.bufferPos then
        -- Fast path:  We already have the bytes in a contiguous buffer, so
        --   just copy directly from it.
        local result = GoogleProtobuf.CodedOutputStream.Utf8Encoding:GetString(this.buffer, this.bufferPos, length)
        this.bufferPos = this.bufferPos + length
        return result
      end
      -- Slow path: Build a byte array first then copy it.
      return GoogleProtobuf.CodedOutputStream.Utf8Encoding:GetString(ReadRawBytes(this, length), 0, length)
    end
    -- <summary>
    -- Reads an embedded message field value from the stream.
    -- </summary>
    ReadMessage = function (this, builder)
      local length = ReadLength(this)
      if this.recursionDepth >= this.recursionLimit then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.RecursionLimitExceeded())
      end
      local oldLimit = PushLimit(this, length)
      this.recursionDepth = this.recursionDepth + 1
      builder:MergeFrom(this)
      CheckReadEndOfStreamTag(this)
      -- Check that we've read exactly as much data as expected.
      if not getReachedLimit(this) then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
      end
      this.recursionDepth = this.recursionDepth - 1
      PopLimit(this, oldLimit)
    end
    -- <summary>
    -- Reads a bytes field value from the stream.
    -- </summary>
    ReadBytes = function (this)
      local length = ReadLength(this)
      if length <= this.bufferSize - this.bufferPos and length > 0 then
        -- Fast path:  We already have the bytes in a contiguous buffer, so
        --   just copy directly from it.
        local result = GoogleProtobuf.ByteString.CopyFrom1(this.buffer, this.bufferPos, length)
        this.bufferPos = this.bufferPos + length
        return result
      else
        -- Slow path:  Build a byte array and attach it to a new ByteString.
        return GoogleProtobuf.ByteString.AttachBytes(ReadRawBytes(this, length))
      end
    end
    -- <summary>
    -- Reads a uint32 field value from the stream.
    -- </summary>
    ReadUInt32 = function (this)
      return ReadRawVarint32(this)
    end
    -- <summary>
    -- Reads an enum field value from the stream.
    -- </summary>
    ReadEnum = function (this)
      -- Currently just a pass-through, but it's nice to separate it logically from WriteInt32.
      return System.toInt32(ReadRawVarint32(this))
    end
    -- <summary>
    -- Reads an sfixed32 field value from the stream.
    -- </summary>
    ReadSFixed32 = function (this)
      return System.toInt32(ReadRawLittleEndian32(this))
    end
    -- <summary>
    -- Reads an sfixed64 field value from the stream.
    -- </summary>
    ReadSFixed64 = function (this)
      return System.toInt64(ReadRawLittleEndian64(this))
    end
    -- <summary>
    -- Reads an sint32 field value from the stream.
    -- </summary>
    ReadSInt32 = function (this)
      return DecodeZigZag32(ReadRawVarint32(this))
    end
    -- <summary>
    -- Reads an sint64 field value from the stream.
    -- </summary>
    ReadSInt64 = function (this)
      return DecodeZigZag64(ReadRawVarint64(this))
    end
    -- <summary>
    -- Reads a length for length-delimited data.
    -- </summary>
    -- This is internally just reading a varint, but this method exists
    -- to make the calling code clearer.
    -- </remarks>
    ReadLength = function (this)
      return System.toInt32(ReadRawVarint32(this))
    end
    -- <summary>
    -- Peeks at the next tag in the stream. If it matches <paramref name="tag"/>,
    -- the tag is consumed and the method returns <c>true</c>; otherwise, the
    -- stream is left in the original position and the method returns <c>false</c>.
    -- </summary>
    MaybeConsumeTag = function (this, tag)
      if PeekTag(this) == tag then
        this.hasNextTag = false
        return true
      end
      return false
    end
    -- <summary>
    -- Same code as ReadRawVarint32, but read each byte individually, checking for
    -- buffer overflow.
    -- </summary>
    SlowReadRawVarint32 = function (this)
      local tmp = ReadRawByte(this)
      if tmp < 128 then
        return System.toUInt32(tmp)
      end
      local result = System.band(tmp, 0x7f)
      tmp = ReadRawByte(this)
      if tmp < 128 then
        result = System.bor(result, System.sl(tmp, 7))
      else
        result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 7))
        tmp = ReadRawByte(this)
        if tmp < 128 then
          result = System.bor(result, System.sl(tmp, 14))
        else
          result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 14))
          tmp = ReadRawByte(this)
          if tmp < 128 then
            result = System.bor(result, System.sl(tmp, 21))
          else
            result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 21))
            tmp = ReadRawByte(this)
            result = System.bor(result, System.sl(tmp, 28))
            if tmp >= 128 then
              -- Discard upper 32 bits.
              for i = 0, 4 do
                if ReadRawByte(this) < 128 then
                  return System.toUInt32(result)
                end
              end
              System.throw(GoogleProtobuf.InvalidProtocolBufferException.MalformedVarint())
            end
          end
        end
      end
      return System.toUInt32(result)
    end
    -- <summary>
    -- Reads a raw Varint from the stream.  If larger than 32 bits, discard the upper bits.
    -- This method is optimised for the case where we've got lots of data in the buffer.
    -- That means we can check the size just once, then just read directly from the buffer
    -- without constant rechecking of the buffer length.
    -- </summary>
    ReadRawVarint32 = function (this)
      if this.bufferPos + 5 > this.bufferSize then
        return SlowReadRawVarint32(this)
      end

      local default = this.bufferPos
      this.bufferPos = default + 1
      local tmp = this.buffer:get(default)
      if tmp < 128 then
        return System.toUInt32(tmp)
      end
      local result = System.band(tmp, 0x7f)
      local extern = this.bufferPos
      this.bufferPos = extern + 1
      tmp = this.buffer:get(extern)
      if tmp < 128 then
        result = System.bor(result, System.sl(tmp, 7))
      else
        result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 7))
        local ref = this.bufferPos
        this.bufferPos = ref + 1
        tmp = this.buffer:get(ref)
        if tmp < 128 then
          result = System.bor(result, System.sl(tmp, 14))
        else
          result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 14))
          local out = this.bufferPos
          this.bufferPos = out + 1
          tmp = this.buffer:get(out)
          if tmp < 128 then
            result = System.bor(result, System.sl(tmp, 21))
          else
            result = System.bor(result, System.sl((System.band(tmp, 0x7f)), 21))
            local try = this.bufferPos
            this.bufferPos = try + 1
            tmp = this.buffer:get(try)
            result = System.bor(result, System.sl(tmp, 28))
            if tmp >= 128 then
              -- Discard upper 32 bits.
              -- Note that this has to use ReadRawByte() as we only ensure we've
              -- got at least 5 bytes at the start of the method. This lets us
              -- use the fast path in more cases, and we rarely hit this section of code.
              for i = 0, 4 do
                if ReadRawByte(this) < 128 then
                  return System.toUInt32(result)
                end
              end
              System.throw(GoogleProtobuf.InvalidProtocolBufferException.MalformedVarint())
            end
          end
        end
      end
      return System.toUInt32(result)
    end
    -- <summary>
    -- Reads a varint from the input one byte at a time, so that it does not
    -- read any bytes after the end of the varint. If you simply wrapped the
    -- stream in a CodedInputStream and used ReadRawVarint32(Stream)
    -- then you would probably end up reading past the end of the varint since
    -- CodedInputStream buffers its input.
    -- </summary>
    -- <returns></returns>
    ReadRawVarint321 = function (input)
      local result = 0
      local offset = 0
      do
        while offset < 32 do
          local b = input:ReadByte()
          if b == - 1 then
            System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
          end
          result = System.bor(result, System.sl((System.band(b, 0x7f)), offset))
          if (System.band(b, 0x80)) == 0 then
            return System.toUInt32(result)
          end
          offset = offset + 7
        end
      end
      -- Keep reading up to 64 bits.
      do
        while offset < 64 do
          local b = input:ReadByte()
          if b == - 1 then
            System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
          end
          if (System.band(b, 0x80)) == 0 then
            return System.toUInt32(result)
          end
          offset = offset + 7
        end
      end
      System.throw(GoogleProtobuf.InvalidProtocolBufferException.MalformedVarint())
    end
    -- <summary>
    -- Reads a raw varint from the stream.
    -- </summary>
    ReadRawVarint64 = function (this)
      local shift = 0
      local result = 0
      while shift < 64 do
        local b = ReadRawByte(this)
        result = System.bor(result, System.sl((System.band(b, 0x7F)), shift))
        if (System.band(b, 0x80)) == 0 then
          return result
        end
        shift = shift + 7
      end
      System.throw(GoogleProtobuf.InvalidProtocolBufferException.MalformedVarint())
    end
    -- <summary>
    -- Reads a 32-bit little-endian integer from the stream.
    -- </summary>
    ReadRawLittleEndian32 = function (this)
      local b1 = ReadRawByte(this)
      local b2 = ReadRawByte(this)
      local b3 = ReadRawByte(this)
      local b4 = ReadRawByte(this)
      return System.bor(System.bor(System.bor(b1, (System.sl(b2, 8))), (System.sl(b3, 16))), (System.sl(b4, 24)))
    end
    -- <summary>
    -- Reads a 64-bit little-endian integer from the stream.
    -- </summary>
    ReadRawLittleEndian64 = function (this)
      local b1 = ReadRawByte(this)
      local b2 = ReadRawByte(this)
      local b3 = ReadRawByte(this)
      local b4 = ReadRawByte(this)
      local b5 = ReadRawByte(this)
      local b6 = ReadRawByte(this)
      local b7 = ReadRawByte(this)
      local b8 = ReadRawByte(this)
      return System.bor(System.bor(System.bor(System.bor(System.bor(System.bor(System.bor(b1, (System.sl(b2, 8))), (System.sl(b3, 16))), (System.sl(b4, 24))), (System.sl(b5, 32))), (System.sl(b6, 40))), (System.sl(b7, 48))), (System.sl(b8, 56)))
    end
    -- <summary>
    -- Decode a 32-bit value with ZigZag encoding.
    -- </summary>
    -- ZigZag encodes signed integers into values that can be efficiently
    -- encoded with varint.  (Otherwise, negative values must be
    -- sign-extended to 64 bits to be varint encoded, thus always taking
    -- 10 bytes on the wire.)
    -- </remarks>
    DecodeZigZag32 = function (n)
      return System.xor(System.toInt32(System.sr(n, 1)), - System.toInt32(System.band(n, 1)))
    end
    -- <summary>
    -- Decode a 32-bit value with ZigZag encoding.
    -- </summary>
    -- ZigZag encodes signed integers into values that can be efficiently
    -- encoded with varint.  (Otherwise, negative values must be
    -- sign-extended to 64 bits to be varint encoded, thus always taking
    -- 10 bytes on the wire.)
    -- </remarks>
    DecodeZigZag64 = function (n)
      return System.xor(System.toInt64(System.sr(n, 1)), - System.toInt64(System.band(n, 1)))
    end
    -- <summary>
    -- Sets currentLimit to (current position) + byteLimit. This is called
    -- when descending into a length-delimited embedded message. The previous
    -- limit is returned.
    -- </summary>
    PushLimit = function (this, byteLimit)
      if byteLimit < 0 then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.NegativeSize())
      end
      byteLimit = byteLimit + (this.totalBytesRetired + this.bufferPos)
      local oldLimit = this.currentLimit
      if byteLimit > oldLimit then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
      end
      this.currentLimit = byteLimit

      RecomputeBufferSizeAfterLimit(this)

      return oldLimit
    end
    RecomputeBufferSizeAfterLimit = function (this)
      this.bufferSize = this.bufferSize + this.bufferSizeAfterLimit
      local bufferEnd = this.totalBytesRetired + this.bufferSize
      if bufferEnd > this.currentLimit then
        -- Limit is in current buffer.
        this.bufferSizeAfterLimit = bufferEnd - this.currentLimit
        this.bufferSize = this.bufferSize - this.bufferSizeAfterLimit
      else
        this.bufferSizeAfterLimit = 0
      end
    end
    -- <summary>
    -- Discards the current limit, returning the previous limit.
    -- </summary>
    PopLimit = function (this, oldLimit)
      this.currentLimit = oldLimit
      RecomputeBufferSizeAfterLimit(this)
    end
    getReachedLimit = function (this)
      if this.currentLimit == 2147483647 --[[Int32.MaxValue]] then
        return false
      end
      local currentAbsolutePosition = this.totalBytesRetired + this.bufferPos
      return currentAbsolutePosition >= this.currentLimit
    end
    getIsAtEnd = function (this)
      return this.bufferPos == this.bufferSize and not RefillBuffer(this, false)
    end
    -- <summary>
    -- Called when buffer is empty to read more bytes from the
    -- input.  If <paramref name="mustSucceed"/> is true, RefillBuffer() gurantees that
    -- either there will be at least one byte in the buffer when it returns
    -- or it will throw an exception.  If <paramref name="mustSucceed"/> is false,
    -- RefillBuffer() returns false if no more bytes were available.
    -- </summary>
    -- <returns></returns>
    RefillBuffer = function (this, mustSucceed)
      if this.bufferPos < this.bufferSize then
        System.throw(System.InvalidOperationException("RefillBuffer() called when buffer wasn't empty."))
      end

      if this.totalBytesRetired + this.bufferSize == this.currentLimit then
        -- Oops, we hit a limit.
        if mustSucceed then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
        else
          return false
        end
      end

      this.totalBytesRetired = this.totalBytesRetired + this.bufferSize

      this.bufferPos = 0
      this.bufferSize = (this.input == nil) and 0 or this.input:Read(this.buffer, 0, #this.buffer)
      if this.bufferSize < 0 then
        System.throw(System.InvalidOperationException("Stream.Read returned a negative count"))
      end
      if this.bufferSize == 0 then
        if mustSucceed then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
        else
          return false
        end
      else
        RecomputeBufferSizeAfterLimit(this)
        local totalBytesRead = this.totalBytesRetired + this.bufferSize + this.bufferSizeAfterLimit
        if totalBytesRead > this.sizeLimit or totalBytesRead < 0 then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException.SizeLimitExceeded())
        end
        return true
      end
    end
    -- <summary>
    -- Read one byte from the input.
    -- </summary>
    -- the end of the stream or the current limit was reached
    -- </exception>
    ReadRawByte = function (this)
      if this.bufferPos == this.bufferSize then
        RefillBuffer(this, true)
      end
      local default = this.bufferPos
      this.bufferPos = default + 1
      return this.buffer:get(default)
    end
    -- <summary>
    -- Reads a fixed size of bytes from the input.
    -- </summary>
    -- the end of the stream or the current limit was reached
    -- </exception>
    ReadRawBytes = function (this, size)
      if size < 0 then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.NegativeSize())
      end

      if this.totalBytesRetired + this.bufferPos + size > this.currentLimit then
        -- Read to the end of the stream (up to the current limit) anyway.
        SkipRawBytes(this, this.currentLimit - this.totalBytesRetired - this.bufferPos)
        -- Then fail.
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
      end

      if size <= this.bufferSize - this.bufferPos then
        -- We have all the bytes we need already.
        local bytes = ArrayByte:new(size)
        GoogleProtobuf.ByteArray.Copy(this.buffer, this.bufferPos, bytes, 0, size)
        this.bufferPos = this.bufferPos + size
        return bytes
      elseif size < #this.buffer then
        -- Reading more bytes than are in the buffer, but not an excessive number
        -- of bytes.  We can safely allocate the resulting array ahead of time.

        -- First copy what we have.
        local bytes = ArrayByte:new(size)
        local pos = this.bufferSize - this.bufferPos
        GoogleProtobuf.ByteArray.Copy(this.buffer, this.bufferPos, bytes, 0, pos)
        this.bufferPos = this.bufferSize

        -- We want to use RefillBuffer() and then copy from the buffer into our
        -- byte array rather than reading directly into our byte array because
        -- the input may be unbuffered.
        RefillBuffer(this, true)

        while size - pos > this.bufferSize do
          System.Buffer.BlockCopy(this.buffer, 0, bytes, pos, this.bufferSize)
          pos = pos + this.bufferSize
          this.bufferPos = this.bufferSize
          RefillBuffer(this, true)
        end

        GoogleProtobuf.ByteArray.Copy(this.buffer, 0, bytes, pos, size - pos)
        this.bufferPos = size - pos

        return bytes
      else
        -- The size is very large.  For security reasons, we can't allocate the
        -- entire byte array yet.  The size comes directly from the input, so a
        -- maliciously-crafted message could provide a bogus very large size in
        -- order to trick the app into allocating a lot of memory.  We avoid this
        -- by allocating and reading only a small chunk at a time, so that the
        -- malicious message must actually *be* extremely large to cause
        -- problems.  Meanwhile, we limit the allowed size of a message elsewhere.

        -- Remember the buffer markers since we'll have to copy the bytes out of
        -- it later.
        local originalBufferPos = this.bufferPos
        local originalBufferSize = this.bufferSize

        -- Mark the current buffer consumed.
        this.totalBytesRetired = this.totalBytesRetired + this.bufferSize
        this.bufferPos = 0
        this.bufferSize = 0

        -- Read all the rest of the bytes we need.
        local sizeLeft = size - (originalBufferSize - originalBufferPos)
        local chunks = ListArrayByte()

        while sizeLeft > 0 do
          local chunk = ArrayByte:new(math.Min(sizeLeft, #this.buffer))
          local pos = 0
          while pos < #chunk do
            local n = (this.input == nil) and - 1 or this.input:Read(chunk, pos, #chunk - pos)
            if n <= 0 then
              System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
            end
            this.totalBytesRetired = this.totalBytesRetired + n
            pos = pos + n
          end
          sizeLeft = sizeLeft - #chunk
          chunks:Add(chunk)
        end

        -- OK, got everything.  Now concatenate it all into one buffer.
        local bytes = ArrayByte:new(size)

        -- Start by copying the leftover bytes from this.buffer.
        local newPos = originalBufferSize - originalBufferPos
        GoogleProtobuf.ByteArray.Copy(this.buffer, originalBufferPos, bytes, 0, newPos)

        -- And now all the chunks.
        for _, chunk in System.each(chunks) do
          System.Buffer.BlockCopy(chunk, 0, bytes, newPos, #chunk)
          newPos = newPos + #chunk
        end

        -- Done.
        return bytes
      end
    end
    -- <summary>
    -- Reads and discards <paramref name="size"/> bytes.
    -- </summary>
    -- or the current limit was reached</exception>
    SkipRawBytes = function (this, size)
      if size < 0 then
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.NegativeSize())
      end

      if this.totalBytesRetired + this.bufferPos + size > this.currentLimit then
        -- Read to the end of the stream anyway.
        SkipRawBytes(this, this.currentLimit - this.totalBytesRetired - this.bufferPos)
        -- Then fail.
        System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
      end

      if size <= this.bufferSize - this.bufferPos then
        -- We have all the bytes we need already.
        this.bufferPos = this.bufferPos + size
      else
        -- Skipping more bytes than are in the buffer.  First skip what we have.
        local pos = this.bufferSize - this.bufferPos

        -- ROK 5/7/2013 Issue #54: should retire all bytes in buffer (bufferSize)
        -- totalBytesRetired += pos;
        this.totalBytesRetired = this.totalBytesRetired + this.bufferSize

        this.bufferPos = 0
        this.bufferSize = 0

        -- Then skip directly from the InputStream for the rest.
        if pos < size then
          if this.input == nil then
            System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
          end
          SkipImpl(this, size - pos)
          this.totalBytesRetired = this.totalBytesRetired + (size - pos)
        end
      end
    end
    -- <summary>
    -- Abstraction of skipping to cope with streams which can't really skip.
    -- </summary>
    SkipImpl = function (this, amountToSkip)
      if this.input:getCanSeek() then
        local previousPosition = this.input:getPosition()
        this.input:setPosition(this.input:getPosition() + amountToSkip)
        if this.input:getPosition() ~= previousPosition + amountToSkip then
          System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
        end
      else
        local skipBuffer = ArrayByte:new(math.Min(1024, amountToSkip))
        while amountToSkip > 0 do
          local bytesRead = this.input:Read(skipBuffer, 0, math.Min(#skipBuffer, amountToSkip))
          if bytesRead <= 0 then
            System.throw(GoogleProtobuf.InvalidProtocolBufferException.TruncatedMessage())
          end
          amountToSkip = amountToSkip - bytesRead
        end
      end
    end
    class = {
      base = function (out)
        return {
          System.IDisposable
        }
      end,
      leaveOpen = false,
      bufferSize = 0,
      bufferSizeAfterLimit = 0,
      bufferPos = 0,
      lastTag = 0,
      nextTag = 0,
      hasNextTag = false,
      totalBytesRetired = 0,
      currentLimit = 2147483647 --[[Int32.MaxValue]],
      recursionDepth = 0,
      recursionLimit = 0,
      sizeLimit = 0,
      Reset = Reset,
      CreateWithLimits = CreateWithLimits,
      getPosition = getPosition,
      getLastTag = getLastTag,
      getSizeLimit = getSizeLimit,
      getRecursionLimit = getRecursionLimit,
      Dispose = Dispose,
      CheckReadEndOfStreamTag = CheckReadEndOfStreamTag,
      PeekTag = PeekTag,
      ReadTag = ReadTag,
      SkipLastField = SkipLastField,
      ReadDouble = ReadDouble,
      ReadFloat = ReadFloat,
      ReadUInt64 = ReadUInt64,
      ReadInt64 = ReadInt64,
      ReadInt32 = ReadInt32,
      ReadFixed64 = ReadFixed64,
      ReadFixed32 = ReadFixed32,
      ReadBool = ReadBool,
      ReadString = ReadString,
      ReadMessage = ReadMessage,
      ReadBytes = ReadBytes,
      ReadUInt32 = ReadUInt32,
      ReadEnum = ReadEnum,
      ReadSFixed32 = ReadSFixed32,
      ReadSFixed64 = ReadSFixed64,
      ReadSInt32 = ReadSInt32,
      ReadSInt64 = ReadSInt64,
      ReadLength = ReadLength,
      MaybeConsumeTag = MaybeConsumeTag,
      ReadRawVarint32 = ReadRawVarint32,
      ReadRawVarint321 = ReadRawVarint321,
      ReadRawVarint64 = ReadRawVarint64,
      ReadRawLittleEndian32 = ReadRawLittleEndian32,
      ReadRawLittleEndian64 = ReadRawLittleEndian64,
      DecodeZigZag32 = DecodeZigZag32,
      DecodeZigZag64 = DecodeZigZag64,
      PushLimit = PushLimit,
      PopLimit = PopLimit,
      getReachedLimit = getReachedLimit,
      getIsAtEnd = getIsAtEnd,
      ReadRawByte = ReadRawByte,
      ReadRawBytes = ReadRawBytes,
      __ctor__ = {
        __ctor1__,
        __ctor2__,
        __ctor3__,
        __ctor4__,
        __ctor5__,
        __ctor6__
      }
    }
    return class
  end)
end)
