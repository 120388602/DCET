-- Generated by CSharp.lua Compiler
--#region Copyright notice and license
-- Protocol Buffers - Google's data interchange format
-- Copyright 2015 Google Inc.  All rights reserved.
-- https://developers.google.com/protocol-buffers/
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     * Redistributions of source code must retain the above copyright
-- notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above
-- copyright notice, this list of conditions and the following disclaimer
-- in the documentation and/or other materials provided with the
-- distribution.
--     * Neither the name of Google Inc. nor the names of its
-- contributors may be used to endorse or promote products derived from
-- this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--#endregion
local System = System
local GoogleProtobuf
local FieldCodec_1Int32
local FieldCodec_1Int64
local FieldCodec_1Double
local FieldCodec_1Single
local FieldCodec_1String
local FieldCodec_1UInt32
local FieldCodec_1UInt64
local FieldCodec_1Boolean
local FieldCodec_1ByteString
System.import(function (out)
  GoogleProtobuf = Google.Protobuf
  FieldCodec_1Int32 = GoogleProtobuf.FieldCodec_1(System.Int32)
  FieldCodec_1Int64 = GoogleProtobuf.FieldCodec_1(System.Int64)
  FieldCodec_1Double = GoogleProtobuf.FieldCodec_1(System.Double)
  FieldCodec_1Single = GoogleProtobuf.FieldCodec_1(System.Single)
  FieldCodec_1String = GoogleProtobuf.FieldCodec_1(System.String)
  FieldCodec_1UInt32 = GoogleProtobuf.FieldCodec_1(System.UInt32)
  FieldCodec_1UInt64 = GoogleProtobuf.FieldCodec_1(System.UInt64)
  FieldCodec_1Boolean = GoogleProtobuf.FieldCodec_1(System.Boolean)
  FieldCodec_1ByteString = GoogleProtobuf.FieldCodec_1(GoogleProtobuf.ByteString)
end)
System.namespace("Google.Protobuf", function (namespace)
  -- <summary>
  -- Factory methods for <see cref="FieldCodec{T}"/>.
  -- </summary>
  namespace.class("FieldCodec", function (namespace)
    local ForString, ForBytes, ForBool, ForInt32, ForSInt32, ForFixed32, ForSFixed32, ForUInt32, 
    ForInt64, ForSInt64, ForFixed64, ForSFixed64, ForUInt64, ForFloat, ForDouble, ForEnum, 
    ForMessage
    -- <summary>
    -- Retrieves a codec suitable for a string field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForString = function (tag)
      return System.new(FieldCodec_1String, 2, function (input)
        return input:ReadString()
      end, function (output, value)
        output:WriteString(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeStringSize, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a bytes field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForBytes = function (tag)
      return System.new(FieldCodec_1ByteString, 2, function (input)
        return input:ReadBytes()
      end, function (output, value)
        output:WriteBytes(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeBytesSize, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a bool field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForBool = function (tag)
      return System.new(FieldCodec_1Boolean, 2, function (input)
        return input:ReadBool()
      end, function (output, value)
        output:WriteBool(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeBoolSize, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an int32 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForInt32 = function (tag)
      return System.new(FieldCodec_1Int32, 2, function (input)
        return input:ReadInt32()
      end, function (output, value)
        output:WriteInt32(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeInt32Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an sint32 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForSInt32 = function (tag)
      return System.new(FieldCodec_1Int32, 2, function (input)
        return input:ReadSInt32()
      end, function (output, value)
        output:WriteSInt32(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeSInt32Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a fixed32 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForFixed32 = function (tag)
      return FieldCodec_1UInt32(function (input)
        return input:ReadFixed32()
      end, function (output, value)
        output:WriteFixed32(value)
      end, 4, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an sfixed32 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForSFixed32 = function (tag)
      return FieldCodec_1Int32(function (input)
        return input:ReadSFixed32()
      end, function (output, value)
        output:WriteSFixed32(value)
      end, 4, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a uint32 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForUInt32 = function (tag)
      return System.new(FieldCodec_1UInt32, 2, function (input)
        return input:ReadUInt32()
      end, function (output, value)
        output:WriteUInt32(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeUInt32Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an int64 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForInt64 = function (tag)
      return System.new(FieldCodec_1Int64, 2, function (input)
        return input:ReadInt64()
      end, function (output, value)
        output:WriteInt64(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeInt64Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an sint64 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForSInt64 = function (tag)
      return System.new(FieldCodec_1Int64, 2, function (input)
        return input:ReadSInt64()
      end, function (output, value)
        output:WriteSInt64(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeSInt64Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a fixed64 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForFixed64 = function (tag)
      return FieldCodec_1UInt64(function (input)
        return input:ReadFixed64()
      end, function (output, value)
        output:WriteFixed64(value)
      end, 8, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an sfixed64 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForSFixed64 = function (tag)
      return FieldCodec_1Int64(function (input)
        return input:ReadSFixed64()
      end, function (output, value)
        output:WriteSFixed64(value)
      end, 8, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a uint64 field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForUInt64 = function (tag)
      return System.new(FieldCodec_1UInt64, 2, function (input)
        return input:ReadUInt64()
      end, function (output, value)
        output:WriteUInt64(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeUInt64Size, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a float field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForFloat = function (tag)
      return System.new(FieldCodec_1Single, 2, function (input)
        return input:ReadFloat()
      end, function (output, value)
        output:WriteFloat(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeFloatSize, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a double field with the given tag.
    -- </summary>
    -- <returns>A codec for the given tag.</returns>
    ForDouble = function (tag)
      return System.new(FieldCodec_1Double, 2, function (input)
        return input:ReadDouble()
      end, function (output, value)
        output:WriteDouble(value)
      end, GoogleProtobuf.CodedOutputStream.ComputeDoubleSize, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for an enum field with the given tag.
    -- </summary>
    -- <param name="toInt32">A conversion function from <see cref="Int32"/> to the enum type.</param>
    -- <param name="fromInt32">A conversion function from the enum type to <see cref="Int32"/>.</param>
    -- <returns>A codec for the given tag.</returns>
    ForEnum = function (tag, toInt32, fromInt32, T)
      return System.new(GoogleProtobuf.FieldCodec_1(T), 2, function (input)
        return fromInt32(input:ReadEnum(), T)
      end, function (output, value)
        output:WriteEnum(toInt32(value, T))
      end, function (value)
        return GoogleProtobuf.CodedOutputStream.ComputeEnumSize(toInt32(value, T))
      end, tag)
    end
    -- <summary>
    -- Retrieves a codec suitable for a message field with the given tag.
    -- </summary>
    -- <param name="parser">A parser to use for the message type.</param>
    -- <returns>A codec for the given tag.</returns>
    ForMessage = function (tag, parser, T)
      return System.new(GoogleProtobuf.FieldCodec_1(T), 2, function (input)
        local message = parser:CreateTemplate1()
        input:ReadMessage(message)
        return message
      end, function (output, value)
        output:WriteMessage(value)
      end, function (message)
        return GoogleProtobuf.CodedOutputStream.ComputeMessageSize(message)
      end, tag)
    end
    return {
      ForString = ForString,
      ForBytes = ForBytes,
      ForBool = ForBool,
      ForInt32 = ForInt32,
      ForSInt32 = ForSInt32,
      ForFixed32 = ForFixed32,
      ForSFixed32 = ForSFixed32,
      ForUInt32 = ForUInt32,
      ForInt64 = ForInt64,
      ForSInt64 = ForSInt64,
      ForFixed64 = ForFixed64,
      ForSFixed64 = ForSFixed64,
      ForUInt64 = ForUInt64,
      ForFloat = ForFloat,
      ForDouble = ForDouble,
      ForEnum = ForEnum,
      ForMessage = ForMessage
    }
  end)

  -- <summary>
  -- <para>
  -- An encode/decode pair for a single field. This effectively encapsulates
  -- all the information needed to read or write the field value from/to a coded
  -- stream.
  -- </para>
  -- <para>
  -- This class is public and has to be as it is used by generated code, but its public
  -- API is very limited - just what the generated code needs to call directly.
  -- </para>
  -- </summary>
  -- This never writes default values to the stream, and does not address "packedness"
  -- in repeated fields itself, other than to know whether or not the field *should* be packed.
  -- </remarks>
  namespace.class("FieldCodec_1", function (namespace)
    return function (T)
      local DefaultDefault, TypeSupportsPacking, IsPackedRepeatedField, WriteTagAndValue, Read, CalculateSizeWithTag, IsDefault, static, 
      internal, __ctor1__, __ctor2__, __ctor3__
      local EqualityComparerT = System.EqualityComparer(T)
      static = function (this)
        DefaultDefault = System.default(T)
        TypeSupportsPacking = System.default(T) ~= nil
        if System.typeof(T) == System.typeof(System.String) then
          DefaultDefault = System.cast(T, "")
        elseif System.typeof(T) == System.typeof(GoogleProtobuf.ByteString) then
          DefaultDefault = System.cast(T, GoogleProtobuf.ByteString.getEmpty())
        end
        -- Otherwise it's the default value of the CLR type
      end
      internal = function (this)
        this.DefaultValue = System.default(T)
      end
      __ctor1__ = function (this, reader, writer, fixedSize, tag)
        __ctor2__(this, reader, writer, function (_)
          return fixedSize
        end, tag)
        this.FixedSize = fixedSize
      end
      __ctor2__ = function (this, reader, writer, sizeCalculator, tag)
        __ctor3__(this, reader, writer, sizeCalculator, tag, DefaultDefault)
      end
      __ctor3__ = function (this, reader, writer, sizeCalculator, tag, defaultValue)
        internal(this)
        this.ValueReader = reader
        this.ValueWriter = writer
        this.ValueSizeCalculator = sizeCalculator
        this.FixedSize = 0
        this.Tag = tag
        this.DefaultValue = defaultValue
        this.tagSize = GoogleProtobuf.CodedOutputStream.ComputeRawVarint32Size(tag)
        -- Detect packed-ness once, so we can check for it within RepeatedField<T>.
        this.PackedRepeatedField = IsPackedRepeatedField(tag)
      end
      IsPackedRepeatedField = function (tag)
        return TypeSupportsPacking and GoogleProtobuf.WireFormat.GetTagWireType(tag) == 2 --[[WireType.LengthDelimited]]
      end
      -- <summary>
      -- Write a tag and the given value, *if* the value is not the default.
      -- </summary>
      WriteTagAndValue = function (this, output, value)
        if not IsDefault(this, value) then
          output:WriteTag1(this.Tag)
          this.ValueWriter(output, value, T)
        end
      end
      -- <summary>
      -- Reads a value of the codec type from the given <see cref="CodedInputStream"/>.
      -- </summary>
      -- <returns>The value read from the stream.</returns>
      Read = function (this, input)
        return this.ValueReader(input, T)
      end
      -- <summary>
      -- Calculates the size required to write the given value, with a tag,
      -- if the value is not the default.
      -- </summary>
      CalculateSizeWithTag = function (this, value)
        return IsDefault(this, value) and 0 or (this.ValueSizeCalculator(value, T) + this.tagSize)
      end
      IsDefault = function (this, value)
        return EqualityComparerT.getDefault():EqualsOf(value, this.DefaultValue)
      end
      return {
        IsPackedRepeatedField = IsPackedRepeatedField,
        PackedRepeatedField = false,
        FixedSize = 0,
        Tag = 0,
        tagSize = 0,
        WriteTagAndValue = WriteTagAndValue,
        Read = Read,
        CalculateSizeWithTag = CalculateSizeWithTag,
        static = static,
        __ctor__ = {
          __ctor1__,
          __ctor2__,
          __ctor3__
        }
      }
    end
  end)
end)
