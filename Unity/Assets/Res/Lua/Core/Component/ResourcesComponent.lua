-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local DCETModel = DCET.Model
local SystemIO = System.IO
local UnityEngine = UnityEngine
local ListString = System.List(System.String)
local ArrayString = System.Array(System.String)
local DictStringInt32 = System.Dictionary(System.String, System.Int32)
local DictStringObject = System.Dictionary(System.String, UnityEngine.Object)
local DictStringArrayString = System.Dictionary(System.String, ArrayString)
local DictStringDictStringObject = System.Dictionary(System.String, DictStringObject)
local DCETHotfix
local DictStringABInfo
System.import(function (out)
  DCETHotfix = DCET.Hotfix
  DictStringABInfo = System.Dictionary(System.String, DCETHotfix.ABInfo)
end)
System.namespace("DCET.Hotfix", function (namespace)
  namespace.class("ABInfoAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, abName, a)
      self.AssetBundle = a
      self.Name = abName
      self.RefCount = 1
    end
    return {
      base = function (out)
        return {
          out.DCET.Hotfix.AwakeSystem_3(out.DCET.Hotfix.ABInfo, System.String, out.UnityEngine.AssetBundle)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.DCET.Hotfix.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("ABInfo", function (namespace)
    local Dispose, __ctor__
    __ctor__ = function (this)
      DCETHotfix.Entity.__ctor__(this)
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      DCETHotfix.Entity.Dispose(this)

      --Log.Debug($"desdroy assetbundle: {this.Name}");

      if UnityEngine.op_Inequality(this.AssetBundle, nil) then
        this.AssetBundle:Unload(true)
      end

      this.RefCount = 0
      this.Name = ""
    end
    return {
      base = function (out)
        return {
          out.DCET.Hotfix.Entity
        }
      end,
      RefCount = 0,
      Dispose = Dispose,
      __ctor__ = __ctor__
    }
  end)

  namespace.class("DependenciesHelper", function (namespace)
    local GetDependencies, GetSortedDependencies, CollectDependencies, class, static
    static = function (this)
      this.DependenciesCache = DictStringArrayString()
    end
    GetDependencies = function (assetBundleName)
      local dependencies = ArrayString:new(0)
      local default
      default, dependencies = class.DependenciesCache:TryGetValue(assetBundleName)
      if default then
        return dependencies
      end
      if DCETModel.Define.IsAsync or DCETModel.Define.IsLua then
        dependencies = DCETHotfix.ResourcesComponent.AssetBundleManifestObject:GetAllDependencies(assetBundleName)
      else
      end
      class.DependenciesCache:AddKeyValue(assetBundleName, dependencies)
      return dependencies
    end
    GetSortedDependencies = function (assetBundleName)
      local info = DictStringInt32()
      local parents = ListString()
      CollectDependencies(parents, assetBundleName, info)
      local orderResult = Linq.OrderBy(info, function (x)
        return x.Value
      end, nil, System.Int32)
      local selectResult = Linq.Select(orderResult, function (x)
        return x.Key
      end, System.String)
      return Linq.ToArray(selectResult)
    end
    CollectDependencies = function (parents, assetBundleName, info)
      parents:Add(assetBundleName)
      local deps = GetDependencies(assetBundleName)
      for _, parent in System.each(parents) do
        if not info:ContainsKey(parent) then
          info:set(parent, 0)
        end
        info:set(parent, info:get(parent) + #deps)
      end


      for _, dep in System.each(deps) do
        if parents:Contains(dep) then
          System.throw(System.Exception("包有循环依赖，请重新标记: " .. assetBundleName .. " " .. dep))
        end
        CollectDependencies(parents, dep, info)
      end
      parents:RemoveAt(#parents - 1)
    end
    class = {
      GetDependencies = GetDependencies,
      GetSortedDependencies = GetSortedDependencies,
      CollectDependencies = CollectDependencies,
      static = static
    }
    return class
  end)


  namespace.class("ResourcesComponent", function (namespace)
    local Dispose, GetAsset, GetAssetBundle, UnloadBundle, UnloadOneBundle, LoadBundle, AddResource, LoadOneBundle, 
    LoadBundleAsync, LoadOneBundleAsync, DebugString, __ctor__
    __ctor__ = function (this)
      this.resourceCache = DictStringDictStringObject()
      this.bundles = DictStringABInfo()
      DCETHotfix.Entity.__ctor__(this)
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      DCETHotfix.Entity.Dispose(this)

      for _, abInfo in System.each(this.bundles) do
        abInfo.Value:Dispose()
      end

      this.bundles:Clear()
      this.resourceCache:Clear()
    end
    GetAsset = function (this, bundleName, prefab)
      local dict
      local default
      default, dict = this.resourceCache:TryGetValue(DCETModel.AssetBundleHelper.BundleNameToLower(bundleName))
      if not default then
        System.throw(System.Exception("not found asset: " .. bundleName .. " " .. prefab))
      end

      local resource = nil
      local extern
      extern, resource = dict:TryGetValue(prefab)
      if not extern then
        System.throw(System.Exception("not found asset: " .. bundleName .. " " .. prefab))
      end

      return resource
    end
    GetAssetBundle = function (this, abName)
      local abInfo
      local default
      default, abInfo = this.bundles:TryGetValue(DCETModel.AssetBundleHelper.BundleNameToLower(abName))
      if not default then
        System.throw(System.Exception("not found bundle: " .. abName))
      end
      return abInfo.AssetBundle
    end
    UnloadBundle = function (this, assetBundleName)
      assetBundleName = DCETModel.AssetBundleHelper.BundleNameToLower(assetBundleName)

      local dependencies = DCETHotfix.DependenciesHelper.GetSortedDependencies(assetBundleName)

      --Log.Debug($"-----------dep unload {assetBundleName} dep: {dependencies.ToList().ListToString()}");
      for _, dependency in System.each(dependencies) do
        UnloadOneBundle(this, dependency)
      end
    end
    UnloadOneBundle = function (this, assetBundleName)
      assetBundleName = DCETModel.AssetBundleHelper.BundleNameToLower(assetBundleName)

      local abInfo
      local default
      default, abInfo = this.bundles:TryGetValue(assetBundleName)
      if not default then
        System.throw(System.Exception("not found assetBundle: " .. assetBundleName))
      end

      --Log.Debug($"---------- unload one bundle {assetBundleName} refcount: {abInfo.RefCount - 1}");

      local extern = abInfo
      extern.RefCount = extern.RefCount - 1

      if abInfo.RefCount > 0 then
        return
      end


      this.bundles:RemoveKey(assetBundleName)
      this.resourceCache:RemoveKey(assetBundleName)
      abInfo:Dispose()
      --Log.Debug($"cache count: {this.cacheDictionary.Count}");
    end
    -- <summary>
    -- 同步加载assetbundle
    -- </summary>
    -- <returns></returns>
    LoadBundle = function (this, assetBundleName)
      assetBundleName = assetBundleName:ToLower()
      local dependencies = DCETHotfix.DependenciesHelper.GetSortedDependencies(assetBundleName)
      --Log.Debug($"-----------dep load {assetBundleName} dep: {dependencies.ToList().ListToString()}");
      for _, dependency in System.each(dependencies) do
        local continue
        repeat
          if System.String.IsNullOrEmpty(dependency) then
            continue = true
            break
          end
          LoadOneBundle(this, dependency)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    AddResource = function (this, bundleName, assetName, resource)
      local dict
      local default
      default, dict = this.resourceCache:TryGetValue(DCETModel.AssetBundleHelper.BundleNameToLower(bundleName))
      if not default then
        dict = DictStringObject()
        this.resourceCache:set(bundleName, dict)
      end

      dict:set(assetName, resource)
    end
    LoadOneBundle = function (this, assetBundleName)
      --Log.Debug($"---------------load one bundle {assetBundleName}");
      local abInfo
      local default
      default, abInfo = this.bundles:TryGetValue(assetBundleName)
      if default then
        local extern = abInfo
        extern.RefCount = extern.RefCount + 1
        return
      end

      if not DCETModel.Define.IsAsync and not DCETModel.Define.IsLua then
        local realPath = nil
        return
      end

      local p = SystemIO.Path.Combine(DCETModel.PathHelper.getAppHotfixResPath(), assetBundleName)
      local assetBundle = nil
      if SystemIO.File.Exists(p) then
        assetBundle = UnityEngine.AssetBundle.LoadFromFile(p)
      else
        p = SystemIO.Path.Combine(DCETModel.PathHelper.getAppResPath(), assetBundleName)
        assetBundle = UnityEngine.AssetBundle.LoadFromFile(p)
      end

      if UnityEngine.op_Equality(assetBundle, nil) then
        System.throw(System.Exception("assets bundle not found: " .. assetBundleName))
      end

      if not assetBundle:getisStreamedSceneAssetBundle() then
        -- 异步load资源到内存cache住
        local assets = assetBundle:LoadAllAssets()
        for _, asset in System.each(assets) do
          AddResource(this, assetBundleName, asset:getname(), asset)
        end
      end

      abInfo = DCETHotfix.EntityFactory.CreateWithParent3(this, assetBundleName, assetBundle, DCETHotfix.ABInfo, System.String, UnityEngine.AssetBundle)
      this.bundles:set(assetBundleName, abInfo)
    end
    -- <summary>
    -- 异步加载assetbundle
    -- </summary>
    -- <returns></returns>
    LoadBundleAsync = function (this, assetBundleName)
      return System.async(function (async, this, assetBundleName)
        assetBundleName = assetBundleName:ToLower()
        local dependencies = DCETHotfix.DependenciesHelper.GetSortedDependencies(assetBundleName)
        -- Log.Debug($"-----------dep load {assetBundleName} dep: {dependencies.ToList().ListToString()}");
        for _, dependency in System.each(dependencies) do
          local continue
          repeat
            if System.String.IsNullOrEmpty(dependency) then
              continue = true
              break
            end
            async:await(LoadOneBundleAsync(this, dependency))
            continue = true
          until 1
          if not continue then
            break
          end
        end
      end, nil, this, assetBundleName)
    end
    LoadOneBundleAsync = function (this, assetBundleName)
      return System.async(function (async, this, assetBundleName)
        local abInfo
        local default
        default, abInfo = this.bundles:TryGetValue(assetBundleName)
        if default then
          local extern = abInfo
          extern.RefCount = extern.RefCount + 1
          return
        end

        --Log.Debug($"---------------load one bundle {assetBundleName}");
        if not DCETModel.Define.IsAsync then
          local realPath = nil
          return
        end

        local p = SystemIO.Path.Combine(DCETModel.PathHelper.getAppHotfixResPath(), assetBundleName)
        local assetBundle = nil
        if not SystemIO.File.Exists(p) then
          p = SystemIO.Path.Combine(DCETModel.PathHelper.getAppResPath(), assetBundleName)
        end

        System.using(DCETHotfix.EntityFactory.Create1(this:getDomain(), DCETHotfix.AssetsBundleLoaderAsync), function (assetsBundleLoaderAsync)
          assetBundle = async:await(assetsBundleLoaderAsync:LoadAsync(p))
        end)

        if UnityEngine.op_Equality(assetBundle, nil) then
          System.throw(System.Exception("assets bundle not found: " .. assetBundleName))
        end

        if not assetBundle:getisStreamedSceneAssetBundle() then
          -- 异步load资源到内存cache住
          local assets
          System.using(DCETHotfix.EntityFactory.Create2(this:getDomain(), assetBundle, DCETHotfix.AssetsLoaderAsync, UnityEngine.AssetBundle), function (assetsLoaderAsync)
            assets = async:await(assetsLoaderAsync:LoadAllAssetsAsync())
          end)
          for _, asset in System.each(assets) do
            AddResource(this, assetBundleName, asset:getname(), asset)
          end
        end

        abInfo = DCETHotfix.EntityFactory.CreateWithParent3(this, assetBundleName, assetBundle, DCETHotfix.ABInfo, System.String, UnityEngine.AssetBundle)
        this.bundles:set(assetBundleName, abInfo)
      end, nil, this, assetBundleName)
    end
    DebugString = function (this)
      local sb = System.StringBuilder()
      for _, abInfo in System.each(this.bundles:getValues()) do
        sb:Append(abInfo.Name .. ":" .. abInfo.RefCount .. "\n")
      end
      return sb:ToString()
    end
    return {
      base = function (out)
        return {
          out.DCET.Hotfix.Entity
        }
      end,
      Dispose = Dispose,
      GetAsset = GetAsset,
      GetAssetBundle = GetAssetBundle,
      UnloadBundle = UnloadBundle,
      LoadBundle = LoadBundle,
      AddResource = AddResource,
      LoadOneBundle = LoadOneBundle,
      LoadBundleAsync = LoadBundleAsync,
      LoadOneBundleAsync = LoadOneBundleAsync,
      DebugString = DebugString,
      __ctor__ = __ctor__
    }
  end)
end)
