-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local SystemLinqExpressions = System.Linq.Expressions
local SystemReflection = System.Reflection
local ListType = System.List(System.Type)
local ArrayType = System.Array(System.Type)
local QueueType = System.Queue(System.Type)
local IDictionary_2StringObject = System.IDictionary_2(System.String, System.Object)
local MongoDBBson
local MongoDBBsonIO
local MongoDBBsonSerialization
local MongoDBConventions
local BsonTrie_1Int32
local ListBsonMemberMap
local ListBsonCreatorMap
local DictTypeBsonClassMap
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
  MongoDBBsonSerialization = MongoDB.Bson.Serialization
  MongoDBConventions = MongoDB.Bson.Serialization.Conventions
  BsonTrie_1Int32 = MongoDBBsonIO.BsonTrie_1(System.Int32)
  ListBsonMemberMap = System.List(MongoDBBsonSerialization.BsonMemberMap)
  ListBsonCreatorMap = System.List(MongoDBBsonSerialization.BsonCreatorMap)
  DictTypeBsonClassMap = System.Dictionary(System.Type, MongoDBBsonSerialization.BsonClassMap)
end)
System.namespace("MongoDB.Bson.Serialization", function (namespace)
  -- <summary>
  -- Represents a mapping between a class and a BSON document.
  -- </summary>
  namespace.class("BsonClassMap", function (namespace)
    local __classMaps, __knownTypesQueue, __getUninitializedObjectMethodInfo, __freezeNestingLevel, getAllMemberMaps, getBaseClassMap, getClassType, getCreatorMaps, 
    getConventionPack, getDeclaredMemberMaps, getDiscriminator, getDiscriminatorIsRequired, getExtraElementsMemberMap, getHasCreatorMaps, getHasRootClass, getIdMemberMap, 
    getIgnoreExtraElements, getIgnoreExtraElementsIsInherited, getIsAnonymous, getIsFrozen, getIsRootClass, getKnownTypes, getElementTrie, getExtraElementsMemberMapIndex, 
    GetMemberInfoType, GetRegisteredClassMaps, IsClassMapRegistered, LookupClassMap, RegisterClassMap, RegisterClassMap1, RegisterClassMap2, AutoMap, 
    CreateInstance, Freeze, GetMemberMap, GetMemberMapForElement, MapConstructor, MapConstructor1, MapCreator, MapCreator1, 
    MapExtraElementsField, MapExtraElementsMember, MapExtraElementsProperty, MapFactoryMethod, MapFactoryMethod1, MapField, MapIdField, MapIdMember, 
    MapIdProperty, MapMember, MapProperty, Reset, SetCreator, SetDiscriminator, SetDiscriminatorIsRequired, SetExtraElementsMember, 
    AddKnownType, SetIdMember, SetIgnoreExtraElements, SetIgnoreExtraElementsIsInherited, SetIsRootClass, UnmapConstructor, UnmapFactoryMethod, UnmapField, 
    UnmapMember, UnmapProperty, GetDiscriminatorConvention, AutoMapClass, TryFindShouldSerializeMethod, EnsureMemberInfoIsForThisClass, EnsureMemberMapIsForThisClass, GetCreator, 
    GetShouldSerializeMethod, IsAnonymousType, ThrowFrozenException, ThrowNotFrozenException, class, static, internal, __ctor1__, 
    __ctor2__
    static = function (this)
      __classMaps = DictTypeBsonClassMap()
      __knownTypesQueue = QueueType()
      local default = SystemReflection.IntrospectionExtensions.GetTypeInfo(SystemReflection.IntrospectionExtensions.GetTypeInfo(System.typeof(System.String)):getAssembly():GetTypeFrom("System.Runtime.Serialization.FormatterServices"))
      if default ~= nil then
        default = default:GetMethod("GetUninitializedObject", 56 --[[BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static]])
      end
      __getUninitializedObjectMethodInfo = default
    end
    internal = function (this)
      this._knownTypes = ListType()
    end
    -- <summary>
    -- Initializes a new instance of the BsonClassMap class.
    -- </summary>
    __ctor1__ = function (this, classType)
      internal(this)
      this._classType = classType
      this._creatorMaps = ListBsonCreatorMap()
      this._conventionPack = MongoDBConventions.ConventionRegistry.Lookup(classType)
      this._isAnonymous = IsAnonymousType(this, classType)
      this._allMemberMaps = ListBsonMemberMap()
      this._allMemberMapsReadonly = this._allMemberMaps:AsReadOnly()
      this._declaredMemberMaps = ListBsonMemberMap()
      this._elementTrie = BsonTrie_1Int32()

      Reset(this)
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="BsonClassMap"/> class.
    -- </summary>
    -- <param name="baseClassMap">The base class map.</param>
    __ctor2__ = function (this, classType, baseClassMap)
      __ctor1__(this, classType)
      this._baseClassMap = baseClassMap
    end
    __freezeNestingLevel = 0
    getAllMemberMaps = function (this)
      return this._allMemberMapsReadonly
    end
    getBaseClassMap = function (this)
      return this._baseClassMap
    end
    getClassType = function (this)
      return this._classType
    end
    getCreatorMaps = function (this)
      return this._creatorMaps
    end
    getConventionPack = function (this)
      return this._conventionPack
    end
    getDeclaredMemberMaps = function (this)
      return this._declaredMemberMaps
    end
    getDiscriminator = function (this)
      return this._discriminator
    end
    getDiscriminatorIsRequired = function (this)
      return this._discriminatorIsRequired
    end
    getExtraElementsMemberMap = function (this)
      return this._extraElementsMemberMap
    end
    getHasCreatorMaps = function (this)
      return #this._creatorMaps > 0
    end
    getHasRootClass = function (this)
      return this._hasRootClass
    end
    getIdMemberMap = function (this)
      return this._idMemberMap
    end
    getIgnoreExtraElements = function (this)
      return this._ignoreExtraElements
    end
    getIgnoreExtraElementsIsInherited = function (this)
      return this._ignoreExtraElementsIsInherited
    end
    getIsAnonymous = function (this)
      return this._isAnonymous
    end
    getIsFrozen = function (this)
      return this._frozen
    end
    getIsRootClass = function (this)
      return this._isRootClass
    end
    getKnownTypes = function (this)
      return this._knownTypes
    end
    getElementTrie = function (this)
      return this._elementTrie
    end
    getExtraElementsMemberMapIndex = function (this)
      return this._extraElementsMemberIndex
    end
    -- <summary>
    -- Gets the type of a member.
    -- </summary>
    -- <returns>The type of the member.</returns>
    GetMemberInfoType = function (memberInfo)
      if memberInfo == nil then
        System.throw(System.ArgumentNullException("memberInfo"))
      end

      if System.is(memberInfo, SystemReflection.FieldInfo) then
        return (System.cast(SystemReflection.FieldInfo, memberInfo)):getFieldType()
      elseif System.is(memberInfo, SystemReflection.PropertyInfo) then
        return (System.cast(SystemReflection.PropertyInfo, memberInfo)):getPropertyType()
      end

      System.throw(System.NotSupportedException("Only field and properties are supported at this time."))
    end
    -- <summary>
    -- Gets all registered class maps.
    -- </summary>
    GetRegisteredClassMaps = function ()
      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterReadLock()
      local default, extern = System.try(function ()
        return true, Linq.ToList(__classMaps:getValues())
        -- return a copy for thread safety
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitReadLock()
      end)
      if default then
        return extern
      end
    end
    -- <summary>
    -- Checks whether a class map is registered for a type.
    -- </summary>
    -- <returns>True if there is a class map registered for the type.</returns>
    IsClassMapRegistered = function (type)
      if type == nil then
        System.throw(System.ArgumentNullException("type"))
      end

      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterReadLock()
      local default, extern = System.try(function ()
        return true, __classMaps:ContainsKey(type)
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitReadLock()
      end)
      if default then
        return extern
      end
    end
    -- <summary>
    -- Looks up a class map (will AutoMap the class if no class map is registered).
    -- </summary>
    -- <returns>The class map.</returns>
    LookupClassMap = function (classType)
      if classType == nil then
        System.throw(System.ArgumentNullException("classType"))
      end

      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterReadLock()
      local default, extern = System.try(function ()
        local classMap
        local default
        default, classMap = __classMaps:TryGetValue(classType)
        if default then
          if getIsFrozen(classMap) then
            return true, classMap
          end
        end
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitReadLock()
      end)
      if default then
        return extern
      end

      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterWriteLock()
      local ref, out = System.try(function ()
        local classMap
        local default
        default, classMap = __classMaps:TryGetValue(classType)
        if not default then
          -- automatically create a classMap for classType and register it
          local classMapDefinition = System.typeof(MongoDBBsonSerialization.BsonClassMap_1)
          local classMapType = classMapDefinition:MakeGenericType(classType)
          classMap = System.cast(class, System.Activator.CreateInstance(classMapType))
          AutoMap(classMap)
          RegisterClassMap2(classMap)
        end
        return true, Freeze(classMap)
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitWriteLock()
      end)
      if ref then
        return out
      end
    end
    -- <summary>
    -- Creates and registers a class map.
    -- </summary>
    -- <returns>The class map.</returns>
    RegisterClassMap = function (TClass)
      return RegisterClassMap1(function (cm)
        AutoMap(cm)
      end, TClass)
    end
    -- <summary>
    -- Creates and registers a class map.
    -- </summary>
    -- <param name="classMapInitializer">The class map initializer.</param>
    -- <returns>The class map.</returns>
    RegisterClassMap1 = function (classMapInitializer, TClass)
      local classMap = System.new(MongoDBBsonSerialization.BsonClassMap_1(TClass), 2, classMapInitializer)
      RegisterClassMap2(classMap)
      return classMap
    end
    -- <summary>
    -- Registers a class map.
    -- </summary>
    RegisterClassMap2 = function (classMap)
      if classMap == nil then
        System.throw(System.ArgumentNullException("classMap"))
      end

      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterWriteLock()
      System.try(function ()
        -- note: class maps can NOT be replaced (because derived classes refer to existing instance)
        __classMaps:AddKeyValue(getClassType(classMap), classMap)
        MongoDBBsonSerialization.BsonSerializer.RegisterDiscriminator(getClassType(classMap), MongoDBBson.BsonValue.op_Implicit21(getDiscriminator(classMap)))
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitWriteLock()
      end)
    end
    -- <summary>
    -- Automaps the class.
    -- </summary>
    AutoMap = function (this)
      if this._frozen then
        ThrowFrozenException(this)
      end
      AutoMapClass(this)
    end
    -- <summary>
    -- Creates an instance of the class.
    -- </summary>
    CreateInstance = function (this)
      if not this._frozen then
        ThrowNotFrozenException(this)
      end
      local creator = GetCreator(this)
      return creator()
    end
    -- <summary>
    -- Freezes the class map.
    -- </summary>
    Freeze = function (this)
      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterReadLock()
      local default, extern = System.try(function ()
        if this._frozen then
          return true, this
        end
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitReadLock()
      end)
      if default then
        return extern
      end

      MongoDBBsonSerialization.BsonSerializer.getConfigLock():EnterWriteLock()
      System.try(function ()
        if not this._frozen then
          __freezeNestingLevel = __freezeNestingLevel + 1
          System.try(function ()
            local baseType = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):getBaseType()
            if baseType ~= nil then
              if this._baseClassMap == nil then
                this._baseClassMap = LookupClassMap(baseType)
              end
              Freeze(this._baseClassMap)
              this._discriminatorIsRequired = this._discriminatorIsRequired or this._baseClassMap._discriminatorIsRequired
              this._hasRootClass = this._hasRootClass or (this._isRootClass or getHasRootClass(this._baseClassMap))
              this._allMemberMaps:AddRange(getAllMemberMaps(this._baseClassMap))
              if getIgnoreExtraElements(this._baseClassMap) and getIgnoreExtraElementsIsInherited(this._baseClassMap) then
                this._ignoreExtraElements = true
                this._ignoreExtraElementsIsInherited = true
              end
            end
            this._declaredMemberMaps = Linq.ToList(Linq.OrderBy(this._declaredMemberMaps, function (m)
              return m:getOrder()
            end, nil, System.Int32))
            -- we're counting on OrderBy being a stable sort
            this._allMemberMaps:AddRange(this._declaredMemberMaps)

            if this._idMemberMap == nil then
              -- see if we can inherit the idMemberMap from our base class
              if this._baseClassMap ~= nil then
                this._idMemberMap = getIdMemberMap(this._baseClassMap)
              end
            else
              if this._idMemberMap:getClassMap() == this then
                -- conventions could have set this to an improper value
                this._idMemberMap:SetElementName("_id")
              end
            end

            if this._extraElementsMemberMap == nil then
              -- see if we can inherit the extraElementsMemberMap from our base class
              if this._baseClassMap ~= nil then
                this._extraElementsMemberMap = getExtraElementsMemberMap(this._baseClassMap)
              end
            end

            this._extraElementsMemberIndex = - 1
            for memberIndex = 0, #this._allMemberMaps - 1 do
              local memberMap = this._allMemberMaps:get(memberIndex)
              local conflictingMemberIndex
              local default
              default, conflictingMemberIndex = this._elementTrie:TryGetValue1(memberMap:getElementName())
              if not default then
                this._elementTrie:Add(memberMap:getElementName(), memberIndex)
              else
                local conflictingMemberMap = this._allMemberMaps:get(conflictingMemberIndex)
                local fieldOrProperty = (System.is(memberMap:getMemberInfo(), SystemReflection.FieldInfo)) and "field" or "property"
                local conflictingFieldOrProperty = (System.is(conflictingMemberMap:getMemberInfo(), SystemReflection.FieldInfo)) and "field" or "property"
                local conflictingType = conflictingMemberMap:getMemberInfo():getDeclaringType()

                local message
                if conflictingType == this._classType then
                  message = System.String.Format("The {0} '{1}' of type '{2}' cannot use element name '{3}' because it is already being used by {4} '{5}'.", fieldOrProperty, memberMap:getMemberName(), this._classType:getFullName(), memberMap:getElementName(), conflictingFieldOrProperty, conflictingMemberMap:getMemberName())
                else
                  message = System.String.Format("The {0} '{1}' of type '{2}' cannot use element name '{3}' because it is already being used by {4} '{5}' of type '{6}'.", fieldOrProperty, memberMap:getMemberName(), this._classType:getFullName(), memberMap:getElementName(), conflictingFieldOrProperty, conflictingMemberMap:getMemberName(), conflictingType:getFullName())
                end
                System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
              end
              if memberMap == this._extraElementsMemberMap then
                this._extraElementsMemberIndex = memberIndex
              end
            end

            -- mark this classMap frozen before we start working on knownTypes
            -- because we might get back to this same classMap while processing knownTypes
            for _, creatorMap in System.each(this._creatorMaps) do
              creatorMap:Freeze()
            end
            for _, memberMap in System.each(this._declaredMemberMaps) do
              memberMap:Freeze()
            end
            this._frozen = true

            -- use a queue to postpone processing of known types until we get back to the first level call to Freeze
            -- this avoids infinite recursion when going back down the inheritance tree while processing known types
            for _, knownType in System.each(this._knownTypes) do
              __knownTypesQueue:Enqueue(knownType)
            end

            -- if we are back to the first level go ahead and process any queued known types
            if __freezeNestingLevel == 1 then
              while #__knownTypesQueue ~= 0 do
                local knownType = __knownTypesQueue:Dequeue()
                LookupClassMap(knownType)
                -- will AutoMap and/or Freeze knownType if necessary
              end
            end
          end, nil, function ()
            __freezeNestingLevel = __freezeNestingLevel - 1
          end)
        end
      end, nil, function ()
        MongoDBBsonSerialization.BsonSerializer.getConfigLock():ExitWriteLock()
      end)
      return this
    end
    -- <summary>
    -- Gets a member map (only considers members declared in this class).
    -- </summary>
    -- <returns>The member map (or null if the member was not found).</returns>
    GetMemberMap = function (this, memberName)
      if memberName == nil then
        System.throw(System.ArgumentNullException("memberName"))
      end

      -- can be called whether frozen or not
      return this._declaredMemberMaps:Find(function (m)
        return m:getMemberName() == memberName
      end)
    end
    -- <summary>
    -- Gets the member map for a BSON element.
    -- </summary>
    -- <returns>The member map.</returns>
    GetMemberMapForElement = function (this, elementName)
      if elementName == nil then
        System.throw(System.ArgumentNullException("elementName"))
      end

      if not this._frozen then
        ThrowNotFrozenException(this)
      end
      local memberIndex
      local default
      default, memberIndex = this._elementTrie:TryGetValue1(elementName)
      if not default then
        return nil
      end
      local memberMap = this._allMemberMaps:get(memberIndex)
      return memberMap
    end
    -- <summary>
    -- Creates a creator map for a constructor and adds it to the class map.
    -- </summary>
    -- <returns>The creator map (so method calls can be chained).</returns>
    MapConstructor = function (this, constructorInfo)
      if SystemReflection.ConstructorInfo.op_Equality(constructorInfo, nil) then
        System.throw(System.ArgumentNullException("constructorInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, constructorInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local creatorMap = Linq.FirstOrDefault(this._creatorMaps, function (m)
        return m:getMemberInfo() == constructorInfo
      end)
      if creatorMap == nil then
        local delegate = MongoDBBsonSerialization.CreatorMapDelegateCompiler():CompileConstructorDelegate(constructorInfo)
        creatorMap = MongoDBBsonSerialization.BsonCreatorMap(this, constructorInfo, delegate)
        this._creatorMaps:Add(creatorMap)
      end
      return creatorMap
    end
    -- <summary>
    -- Creates a creator map for a constructor and adds it to the class map.
    -- </summary>
    -- <param name="argumentNames">The argument names.</param>
    -- <returns>The creator map (so method calls can be chained).</returns>
    MapConstructor1 = function (this, constructorInfo, argumentNames)
      local creatorMap = MapConstructor(this, constructorInfo)
      creatorMap:SetArguments1(argumentNames)
      return creatorMap
    end
    -- <summary>
    -- Creates a creator map and adds it to the class.
    -- </summary>
    -- <returns>The factory method map (so method calls can be chained).</returns>
    MapCreator = function (this, delegate)
      if delegate == nil then
        System.throw(System.ArgumentNullException("delegate"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local creatorMap = MongoDBBsonSerialization.BsonCreatorMap(this, nil, delegate)
      this._creatorMaps:Add(creatorMap)
      return creatorMap
    end
    -- <summary>
    -- Creates a creator map and adds it to the class.
    -- </summary>
    -- <param name="argumentNames">The argument names.</param>
    -- <returns>The factory method map (so method calls can be chained).</returns>
    MapCreator1 = function (this, delegate, argumentNames)
      local creatorMap = MapCreator(this, delegate)
      creatorMap:SetArguments1(argumentNames)
      return creatorMap
    end
    -- <summary>
    -- Creates a member map for the extra elements field and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapExtraElementsField = function (this, fieldName)
      if fieldName == nil then
        System.throw(System.ArgumentNullException("fieldName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local fieldMap = MapField(this, fieldName)
      SetExtraElementsMember(this, fieldMap)
      return fieldMap
    end
    -- <summary>
    -- Creates a member map for the extra elements member and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapExtraElementsMember = function (this, memberInfo)
      if memberInfo == nil then
        System.throw(System.ArgumentNullException("memberInfo"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local memberMap = MapMember(this, memberInfo)
      SetExtraElementsMember(this, memberMap)
      return memberMap
    end
    -- <summary>
    -- Creates a member map for the extra elements property and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapExtraElementsProperty = function (this, propertyName)
      if propertyName == nil then
        System.throw(System.ArgumentNullException("propertyName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local propertyMap = MapProperty(this, propertyName)
      SetExtraElementsMember(this, propertyMap)
      return propertyMap
    end
    -- <summary>
    -- Creates a creator map for a factory method and adds it to the class.
    -- </summary>
    -- <returns>The creator map (so method calls can be chained).</returns>
    MapFactoryMethod = function (this, methodInfo)
      if methodInfo == nil then
        System.throw(System.ArgumentNullException("methodInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, methodInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local creatorMap = Linq.FirstOrDefault(this._creatorMaps, function (m)
        return m:getMemberInfo() == methodInfo
      end)
      if creatorMap == nil then
        local delegate = MongoDBBsonSerialization.CreatorMapDelegateCompiler():CompileFactoryMethodDelegate(methodInfo)
        creatorMap = MongoDBBsonSerialization.BsonCreatorMap(this, methodInfo, delegate)
        this._creatorMaps:Add(creatorMap)
      end
      return creatorMap
    end
    -- <summary>
    -- Creates a creator map for a factory method and adds it to the class.
    -- </summary>
    -- <param name="argumentNames">The argument names.</param>
    -- <returns>The creator map (so method calls can be chained).</returns>
    MapFactoryMethod1 = function (this, methodInfo, argumentNames)
      local creatorMap = MapFactoryMethod(this, methodInfo)
      creatorMap:SetArguments1(argumentNames)
      return creatorMap
    end
    -- <summary>
    -- Creates a member map for a field and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapField = function (this, fieldName)
      if fieldName == nil then
        System.throw(System.ArgumentNullException("fieldName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local fieldInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):GetField(fieldName, 54 --[[BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly]])
      if fieldInfo == nil then
        local message = System.String.Format("The class '{0}' does not have a field named '{1}'.", this._classType:getFullName(), fieldName)
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
      end
      return MapMember(this, fieldInfo)
    end
    -- <summary>
    -- Creates a member map for the Id field and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapIdField = function (this, fieldName)
      if fieldName == nil then
        System.throw(System.ArgumentNullException("fieldName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local fieldMap = MapField(this, fieldName)
      SetIdMember(this, fieldMap)
      return fieldMap
    end
    -- <summary>
    -- Creates a member map for the Id member and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapIdMember = function (this, memberInfo)
      if memberInfo == nil then
        System.throw(System.ArgumentNullException("memberInfo"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local memberMap = MapMember(this, memberInfo)
      SetIdMember(this, memberMap)
      return memberMap
    end
    -- <summary>
    -- Creates a member map for the Id property and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapIdProperty = function (this, propertyName)
      if propertyName == nil then
        System.throw(System.ArgumentNullException("propertyName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local propertyMap = MapProperty(this, propertyName)
      SetIdMember(this, propertyMap)
      return propertyMap
    end
    -- <summary>
    -- Creates a member map for a member and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapMember = function (this, memberInfo)
      if memberInfo == nil then
        System.throw(System.ArgumentNullException("memberInfo"))
      end
      if not (System.is(memberInfo, SystemReflection.FieldInfo)) and not (System.is(memberInfo, SystemReflection.PropertyInfo)) then
        System.throw(System.ArgumentException("MemberInfo must be either a FieldInfo or a PropertyInfo.", "memberInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, memberInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local memberMap = this._declaredMemberMaps:Find(function (m)
        return m:getMemberInfo() == memberInfo
      end)
      if memberMap == nil then
        memberMap = MongoDBBsonSerialization.BsonMemberMap(this, memberInfo)
        this._declaredMemberMaps:Add(memberMap)
      end
      return memberMap
    end
    -- <summary>
    -- Creates a member map for a property and adds it to the class map.
    -- </summary>
    -- <returns>The member map (so method calls can be chained).</returns>
    MapProperty = function (this, propertyName)
      if propertyName == nil then
        System.throw(System.ArgumentNullException("propertyName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local propertyInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):GetProperty(propertyName, 54 --[[BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly]])
      if propertyInfo == nil then
        local message = System.String.Format("The class '{0}' does not have a property named '{1}'.", this._classType:getFullName(), propertyName)
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
      end
      return MapMember(this, propertyInfo)
    end
    -- <summary>
    -- Resets the class map back to its initial state.
    -- </summary>
    Reset = function (this)
      if this._frozen then
        ThrowFrozenException(this)
      end

      this._creatorMaps:Clear()
      this._creator = nil
      this._declaredMemberMaps = ListBsonMemberMap()
      this._discriminator = this._classType:getName()
      this._discriminatorIsRequired = false
      this._extraElementsMemberMap = nil
      this._idMemberMap = nil
      this._ignoreExtraElements = true
      -- TODO: should this really be false?
      this._ignoreExtraElementsIsInherited = false
      this._isRootClass = false
      this._knownTypes:Clear()
    end
    -- <summary>
    -- Sets the creator for the object.
    -- </summary>
    -- <returns>The class map (so method calls can be chained).</returns>
    SetCreator = function (this, creator)
      this._creator = creator
      return this
    end
    -- <summary>
    -- Sets the discriminator.
    -- </summary>
    SetDiscriminator = function (this, discriminator)
      if discriminator == nil then
        System.throw(System.ArgumentNullException("discriminator"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      this._discriminator = discriminator
    end
    -- <summary>
    -- Sets whether a discriminator is required when serializing this class.
    -- </summary>
    SetDiscriminatorIsRequired = function (this, discriminatorIsRequired)
      if this._frozen then
        ThrowFrozenException(this)
      end
      this._discriminatorIsRequired = discriminatorIsRequired
    end
    -- <summary>
    -- Sets the member map of the member used to hold extra elements.
    -- </summary>
    SetExtraElementsMember = function (this, memberMap)
      if memberMap == nil then
        System.throw(System.ArgumentNullException("memberMap"))
      end
      EnsureMemberMapIsForThisClass(this, memberMap)

      if this._frozen then
        ThrowFrozenException(this)
      end
      if memberMap:getMemberType() ~= System.typeof(MongoDBBson.BsonDocument) and not SystemReflection.IntrospectionExtensions.GetTypeInfo(System.typeof(IDictionary_2StringObject)):IsAssignableFrom(memberMap:getMemberType()) then
        local message = System.String.Format("Type of ExtraElements member must be BsonDocument or implement IDictionary<string, object>.", System.Array(System.Object)())
        System.throw(System.InvalidOperationException(message))
      end

      this._extraElementsMemberMap = memberMap
    end
    -- <summary>
    -- Adds a known type to the class map.
    -- </summary>
    AddKnownType = function (this, type)
      if not SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):IsAssignableFrom(type) then
        local message = System.String.Format("Class {0} cannot be assigned to Class {1}.  Ensure that known types are derived from the mapped class.", type:getFullName(), this._classType:getFullName())
        System.throw(System.ArgumentNullException("type", message))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      this._knownTypes:Add(type)
    end
    -- <summary>
    -- Sets the Id member.
    -- </summary>
    SetIdMember = function (this, memberMap)
      if memberMap ~= nil then
        EnsureMemberMapIsForThisClass(this, memberMap)
      end

      if this._frozen then
        ThrowFrozenException(this)
      end

      this._idMemberMap = memberMap
    end
    -- <summary>
    -- Sets whether extra elements should be ignored when deserializing.
    -- </summary>
    SetIgnoreExtraElements = function (this, ignoreExtraElements)
      if this._frozen then
        ThrowFrozenException(this)
      end
      this._ignoreExtraElements = ignoreExtraElements
    end
    -- <summary>
    -- Sets whether the IgnoreExtraElements value should be inherited by derived classes.
    -- </summary>
    SetIgnoreExtraElementsIsInherited = function (this, ignoreExtraElementsIsInherited)
      if this._frozen then
        ThrowFrozenException(this)
      end
      this._ignoreExtraElementsIsInherited = ignoreExtraElementsIsInherited
    end
    -- <summary>
    -- Sets whether this class is a root class.
    -- </summary>
    SetIsRootClass = function (this, isRootClass)
      if this._frozen then
        ThrowFrozenException(this)
      end
      this._isRootClass = isRootClass
    end
    -- <summary>
    -- Removes a creator map for a constructor from the class map.
    -- </summary>
    UnmapConstructor = function (this, constructorInfo)
      if SystemReflection.ConstructorInfo.op_Equality(constructorInfo, nil) then
        System.throw(System.ArgumentNullException("constructorInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, constructorInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local creatorMap = Linq.FirstOrDefault(this._creatorMaps, function (m)
        return m:getMemberInfo() == constructorInfo
      end)
      if creatorMap ~= nil then
        this._creatorMaps:Remove(creatorMap)
      end
    end
    -- <summary>
    -- Removes a creator map for a factory method from the class map.
    -- </summary>
    UnmapFactoryMethod = function (this, methodInfo)
      if methodInfo == nil then
        System.throw(System.ArgumentNullException("methodInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, methodInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local creatorMap = Linq.FirstOrDefault(this._creatorMaps, function (m)
        return m:getMemberInfo() == methodInfo
      end)
      if creatorMap ~= nil then
        this._creatorMaps:Remove(creatorMap)
      end
    end
    -- <summary>
    -- Removes the member map for a field from the class map.
    -- </summary>
    UnmapField = function (this, fieldName)
      if fieldName == nil then
        System.throw(System.ArgumentNullException("fieldName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local fieldInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):GetField(fieldName, 54 --[[BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly]])
      if fieldInfo == nil then
        local message = System.String.Format("The class '{0}' does not have a field named '{1}'.", this._classType:getFullName(), fieldName)
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
      end
      UnmapMember(this, fieldInfo)
    end
    -- <summary>
    -- Removes a member map from the class map.
    -- </summary>
    UnmapMember = function (this, memberInfo)
      if memberInfo == nil then
        System.throw(System.ArgumentNullException("memberInfo"))
      end
      EnsureMemberInfoIsForThisClass(this, memberInfo)

      if this._frozen then
        ThrowFrozenException(this)
      end
      local memberMap = this._declaredMemberMaps:Find(function (m)
        return m:getMemberInfo() == memberInfo
      end)
      if memberMap ~= nil then
        this._declaredMemberMaps:Remove(memberMap)
        if this._idMemberMap == memberMap then
          this._idMemberMap = nil
        end
        if this._extraElementsMemberMap == memberMap then
          this._extraElementsMemberMap = nil
        end
      end
    end
    -- <summary>
    -- Removes the member map for a property from the class map.
    -- </summary>
    UnmapProperty = function (this, propertyName)
      if propertyName == nil then
        System.throw(System.ArgumentNullException("propertyName"))
      end

      if this._frozen then
        ThrowFrozenException(this)
      end
      local propertyInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):GetProperty(propertyName, 54 --[[BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly]])
      if propertyInfo == nil then
        local message = System.String.Format("The class '{0}' does not have a property named '{1}'.", this._classType:getFullName(), propertyName)
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
      end
      UnmapMember(this, propertyInfo)
    end
    -- <summary>
    -- Gets the discriminator convention for the class.
    -- </summary>
    GetDiscriminatorConvention = function (this)
      -- return a cached discriminator convention when possible
      local discriminatorConvention = this._discriminatorConvention
      if discriminatorConvention == nil then
        -- it's possible but harmless for multiple threads to do the initial lookup at the same time
        discriminatorConvention = MongoDBBsonSerialization.BsonSerializer.LookupDiscriminatorConvention(this._classType)
        this._discriminatorConvention = discriminatorConvention
      end
      return discriminatorConvention
    end
    AutoMapClass = function (this)
      MongoDBConventions.ConventionRunner(this._conventionPack):Apply(this)

      for _, memberMap in System.each(this._declaredMemberMaps) do
        TryFindShouldSerializeMethod(this, memberMap)
      end
    end
    TryFindShouldSerializeMethod = function (this, memberMap)
      -- see if the class has a method called ShouldSerializeXyz where Xyz is the name of this member
      local shouldSerializeMethod = GetShouldSerializeMethod(this, memberMap:getMemberInfo())
      if shouldSerializeMethod ~= nil then
        memberMap:SetShouldSerializeMethod(shouldSerializeMethod)
      end
    end
    EnsureMemberInfoIsForThisClass = function (this, memberInfo)
      if memberInfo:getDeclaringType() ~= this._classType then
        local message = System.String.Format("The memberInfo argument must be for class {0}, but was for class {1}.", this._classType:getName(), memberInfo:getDeclaringType():getName())
        System.throw(System.ArgumentOutOfRangeException("memberInfo", message))
      end
    end
    EnsureMemberMapIsForThisClass = function (this, memberMap)
      if memberMap:getClassMap() ~= this then
        local message = System.String.Format("The memberMap argument must be for class {0}, but was for class {1}.", this._classType:getName(), getClassType(memberMap:getClassMap()):getName())
        System.throw(System.ArgumentOutOfRangeException("memberMap", message))
      end
    end
    GetCreator = function (this)
      if this._creator == nil then
        local body
        local bindingFlags = 52 --[[BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance]]
        local classTypeInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType)
        local defaultConstructor = Linq.SingleOrDefault(Linq.Where(classTypeInfo:GetConstructors(bindingFlags), function (c)
          return #c:GetParameters() == 0
        end))
        if SystemReflection.ConstructorInfo.op_Inequality(defaultConstructor, nil) then
          -- lambdaExpression = () => (object) new TClass()
          body = SystemLinqExpressions.Expression.New(defaultConstructor)
        elseif __getUninitializedObjectMethodInfo ~= nil then
          -- lambdaExpression = () => FormatterServices.GetUninitializedObject(classType)
          body = SystemLinqExpressions.Expression.Call(__getUninitializedObjectMethodInfo, SystemLinqExpressions.Expression.Constant(this._classType))
        else
          local message = "Type '" .. this._classType:GetType():getName() .. "' does not have a default constructor."
          System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
        end

        local lambdaExpression = SystemLinqExpressions.Expression.Lambda(body, System.Array(SystemLinqExpressions.ParameterExpression)(), System.Delegate)
        this._creator = lambdaExpression:Compile()
      end
      return this._creator
    end
    GetShouldSerializeMethod = function (this, memberInfo)
      local shouldSerializeMethodName = "ShouldSerialize" .. memberInfo:getName()
      local shouldSerializeMethodInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classType):GetMethod(shouldSerializeMethodName, ArrayType:new(0))
      if shouldSerializeMethodInfo ~= nil and shouldSerializeMethodInfo:getIsPublic() and shouldSerializeMethodInfo:getReturnType() == System.typeof(System.Boolean) then
        -- lambdaExpression = (obj) => ((TClass) obj).ShouldSerializeXyz()
        local objParameter = SystemLinqExpressions.Expression.Parameter(System.typeof(System.Object), "obj")
        local lambdaExpression = SystemLinqExpressions.Expression.Lambda(SystemLinqExpressions.Expression.Call(SystemLinqExpressions.Expression.Convert(objParameter, this._classType), shouldSerializeMethodInfo), objParameter, System.Delegate)
        return lambdaExpression:Compile()
      else
        return nil
      end
    end
    IsAnonymousType = function (this, type)
      -- don't test for too many things in case implementation details change in the future
      local typeInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(type)
      return Linq.Any(SystemReflection.CustomAttributeExtensions.GetCustomAttributes(typeInfo, false, System.CompilerGeneratedAttribute)) and typeInfo:getIsGenericType() and type:getName():Contains("Anon")
      -- don't check for more than "Anon" so it works in mono also
    end
    ThrowFrozenException = function (this)
      local message = System.String.Format("Class map for {0} has been frozen and no further changes are allowed.", this._classType:getFullName())
      System.throw(System.InvalidOperationException(message))
    end
    ThrowNotFrozenException = function (this)
      local message = System.String.Format("Class map for {0} has been not been frozen yet.", this._classType:getFullName())
      System.throw(System.InvalidOperationException(message))
    end
    class = {
      _isAnonymous = false,
      _frozen = false,
      _discriminatorIsRequired = false,
      _hasRootClass = false,
      _isRootClass = false,
      _ignoreExtraElements = false,
      _ignoreExtraElementsIsInherited = false,
      _extraElementsMemberIndex = - 1,
      getAllMemberMaps = getAllMemberMaps,
      getBaseClassMap = getBaseClassMap,
      getClassType = getClassType,
      getCreatorMaps = getCreatorMaps,
      getConventionPack = getConventionPack,
      getDeclaredMemberMaps = getDeclaredMemberMaps,
      getDiscriminator = getDiscriminator,
      getDiscriminatorIsRequired = getDiscriminatorIsRequired,
      getExtraElementsMemberMap = getExtraElementsMemberMap,
      getHasCreatorMaps = getHasCreatorMaps,
      getHasRootClass = getHasRootClass,
      getIdMemberMap = getIdMemberMap,
      getIgnoreExtraElements = getIgnoreExtraElements,
      getIgnoreExtraElementsIsInherited = getIgnoreExtraElementsIsInherited,
      getIsAnonymous = getIsAnonymous,
      getIsFrozen = getIsFrozen,
      getIsRootClass = getIsRootClass,
      getKnownTypes = getKnownTypes,
      getElementTrie = getElementTrie,
      getExtraElementsMemberMapIndex = getExtraElementsMemberMapIndex,
      GetMemberInfoType = GetMemberInfoType,
      GetRegisteredClassMaps = GetRegisteredClassMaps,
      IsClassMapRegistered = IsClassMapRegistered,
      LookupClassMap = LookupClassMap,
      RegisterClassMap = RegisterClassMap,
      RegisterClassMap1 = RegisterClassMap1,
      RegisterClassMap2 = RegisterClassMap2,
      AutoMap = AutoMap,
      CreateInstance = CreateInstance,
      Freeze = Freeze,
      GetMemberMap = GetMemberMap,
      GetMemberMapForElement = GetMemberMapForElement,
      MapConstructor = MapConstructor,
      MapConstructor1 = MapConstructor1,
      MapCreator = MapCreator,
      MapCreator1 = MapCreator1,
      MapExtraElementsField = MapExtraElementsField,
      MapExtraElementsMember = MapExtraElementsMember,
      MapExtraElementsProperty = MapExtraElementsProperty,
      MapFactoryMethod = MapFactoryMethod,
      MapFactoryMethod1 = MapFactoryMethod1,
      MapField = MapField,
      MapIdField = MapIdField,
      MapIdMember = MapIdMember,
      MapIdProperty = MapIdProperty,
      MapMember = MapMember,
      MapProperty = MapProperty,
      Reset = Reset,
      SetCreator = SetCreator,
      SetDiscriminator = SetDiscriminator,
      SetDiscriminatorIsRequired = SetDiscriminatorIsRequired,
      SetExtraElementsMember = SetExtraElementsMember,
      AddKnownType = AddKnownType,
      SetIdMember = SetIdMember,
      SetIgnoreExtraElements = SetIgnoreExtraElements,
      SetIgnoreExtraElementsIsInherited = SetIgnoreExtraElementsIsInherited,
      SetIsRootClass = SetIsRootClass,
      UnmapConstructor = UnmapConstructor,
      UnmapFactoryMethod = UnmapFactoryMethod,
      UnmapField = UnmapField,
      UnmapMember = UnmapMember,
      UnmapProperty = UnmapProperty,
      GetDiscriminatorConvention = GetDiscriminatorConvention,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
    return class
  end)

  -- <summary>
  -- Represents a mapping between a class and a BSON document.
  -- </summary>
  namespace.class("BsonClassMap_1", function (namespace)
    return function (TClass)
      local CreateInstance1, GetMemberMap1, MapCreator2, MapExtraElementsField1, MapExtraElementsMember1, MapExtraElementsProperty1, MapField1, MapIdField1, 
      MapIdMember1, MapIdProperty1, MapMember1, MapProperty1, UnmapField1, UnmapMember1, UnmapProperty1, GetPropertyAccessors, 
      GetMemberInfoFromLambda, GetMemberNameFromLambda, FindPropertyImplementation, __ctor1__, __ctor2__
      -- <summary>
      -- Initializes a new instance of the BsonClassMap class.
      -- </summary>
      __ctor1__ = function (this)
        MongoDBBsonSerialization.BsonClassMap.__ctor__[1](this, System.typeof(TClass))
      end
      -- <summary>
      -- Initializes a new instance of the BsonClassMap class.
      -- </summary>
      __ctor2__ = function (this, classMapInitializer)
        MongoDBBsonSerialization.BsonClassMap.__ctor__[1](this, System.typeof(TClass))
        classMapInitializer(this)
      end
      -- <summary>
      -- Creates an instance.
      -- </summary>
      CreateInstance1 = function (this)
        return System.cast(TClass, this:CreateInstance())
      end
      -- <summary>
      -- Gets a member map.
      -- </summary>
      -- <param name="memberLambda">A lambda expression specifying the member.</param>
      -- <returns>The member map.</returns>
      GetMemberMap1 = function (this, memberLambda, TMember)
        local memberName = GetMemberNameFromLambda(memberLambda, TMember)
        return this:GetMemberMap(memberName)
      end
      -- <summary>
      -- Creates a creator map and adds it to the class map.
      -- </summary>
      -- <returns>The member map.</returns>
      MapCreator2 = function (this, creatorLambda)
        if creatorLambda == nil then
          System.throw(System.ArgumentNullException("creatorLambda"))
        end

        local arguments
        local default
        default, arguments = MongoDBBsonSerialization.CreatorMapDelegateCompiler():CompileCreatorDelegate(creatorLambda, nil, TClass)
        local delegate = default
        local creatorMap = this:MapCreator(delegate)
        creatorMap:SetArguments(arguments)
        return creatorMap
      end
      -- <summary>
      -- Creates a member map for the extra elements field and adds it to the class map.
      -- </summary>
      -- <param name="fieldLambda">A lambda expression specifying the extra elements field.</param>
      -- <returns>The member map.</returns>
      MapExtraElementsField1 = function (this, fieldLambda, TMember)
        local fieldMap = MapField1(this, fieldLambda, TMember)
        this:SetExtraElementsMember(fieldMap)
        return fieldMap
      end
      -- <summary>
      -- Creates a member map for the extra elements member and adds it to the class map.
      -- </summary>
      -- <param name="memberLambda">A lambda expression specifying the extra elements member.</param>
      -- <returns>The member map.</returns>
      MapExtraElementsMember1 = function (this, memberLambda, TMember)
        local memberMap = MapMember1(this, memberLambda, TMember)
        this:SetExtraElementsMember(memberMap)
        return memberMap
      end
      -- <summary>
      -- Creates a member map for the extra elements property and adds it to the class map.
      -- </summary>
      -- <param name="propertyLambda">A lambda expression specifying the extra elements property.</param>
      -- <returns>The member map.</returns>
      MapExtraElementsProperty1 = function (this, propertyLambda, TMember)
        local propertyMap = MapProperty1(this, propertyLambda, TMember)
        this:SetExtraElementsMember(propertyMap)
        return propertyMap
      end
      -- <summary>
      -- Creates a member map for a field and adds it to the class map.
      -- </summary>
      -- <param name="fieldLambda">A lambda expression specifying the field.</param>
      -- <returns>The member map.</returns>
      MapField1 = function (this, fieldLambda, TMember)
        return MapMember1(this, fieldLambda, TMember)
      end
      -- <summary>
      -- Creates a member map for the Id field and adds it to the class map.
      -- </summary>
      -- <param name="fieldLambda">A lambda expression specifying the Id field.</param>
      -- <returns>The member map.</returns>
      MapIdField1 = function (this, fieldLambda, TMember)
        local fieldMap = MapField1(this, fieldLambda, TMember)
        this:SetIdMember(fieldMap)
        return fieldMap
      end
      -- <summary>
      -- Creates a member map for the Id member and adds it to the class map.
      -- </summary>
      -- <param name="memberLambda">A lambda expression specifying the Id member.</param>
      -- <returns>The member map.</returns>
      MapIdMember1 = function (this, memberLambda, TMember)
        local memberMap = MapMember1(this, memberLambda, TMember)
        this:SetIdMember(memberMap)
        return memberMap
      end
      -- <summary>
      -- Creates a member map for the Id property and adds it to the class map.
      -- </summary>
      -- <param name="propertyLambda">A lambda expression specifying the Id property.</param>
      -- <returns>The member map.</returns>
      MapIdProperty1 = function (this, propertyLambda, TMember)
        local propertyMap = MapProperty1(this, propertyLambda, TMember)
        this:SetIdMember(propertyMap)
        return propertyMap
      end
      -- <summary>
      -- Creates a member map and adds it to the class map.
      -- </summary>
      -- <param name="memberLambda">A lambda expression specifying the member.</param>
      -- <returns>The member map.</returns>
      MapMember1 = function (this, memberLambda, TMember)
        local memberInfo = GetMemberInfoFromLambda(memberLambda, TMember)
        return this:MapMember(memberInfo)
      end
      -- <summary>
      -- Creates a member map for the Id property and adds it to the class map.
      -- </summary>
      -- <param name="propertyLambda">A lambda expression specifying the Id property.</param>
      -- <returns>The member map.</returns>
      MapProperty1 = function (this, propertyLambda, TMember)
        return MapMember1(this, propertyLambda, TMember)
      end
      -- <summary>
      -- Removes the member map for a field from the class map.
      -- </summary>
      -- <param name="fieldLambda">A lambda expression specifying the field.</param>
      UnmapField1 = function (this, fieldLambda, TMember)
        UnmapMember1(this, fieldLambda, TMember)
      end
      -- <summary>
      -- Removes a member map from the class map.
      -- </summary>
      -- <param name="memberLambda">A lambda expression specifying the member.</param>
      UnmapMember1 = function (this, memberLambda, TMember)
        local memberInfo = GetMemberInfoFromLambda(memberLambda, TMember)
        this:UnmapMember(memberInfo)
      end
      -- <summary>
      -- Removes a member map for a property from the class map.
      -- </summary>
      -- <param name="propertyLambda">A lambda expression specifying the property.</param>
      UnmapProperty1 = function (this, propertyLambda, TMember)
        UnmapMember1(this, propertyLambda, TMember)
      end
      GetPropertyAccessors = function (propertyInfo)
        return propertyInfo:GetAccessors(true)
      end
      GetMemberInfoFromLambda = function (memberLambda, TMember)
        local body = memberLambda:getBody()
        local memberExpression
        repeat
          local default = body:getNodeType()
          if default == 23 --[[ExpressionType.MemberAccess]] then
            memberExpression = System.cast(SystemLinqExpressions.MemberExpression, body)
            break
          elseif default == 10 --[[ExpressionType.Convert]] then
            local convertExpression = System.cast(SystemLinqExpressions.UnaryExpression, body)
            memberExpression = System.cast(SystemLinqExpressions.MemberExpression, convertExpression:getOperand())
            break
          else
            System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "Invalid lambda expression"))
          end
        until 1
        local memberInfo = memberExpression:getMember()
        if System.is(memberInfo, SystemReflection.PropertyInfo) then
          if SystemReflection.IntrospectionExtensions.GetTypeInfo(memberInfo:getDeclaringType()):getIsInterface() then
            memberInfo = FindPropertyImplementation(System.cast(SystemReflection.PropertyInfo, memberInfo), System.typeof(TClass))
          end
        elseif not (System.is(memberInfo, SystemReflection.FieldInfo)) then
          System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "Invalid lambda expression"))
        end
        return memberInfo
      end
      GetMemberNameFromLambda = function (memberLambda, TMember)
        return GetMemberInfoFromLambda(memberLambda, TMember):getName()
      end
      FindPropertyImplementation = function (interfacePropertyInfo, actualType)
        local interfaceType = interfacePropertyInfo:getDeclaringType()

        -- An interface map must be used because because there is no
        -- other officially documented way to derive the explicitly
        -- implemented property name.
        local interfaceMap = actualType:GetInterfaceMap(interfaceType)

        local interfacePropertyAccessors = GetPropertyAccessors(interfacePropertyInfo)

        local actualPropertyAccessors = Linq.Select(interfacePropertyAccessors, function (interfacePropertyAccessor)
          local index = System.Array.IndexOf(interfaceMap.InterfaceMethods, interfacePropertyAccessor)

          return interfaceMap.TargetMethods:get(index)
        end, SystemReflection.MethodInfo)

        -- Binding must be done by accessor methods because interface
        -- maps only map accessor methods and do not map properties.
        return Linq.Single({0, function (propertyInfo)
          -- we are looking for a property that implements all the required accessors
          local propertyAccessors = GetPropertyAccessors(propertyInfo)
          return Linq.All(actualPropertyAccessors, function (x)
            return Linq.Contains(propertyAccessors, x)
          end)
        end})
      end
      return {
        base = function (out)
          return {
            out.MongoDB.Bson.Serialization.BsonClassMap
          }
        end,
        CreateInstance1 = CreateInstance1,
        GetMemberMap1 = GetMemberMap1,
        MapCreator2 = MapCreator2,
        MapExtraElementsField1 = MapExtraElementsField1,
        MapExtraElementsMember1 = MapExtraElementsMember1,
        MapExtraElementsProperty1 = MapExtraElementsProperty1,
        MapField1 = MapField1,
        MapIdField1 = MapIdField1,
        MapIdMember1 = MapIdMember1,
        MapIdProperty1 = MapIdProperty1,
        MapMember1 = MapMember1,
        MapProperty1 = MapProperty1,
        UnmapField1 = UnmapField1,
        UnmapMember1 = UnmapMember1,
        UnmapProperty1 = UnmapProperty1,
        __ctor__ = {
          __ctor1__,
          __ctor2__
        }
      }
    end
  end)
end)
