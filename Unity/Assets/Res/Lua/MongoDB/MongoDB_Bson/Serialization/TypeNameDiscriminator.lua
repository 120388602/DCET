-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local SystemReflection = System.Reflection
local SystemRegularExpressions = System.Text.RegularExpressions
local ListType = System.List(System.Type)
local ListString = System.List(System.String)
local ArrayAssembly = System.Array(SystemReflection.Assembly)
System.namespace("MongoDB.Bson.Serialization", function (namespace)
  -- <summary>
  -- Supports using type names as discriminators.
  -- </summary>
  namespace.class("TypeNameDiscriminator", function (namespace)
    local __wellKnownAssemblies, GetActualType, GetDiscriminator, TryParseGenericTypeName, static
    static = function (this)
      __wellKnownAssemblies = ArrayAssembly(SystemReflection.IntrospectionExtensions.GetTypeInfo(System.typeof(System.Object)):getAssembly(), SystemReflection.IntrospectionExtensions.GetTypeInfo(System.typeof(System.Queue)):getAssembly(), SystemReflection.IntrospectionExtensions.GetTypeInfo(System.typeof(System.HashSet)):getAssembly())
    end
    -- <summary>
    -- Resolves a type name discriminator.
    -- </summary>
    -- <returns>The type if type type name can be resolved; otherwise, null.</returns>
    GetActualType = function (typeName)
      local type = System.Type.GetTypeFrom(typeName)
      if type ~= nil then
        return type
      end

      for _, assembly in System.each(__wellKnownAssemblies) do
        type = assembly:GetTypeFrom(typeName)
        if type ~= nil then
          return type
        end
      end

      local genericTypeDefinitionName
      local typeArgumentNames
      local default
      default, genericTypeDefinitionName, typeArgumentNames = TryParseGenericTypeName(typeName)
      if default then
        local genericTypeDefinition = GetActualType(genericTypeDefinitionName)
        if genericTypeDefinition ~= nil then
          local typeArguments = ListType()
          for _, typeArgumentName in System.each(typeArgumentNames) do
            local typeArgument = GetActualType(typeArgumentName)
            if typeArgument == nil then
              break
            end
            typeArguments:Add(typeArgument)
          end

          if #typeArguments == #SystemReflection.IntrospectionExtensions.GetTypeInfo(genericTypeDefinition):GetGenericArguments() then
            return genericTypeDefinition:MakeGenericType(typeArguments:ToArray())
          end
        end
      end

      return nil
    end
    -- <summary>
    -- Gets a type name to be used as a discriminator (like AssemblyQualifiedName but shortened for common DLLs).
    -- </summary>
    -- <returns>The type name.</returns>
    GetDiscriminator = function (type)
      if type == nil then
        System.throw(System.ArgumentNullException("type"))
      end
      local typeInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(type)

      local typeName
      if typeInfo:getIsGenericType() then
        local typeArgumentNames = ""
        for _, typeArgument in System.each(SystemReflection.IntrospectionExtensions.GetTypeInfo(type):GetGenericArguments()) do
          local typeArgumentName = GetDiscriminator(typeArgument)
          if typeArgumentName:IndexOf(44 --[[',']]) ~= - 1 then
            typeArgumentName = "[" .. typeArgumentName .. "]"
          end
          if typeArgumentNames ~= "" then
            typeArgumentNames = typeArgumentNames .. ","
          end
          typeArgumentNames = typeArgumentNames .. typeArgumentName
        end
        typeName = type:GetGenericTypeDefinition():getFullName() .. "[" .. typeArgumentNames .. "]"
      else
        typeName = type:getFullName()
      end

      local assembly = SystemReflection.IntrospectionExtensions.GetTypeInfo(type):getAssembly()
      local assemblyName = nil
      if not Linq.Contains(__wellKnownAssemblies, assembly) then
        assemblyName = assembly:getFullName()
        local match = SystemRegularExpressions.Regex.Match(assemblyName, "(?<dll>[^,]+), Version=[^,]+, Culture=[^,]+, PublicKeyToken=(?<token>[^,]+)")
        if match:getSuccess() then
          local publicKeyToken = match:getGroups():get("token"):getValue()
          if publicKeyToken == "null" then
            local dllName = match:getGroups():get("dll"):getValue()
            assemblyName = dllName
          end
        end
      end

      if assemblyName == nil then
        return typeName
      else
        return typeName .. ", " .. assemblyName
      end
    end
    TryParseGenericTypeName = function (typeName, genericTypeDefinitionName, typeArgumentNames)
      local leftBracketIndex = typeName:IndexOf(91 --[['[']])
      if leftBracketIndex ~= - 1 then
        genericTypeDefinitionName = typeName:Substring(0, leftBracketIndex)
        local typeArgumentNamesString = typeName:Substring(leftBracketIndex + 1, #typeName - leftBracketIndex - 2)
        local typeArgumentNamesList = ListString()
        local startIndex = 0
        local nestingLevel = 0
        for index = 0, #typeArgumentNamesString - 1 do
          local c = typeArgumentNamesString:get(index)
          repeat
            local default = c
            if default == 91 --[['[']] then
              nestingLevel = nestingLevel + 1
              break
            elseif default == 93 --[[']']] then
              nestingLevel = nestingLevel - 1
              break
            elseif default == 44 --[[',']] then
              if nestingLevel == 0 then
                local typeArgumentName = typeArgumentNamesString:Substring(startIndex, index - startIndex)
                typeArgumentNamesList:Add(typeArgumentName)
              end
              break
            end
          until 1
        end
        typeArgumentNamesList:Add(typeArgumentNamesString:Substring(startIndex))
        typeArgumentNames = typeArgumentNamesList:ToArray()
        return true, genericTypeDefinitionName, typeArgumentNames
      end

      genericTypeDefinitionName = nil
      typeArgumentNames = nil
      return false, genericTypeDefinitionName, typeArgumentNames
    end
    return {
      GetActualType = GetActualType,
      GetDiscriminator = GetDiscriminator,
      static = static
    }
  end)
end)
