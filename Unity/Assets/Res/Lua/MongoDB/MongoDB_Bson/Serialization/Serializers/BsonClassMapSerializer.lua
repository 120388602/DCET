-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local SystemComponentModel = System.ComponentModel
local SystemReflection = System.Reflection
local ArrayUInt32 = System.Array(System.UInt32)
local DictStringObject = System.Dictionary(System.String, System.Object)
local IDictionary_2StringObject = System.IDictionary_2(System.String, System.Object)
local MongoDBBson
local MongoDBBsonIO
local MongoDBBsonSerialization
local MongoDBSerializers
local TrieNameDecoder_1Int32
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
  MongoDBBsonSerialization = MongoDB.Bson.Serialization
  MongoDBSerializers = MongoDB.Bson.Serialization.Serializers
  TrieNameDecoder_1Int32 = MongoDBBsonIO.TrieNameDecoder_1(System.Int32)
end)
System.namespace("MongoDB.Bson.Serialization", function (namespace)
  -- <summary>
  -- Represents a serializer for a class map.
  -- </summary>
  namespace.class("BsonClassMapSerializer_1", function (namespace)
    namespace.class("FastMemberMapHelper", function (namespace)
      return function (TClass)
        local GetBitArray, GetLeastSignificantBit
        GetBitArray = function (memberCount)
          local bitArrayOffset = System.band(memberCount, 31)
          local bitArrayLength = System.sr(memberCount, 5)
          if bitArrayOffset == 0 then
            return ArrayUInt32:new(bitArrayLength)
          end
          local bitArray = ArrayUInt32:new(bitArrayLength + 1)
          bitArray:set(bitArrayLength, System.sl(System.bnot(0), bitArrayOffset))
          -- set unused bits to 1
          return bitArray
        end
        GetLeastSignificantBit = function (bitBlock)
          local leastSignificantBit = 1
          if (System.band(bitBlock, 65535)) == 0 then
            bitBlock = System.sr(bitBlock, 16)
            leastSignificantBit = System.bor(leastSignificantBit, 16)
          end
          if (System.band(bitBlock, 255)) == 0 then
            bitBlock = System.sr(bitBlock, 8)
            leastSignificantBit = System.bor(leastSignificantBit, 8)
          end
          if (System.band(bitBlock, 15)) == 0 then
            bitBlock = System.sr(bitBlock, 4)
            leastSignificantBit = System.bor(leastSignificantBit, 4)
          end
          if (System.band(bitBlock, 3)) == 0 then
            bitBlock = System.sr(bitBlock, 2)
            leastSignificantBit = System.bor(leastSignificantBit, 2)
          end
          return leastSignificantBit - System.toInt32(System.band(bitBlock, 1))
        end
        return {
          GetBitArray = GetBitArray,
          GetLeastSignificantBit = GetLeastSignificantBit
        }
      end
    end)
    return function (TClass)
      local getIsDiscriminatorCompatibleWithObjectSerializer, Deserialize, DeserializeClass, GetDocumentId, TryGetMemberSerializationInfo, Serialize, SetDocumentId, ChooseBestCreator, 
      CreateInstanceUsingCreator, DeserializeExtraElementMember, DeserializeExtraElementValue, DeserializeMemberValue, SerializeClass, SerializeExtraElements, SerializeDiscriminator, SerializeMember, 
      SerializeNormalMember, ShouldSerializeDiscriminator, __ctor__
      local FastMemberMapHelperTClass = MongoDB.Bson.Serialization.BsonClassMapSerializer_1.FastMemberMapHelper(TClass)
      -- <summary>
      -- Initializes a new instance of the BsonClassMapSerializer class.
      -- </summary>
      __ctor__ = function (this, classMap)
        if classMap == nil then
          System.throw(System.ArgumentNullException("classMap"))
        end
        if classMap:getClassType() ~= System.typeof(TClass) then
          local message = System.String.Format("Must be a BsonClassMap for the type {0}.", System.typeof(TClass))
          System.throw(System.ArgumentException(message, "classMap"))
        end
        if not classMap:getIsFrozen() then
          System.throw(System.ArgumentException("Class map is not frozen.", "classMap" --[[nameof(classMap)]]))
        end

        this._classMap = classMap
      end
      getIsDiscriminatorCompatibleWithObjectSerializer = function (this)
        return true
      end
      -- <summary>
      -- Deserializes a value.
      -- </summary>
      -- <param name="args">The deserialization args.</param>
      -- <returns>A deserialized value.</returns>
      Deserialize = function (this, context, args)
        local bsonReader = context:getReader()

        if SystemReflection.IntrospectionExtensions.GetTypeInfo(this._classMap:getClassType()):getIsValueType() then
          local message = System.String.Format("Value class {0} cannot be deserialized.", this._classMap:getClassType():getFullName())
          System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
        end

        if bsonReader:GetCurrentBsonType() == 10 --[[BsonType.Null]] then
          bsonReader:ReadNull()
          return System.default(TClass)
        else
          local discriminatorConvention = this._classMap:GetDiscriminatorConvention()

          local actualType = discriminatorConvention:GetActualType(bsonReader, args:getNominalType())
          if actualType == System.typeof(TClass) then
            return DeserializeClass(this, context)
          else
            local serializer = MongoDBBsonSerialization.BsonSerializer.LookupSerializer1(actualType)
            return System.cast(TClass, MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize(serializer, context))
          end
        end
      end
      -- <summary>
      -- Deserializes a value.
      -- </summary>
      -- <returns>A deserialized value.</returns>
      DeserializeClass = function (this, context)
        local bsonReader = context:getReader()

        local bsonType = bsonReader:GetCurrentBsonType()
        if bsonType ~= 3 --[[BsonType.Document]] then
          local message = System.String.Format("Expected a nested document representing the serialized form of a {0} value, but found a value of type {1} instead.", System.typeof(TClass):getFullName(), bsonType)
          System.throw(System.FormatException(message))
        end

        local values = nil
        local document = System.default(TClass)
        local supportsInitialization = nil
        if this._classMap:getHasCreatorMaps() then
          -- for creator-based deserialization we first gather the values in a dictionary and then call a matching creator
          values = DictStringObject()
        else
          -- for mutable classes we deserialize the values directly into the result object
          document = System.cast(TClass, this._classMap:CreateInstance())

          supportsInitialization = System.as(document, SystemComponentModel.ISupportInitialize)
          if supportsInitialization ~= nil then
            supportsInitialization:BeginInit()
          end
        end

        local discriminatorConvention = this._classMap:GetDiscriminatorConvention()
        local allMemberMaps = this._classMap:getAllMemberMaps()
        local extraElementsMemberMapIndex = this._classMap:getExtraElementsMemberMapIndex()
        local memberMapBitArray = FastMemberMapHelperTClass.GetBitArray(allMemberMaps:getCount())

        bsonReader:ReadStartDocument()
        local elementTrie = this._classMap:getElementTrie()
        while bsonReader:ReadBsonType() ~= 0 --[[BsonType.EndOfDocument]] do
          local continue
          repeat
            local trieDecoder = TrieNameDecoder_1Int32(elementTrie)
            local elementName = bsonReader:ReadName(trieDecoder)

            if trieDecoder:getFound() then
              local memberMapIndex = trieDecoder:getValue()
              local memberMap = allMemberMaps:get(memberMapIndex)
              if memberMapIndex ~= extraElementsMemberMapIndex then
                if document ~= nil then
                  if memberMap:getIsReadOnly() then
                    bsonReader:SkipValue()
                  else
                    local value = DeserializeMemberValue(this, context, memberMap)
                    memberMap:getSetter()(document, value)
                  end
                else
                  local value = DeserializeMemberValue(this, context, memberMap)
                  values:set(elementName, value)
                end
              else
                if document ~= nil then
                  DeserializeExtraElementMember(this, context, document, elementName, memberMap)
                else
                  DeserializeExtraElementValue(this, context, values, elementName, memberMap)
                end
              end
              memberMapBitArray:set(System.sr(memberMapIndex, 5), System.bor(memberMapBitArray:get(System.sr(memberMapIndex, 5)), System.sl(1, (System.band(memberMapIndex, 31)))))
            else
              if elementName == discriminatorConvention:getElementName() then
                bsonReader:SkipValue()
                -- skip over discriminator
                continue = true
                break
              end

              if extraElementsMemberMapIndex >= 0 then
                local extraElementsMemberMap = this._classMap:getExtraElementsMemberMap()
                if document ~= nil then
                  DeserializeExtraElementMember(this, context, document, elementName, extraElementsMemberMap)
                else
                  DeserializeExtraElementValue(this, context, values, elementName, extraElementsMemberMap)
                end
                memberMapBitArray:set(System.sr(extraElementsMemberMapIndex, 5), System.bor(memberMapBitArray:get(System.sr(extraElementsMemberMapIndex, 5)), System.sl(1, (System.band(extraElementsMemberMapIndex, 31)))))
              elseif this._classMap:getIgnoreExtraElements() then
                bsonReader:SkipValue()
              else
                local message = System.String.Format("Element '{0}' does not match any field or property of class {1}.", elementName, this._classMap:getClassType():getFullName())
                System.throw(System.FormatException(message))
              end
            end
            continue = true
          until 1
          if not continue then
            break
          end
        end
        bsonReader:ReadEndDocument()

        -- check any members left over that we didn't have elements for (in blocks of 32 elements at a time)
        for bitArrayIndex = 0, #memberMapBitArray - 1 do
          local continue
          repeat
            local memberMapIndex = System.sl(bitArrayIndex, 5)
            local memberMapBlock = System.bnot(memberMapBitArray:get(bitArrayIndex))
            -- notice that bits are flipped so 1's are now the missing elements

            -- work through this memberMapBlock of 32 elements
            while true do
              local continue
              repeat
                -- examine missing elements (memberMapBlock is shifted right as we work through the block)
                do
                  while (System.band(memberMapBlock, 1)) ~= 0 do
                    local continue
                    repeat
                      local memberMap = allMemberMaps:get(memberMapIndex)
                      if memberMap:getIsReadOnly() then
                        continue = true
                        break
                      end

                      if memberMap:getIsRequired() then
                        local fieldOrProperty = (System.is(memberMap:getMemberInfo(), SystemReflection.FieldInfo)) and "field" or "property"
                        local message = System.String.Format("Required element '{0}' for {1} '{2}' of class {3} is missing.", memberMap:getElementName(), fieldOrProperty, memberMap:getMemberName(), this._classMap:getClassType():getFullName())
                        System.throw(System.FormatException(message))
                      end

                      if document ~= nil then
                        memberMap:ApplyDefaultValue(document)
                      elseif memberMap:getIsDefaultValueSpecified() and not memberMap:getIsReadOnly() then
                        values:set(memberMap:getElementName(), memberMap:getDefaultValue())
                      end
                      continue = true
                    until 1
                    if not continue then
                      break
                    end
                    memberMapIndex = memberMapIndex + 1
                    memberMapBlock = System.sr(memberMapBlock, 1)
                  end
                end

                if memberMapBlock == 0 then
                  break
                end

                -- skip ahead to the next missing element
                local leastSignificantBit = FastMemberMapHelperTClass.GetLeastSignificantBit(memberMapBlock)
                memberMapIndex = memberMapIndex + leastSignificantBit
                memberMapBlock = System.sr(memberMapBlock, leastSignificantBit)
                continue = true
              until 1
              if not continue then
                break
              end
            end
            continue = true
          until 1
          if not continue then
            break
          end
        end

        if document ~= nil then
          if supportsInitialization ~= nil then
            supportsInitialization:EndInit()
          end

          return document
        else
          return CreateInstanceUsingCreator(this, values)
        end
      end
      -- <summary>
      -- Gets the document Id.
      -- </summary>
      -- <param name="id">The Id.</param>
      -- <param name="idNominalType">The nominal type of the Id.</param>
      -- <param name="idGenerator">The IdGenerator for the Id type.</param>
      -- <returns>True if the document has an Id.</returns>
      GetDocumentId = function (this, document, id, idNominalType, idGenerator)
        local idMemberMap = this._classMap:getIdMemberMap()
        if idMemberMap ~= nil then
          id = idMemberMap:getGetter()(document)
          idNominalType = idMemberMap:getMemberType()
          idGenerator = idMemberMap:getIdGenerator()
          return true, id, idNominalType, idGenerator
        else
          id = nil
          idNominalType = nil
          idGenerator = nil
          return false, id, idNominalType, idGenerator
        end
      end
      -- <summary>
      -- Tries to get the serialization info for a member.
      -- </summary>
      -- <param name="serializationInfo">The serialization information.</param>
      -- <returns>
      -- <c>true</c> if the serialization info exists; otherwise <c>false</c>.
      -- </returns>
      TryGetMemberSerializationInfo = function (this, memberName, serializationInfo)
        for _, memberMap in System.each(this._classMap:getAllMemberMaps()) do
          if memberMap:getMemberName() == memberName then
            local elementName = memberMap:getElementName()
            local serializer = memberMap:GetSerializer()
            serializationInfo = MongoDBBsonSerialization.BsonSerializationInfo(elementName, serializer, serializer:getValueType())
            return true, serializationInfo
          end
        end

        serializationInfo = nil
        return false, serializationInfo
      end
      -- <summary>
      -- Serializes a value.
      -- </summary>
      -- <param name="args">The serialization args.</param>
      -- <param name="value">The object.</param>
      Serialize = function (this, context, args, value)
        local bsonWriter = context:getWriter()

        if value == nil then
          bsonWriter:WriteNull()
        else
          local actualType = value:GetType()
          if actualType == System.typeof(TClass) then
            SerializeClass(this, context, args:__clone__(), value)
          else
            local serializer = MongoDBBsonSerialization.BsonSerializer.LookupSerializer1(actualType)
            serializer:Serialize1(context, args:__clone__(), value)
          end
        end
      end
      -- <summary>
      -- Sets the document Id.
      -- </summary>
      -- <param name="id">The Id.</param>
      SetDocumentId = function (this, document, id)
        local documentType = document:GetType()
        local documentTypeInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(documentType)
        if documentTypeInfo:getIsValueType() then
          local message = System.String.Format("SetDocumentId cannot be used with value type {0}.", documentType:getFullName())
          System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
        end

        local idMemberMap = this._classMap:getIdMemberMap()
        if idMemberMap ~= nil then
          idMemberMap:getSetter()(document, id)
        else
          local message = System.String.Format("Class {0} has no Id member.", document:GetType():getFullName())
          System.throw(System.InvalidOperationException(message))
        end
      end
      ChooseBestCreator = function (this, values)
        -- there's only one selector for now, but there might be more in the future (possibly even user provided)
        local selector = MongoDBBsonSerialization.MostArgumentsCreatorSelector()
        local creatorMap = selector:SelectCreator(this._classMap, values)

        if creatorMap == nil then
          System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "No matching creator found."))
        end

        return creatorMap
      end
      CreateInstanceUsingCreator = function (this, values)
        local creatorMap = ChooseBestCreator(this, values)
        local document = creatorMap:CreateInstance(values)
        -- removes values consumed

        local supportsInitialization = System.as(document, SystemComponentModel.ISupportInitialize)
        if supportsInitialization ~= nil then
          supportsInitialization:BeginInit()
        end

        -- process any left over values that weren't passed to the creator
        for _, keyValuePair in System.each(values) do
          local elementName = keyValuePair.Key
          local value = keyValuePair.Value

          local memberMap = this._classMap:GetMemberMapForElement(elementName)
          if not memberMap:getIsReadOnly() then
            memberMap:getSetter()(document, value)
          end
        end

        if supportsInitialization ~= nil then
          supportsInitialization:EndInit()
        end

        return System.cast(TClass, document)
      end
      DeserializeExtraElementMember = function (this, context, obj, elementName, extraElementsMemberMap)
        local bsonReader = context:getReader()

        if extraElementsMemberMap:getMemberType() == System.typeof(MongoDBBson.BsonDocument) then
          local extraElements = System.cast(MongoDBBson.BsonDocument, extraElementsMemberMap:getGetter()(obj))
          if MongoDBBson.BsonDocument.op_Equality1(extraElements, nil) then
            extraElements = MongoDBBson.BsonDocument()
            extraElementsMemberMap:getSetter()(obj, extraElements)
          end

          local bsonValue = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, MongoDBBson.BsonValue)
          extraElements:set1(elementName, bsonValue)
        else
          local extraElements = System.cast(IDictionary_2StringObject, extraElementsMemberMap:getGetter()(obj))
          if extraElements == nil then
            if extraElementsMemberMap:getMemberType() == System.typeof(IDictionary_2StringObject) then
              extraElements = DictStringObject()
            else
              extraElements = System.cast(IDictionary_2StringObject, System.Activator.CreateInstance(extraElementsMemberMap:getMemberType()))
            end
            extraElementsMemberMap:getSetter()(obj, extraElements)
          end

          local bsonValue = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, MongoDBBson.BsonValue)
          extraElements:set(elementName, MongoDBBson.BsonTypeMapper.MapToDotNetValue(bsonValue))
        end
      end
      DeserializeExtraElementValue = function (this, context, values, elementName, extraElementsMemberMap)
        local bsonReader = context:getReader()

        if extraElementsMemberMap:getMemberType() == System.typeof(MongoDBBson.BsonDocument) then
          local extraElements
          local obj
          local default
          default, obj = values:TryGetValue(extraElementsMemberMap:getElementName())
          if default then
            extraElements = System.cast(MongoDBBson.BsonDocument, obj)
          else
            extraElements = MongoDBBson.BsonDocument()
            values:AddKeyValue(extraElementsMemberMap:getElementName(), extraElements)
          end

          local bsonValue = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, MongoDBBson.BsonValue)
          extraElements:set1(elementName, bsonValue)
        else
          local extraElements
          local obj
          local default
          default, obj = values:TryGetValue(extraElementsMemberMap:getElementName())
          if default then
            extraElements = System.cast(IDictionary_2StringObject, obj)
          else
            if extraElementsMemberMap:getMemberType() == System.typeof(IDictionary_2StringObject) then
              extraElements = DictStringObject()
            else
              extraElements = System.cast(IDictionary_2StringObject, System.Activator.CreateInstance(extraElementsMemberMap:getMemberType()))
            end
            values:AddKeyValue(extraElementsMemberMap:getElementName(), extraElements)
          end

          local bsonValue = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, MongoDBBson.BsonValue)
          extraElements:set(elementName, MongoDBBson.BsonTypeMapper.MapToDotNetValue(bsonValue))
        end
      end
      DeserializeMemberValue = function (this, context, memberMap)
        local bsonReader = context:getReader()

        local default, extern = System.try(function ()
          return true, MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize(memberMap:GetSerializer(), context)
        end, function (default)
          local ex = default
          local message = System.String.Format("An error occurred while deserializing the {0} {1} of class {2}: {3}", memberMap:getMemberName(), (System.is(memberMap:getMemberInfo(), SystemReflection.FieldInfo)) and "field" or "property", memberMap:getClassMap():getClassType():getFullName(), ex:getMessage())
          System.throw(System.FormatException(message, ex))
        end)
        if default then
          return extern
        end
      end
      SerializeClass = function (this, context, args, document)
        local bsonWriter = context:getWriter()

        local remainingMemberMaps = Linq.ToList(this._classMap:getAllMemberMaps())

        bsonWriter:WriteStartDocument()

        local idMemberMap = this._classMap:getIdMemberMap()
        if idMemberMap ~= nil and args:getSerializeIdFirst() then
          SerializeMember(this, context, document, idMemberMap)
          remainingMemberMaps:Remove(idMemberMap)
        end

        --var autoTimeStampMemberMap = _classMap.AutoTimeStampMemberMap;
        --if (autoTimeStampMemberMap != null)
        --{
        --    SerializeNormalMember(context, document, autoTimeStampMemberMap);
        --    remainingMemberMaps.Remove(autoTimeStampMemberMap);
        --}

        if ShouldSerializeDiscriminator(this, args:getNominalType()) then
          SerializeDiscriminator(this, context, args:getNominalType(), document)
        end

        for _, memberMap in System.each(remainingMemberMaps) do
          SerializeMember(this, context, document, memberMap)
        end

        bsonWriter:WriteEndDocument()
      end
      SerializeExtraElements = function (this, context, obj, extraElementsMemberMap)
        local bsonWriter = context:getWriter()

        local extraElements = extraElementsMemberMap:getGetter()(obj)
        if extraElements ~= nil then
          if extraElementsMemberMap:getMemberType() == System.typeof(MongoDBBson.BsonDocument) then
            local bsonDocument = System.cast(MongoDBBson.BsonDocument, extraElements)
            for _, element in System.each(bsonDocument) do
              bsonWriter:WriteName(element:getName())
              MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, element:getValue(), MongoDBBson.BsonValue)
            end
          else
            local dictionary = System.cast(IDictionary_2StringObject, extraElements)
            for _, key in System.each(dictionary:getKeys()) do
              bsonWriter:WriteName(key)
              local value = dictionary:get(key)
              local bsonValue = MongoDBBson.BsonTypeMapper.MapToBsonValue(value)
              MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, bsonValue, MongoDBBson.BsonValue)
            end
          end
        end
      end
      SerializeDiscriminator = function (this, context, nominalType, obj)
        local discriminatorConvention = this._classMap:GetDiscriminatorConvention()
        if discriminatorConvention ~= nil then
          local actualType = obj:GetType()
          local discriminator = discriminatorConvention:GetDiscriminator(nominalType, actualType)
          if MongoDBBson.BsonValue.op_Inequality(discriminator, nil) then
            context:getWriter():WriteName(discriminatorConvention:getElementName())
            MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize1(MongoDBSerializers.BsonValueSerializer.getInstance(), context, discriminator, MongoDBBson.BsonValue)
          end
        end
      end
      SerializeMember = function (this, context, obj, memberMap)
        if memberMap ~= this._classMap:getExtraElementsMemberMap() then
          SerializeNormalMember(this, context, obj, memberMap)
        else
          SerializeExtraElements(this, context, obj, memberMap)
        end
      end
      SerializeNormalMember = function (this, context, obj, memberMap)
        local bsonWriter = context:getWriter()

        local value = memberMap:getGetter()(obj)

        if not memberMap:ShouldSerialize(obj, value) then
          return
          -- don't serialize member
        end

        bsonWriter:WriteName(memberMap:getElementName())
        MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize(memberMap:GetSerializer(), context, value)
      end
      ShouldSerializeDiscriminator = function (this, nominalType)
        return (nominalType ~= this._classMap:getClassType() or this._classMap:getDiscriminatorIsRequired() or this._classMap:getHasRootClass()) and not this._classMap:getIsAnonymous()
      end
      return {
        base = function (out)
          return {
            out.MongoDB.Bson.Serialization.Serializers.SerializerBase_1(TClass),
            out.MongoDB.Bson.Serialization.IBsonIdProvider,
            out.MongoDB.Bson.Serialization.IBsonDocumentSerializer,
            out.MongoDB.Bson.Serialization.IBsonPolymorphicSerializer
          }
        end,
        getIsDiscriminatorCompatibleWithObjectSerializer = getIsDiscriminatorCompatibleWithObjectSerializer,
        Deserialize = Deserialize,
        DeserializeClass = DeserializeClass,
        GetDocumentId = GetDocumentId,
        TryGetMemberSerializationInfo = TryGetMemberSerializationInfo,
        Serialize = Serialize,
        SetDocumentId = SetDocumentId,
        __ctor__ = __ctor__
      }
    end
  end)
end)
