-- Generated by CSharp.lua Compiler
--[[ Copyright 2016-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local SystemGlobalization = System.Globalization
local SystemRegularExpressions = System.Text.RegularExpressions
local MongoDBBson
local MongoDBBsonIO
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
end)
System.namespace("MongoDB.Bson", function (namespace)
  -- <summary>
  -- Represents a Decimal128 value.
  -- </summary>
  namespace.struct("Decimal128", function (namespace)
    local __maxSignificand, __maxDecimalValue, __minDecimalValue, __maxValue, __minValue, getMaxValue, getMinValue, getNegativeInfinity, 
    getOne, getPositiveInfinity, getQNaN, getSNaN, getZero, op_Equality, op_Inequality, op_GreaterThan, 
    op_GreaterThanOrEqual, op_LessThan, op_LessThanOrEqual, op_Explicit, op_Explicit1, op_Explicit2, op_Implicit, op_Implicit1, 
    op_Explicit3, op_Explicit4, op_Implicit2, op_Implicit3, op_Implicit4, op_Implicit5, op_Implicit6, op_Implicit7, 
    op_Implicit8, op_Explicit5, op_Explicit6, op_Explicit7, op_Explicit8, op_Explicit9, op_Explicit10, op_Explicit11, 
    op_Explicit12, op_Explicit13, Compare, Equals1, FromComponents, FromIEEEBits, GetExponent, GetSignificandHighBits, 
    GetSignificandLowBits, IsInfinity, IsNaN, IsNegative, IsNegativeInfinity, IsPositiveInfinity, IsQNaN, IsSNaN, 
    IsZero, Negate, Parse, ToByte1, ToDecimal1, ToDouble1, ToInt161, ToInt321, 
    ToInt641, ToSByte1, ToSingle1, ToUInt161, ToUInt321, ToUInt641, TryParse, ClampOrRound, 
    TryDecreaseExponent, FromComponents1, GetSignificand, TryIncreaseExponent, MapDecimal128BiasedExponentToExponent, MapDecimal128HighBitsToIEEEHighBits, MapExponentToDecimal128BiasedExponent, MapIEEEHighBitsToDecimal128HighBits, 
    RemoveLeadingZeroes, CompareTo, Equals, EqualsObj, GetHashCode, GetIEEEHighBits, GetIEEELowBits, ToString, 
    GetTypeCode, ToBoolean, ToByte, ToChar, ToDateTime, ToDecimal, ToDouble, ToInt16, 
    ToInt32, ToInt64, ToSByte, ToSingle, ToString1, ToType, ToUInt16, ToUInt32, 
    ToUInt64, ToStringWithExponentialNotation, ToStringWithoutExponentialNotation, TryTruncateToUInt64, class, static, __ctor1__, __ctor2__, 
    __ctor3__, __ctor4__, __ctor5__, __ctor6__, __ctor7__, __ctor8__
    namespace.class("Decimal128Comparer", function (namespace)
      local __instance, getInstance, Compare, GetDecimal128Type, CompareNumbers, GetNumberClass, CompareNegativeNumbers, ComparePositiveNumbers, 
      class, static
      static = function (this)
        __instance = class()
      end
      getInstance = function ()
        return __instance
      end
      Compare = function (this, x, y)
        local xType = GetDecimal128Type(this, x:__clone__())
        local yType = GetDecimal128Type(this, y:__clone__())
        local result = xType:CompareToObj(yType)
        if result == 0 and xType == 2 --[[Decimal128Type.Number]] then
          return CompareNumbers(this, x:__clone__(), y:__clone__())
        else
          return result
        end
      end
      GetDecimal128Type = function (this, x)
        if IsNaN(x:__clone__()) then
          return 0 --[[Decimal128Type.NaN]]
        elseif IsNegativeInfinity(x:__clone__()) then
          return 1 --[[Decimal128Type.NegativeInfinity]]
        elseif IsPositiveInfinity(x:__clone__()) then
          return 3 --[[Decimal128Type.PositiveInfity]]
        else
          return 2 --[[Decimal128Type.Number]]
        end
      end
      CompareNumbers = function (this, x, y)
        local xClass = GetNumberClass(this, x:__clone__())
        local yClass = GetNumberClass(this, y:__clone__())
        local result = xClass:CompareToObj(yClass)
        if result == 0 then
          if xClass == 0 --[[NumberClass.Negative]] then
            return CompareNegativeNumbers(this, x:__clone__(), y:__clone__())
          elseif xClass == 2 --[[NumberClass.Positive]] then
            return ComparePositiveNumbers(this, x:__clone__(), y:__clone__())
          else
            return 0
            -- else all Zeroes compare equal
          end
        else
          return result
        end
      end
      GetNumberClass = function (this, x)
        if IsZero(x:__clone__()) then
          return 1 --[[NumberClass.Zero]]
        elseif IsNegative(x:__clone__()) then
          return 0 --[[NumberClass.Negative]]
        else
          return 2 --[[NumberClass.Positive]]
        end
      end
      CompareNegativeNumbers = function (this, x, y)
        return - ComparePositiveNumbers(this, Negate(x:__clone__()), Negate(y:__clone__()))
      end
      ComparePositiveNumbers = function (this, x, y)
        local xExponent = GetExponent(x:__clone__())
        local xSignificand = GetSignificand(x:__clone__())
        local yExponent = GetExponent(y:__clone__())
        local ySignificand = GetSignificand(y:__clone__())

        local exponentDifference = math.Abs(xExponent - yExponent)
        if exponentDifference <= 66 then
          -- we may or may not be able to make the exponents equal but we won't know until we try
          -- but we do know we can't eliminate an exponent difference larger than 66
          if xExponent < yExponent then
            xSignificand, xExponent = TryIncreaseExponent(xSignificand, xExponent, yExponent)
            ySignificand, yExponent = TryDecreaseExponent(ySignificand, yExponent, xExponent)
          elseif xExponent > yExponent then
            xSignificand, xExponent = TryDecreaseExponent(xSignificand, xExponent, yExponent)
            ySignificand, yExponent = TryIncreaseExponent(ySignificand, yExponent, xExponent)
          end
        end

        if xExponent == yExponent then
          return xSignificand:CompareTo(ySignificand:__clone__())
        else
          return xExponent:CompareTo(yExponent)
        end
      end
      class = {
        base = function (out)
          return {
            System.IComparer_1(out.MongoDB.Bson.Decimal128)
          }
        end,
        getInstance = getInstance,
        Compare = Compare,
        static = static
      }
      return class
    end)
    namespace.class("Flags", function (namespace)
      local IsFirstForm, IsInfinity, IsNaN, IsNegative, IsNegativeInfinity, IsPositiveInfinity, IsQNaN, IsSecondForm, 
      IsSNaN
      IsFirstForm = function (highBits)
        return (System.band(highBits, 6917529027641081856 --[[Flags.FirstFormLeadingBits]])) <= 4611686018427387904 --[[Flags.FirstFormLeadingBitsMax]]
      end
      IsInfinity = function (highBits)
        return (System.band(highBits, 8935141660703064064 --[[Flags.InfinityBits]])) == 8646911284551352320 --[[Flags.Infinity]]
      end
      IsNaN = function (highBits)
        return (System.band(highBits, 8935141660703064064 --[[Flags.PartialNaNBits]])) == 8935141660703064064 --[[Flags.PartialNaN]]
      end
      IsNegative = function (highBits)
        return (System.band(highBits, 9223372036854775808 --[[Flags.SignBit]])) ~= 0
      end
      IsNegativeInfinity = function (highBits)
        return (System.band(highBits, 18158513697557839872 --[[Flags.SignedInfinityBits]])) == 17870283321406128128 --[[Flags.NegativeInfinity]]
      end
      IsPositiveInfinity = function (highBits)
        return (System.band(highBits, 18158513697557839872 --[[Flags.SignedInfinityBits]])) == 8646911284551352320 --[[Flags.PositiveInfinity]]
      end
      IsQNaN = function (highBits)
        return (System.band(highBits, 9079256848778919936 --[[Flags.NaNBits]])) == 8935141660703064064 --[[Flags.QNaN]]
      end
      IsSecondForm = function (highBits)
        local secondFormLeadingBits = System.band(highBits, 8646911284551352320 --[[Flags.SecondFormLeadingBits]])
        return secondFormLeadingBits >= 6917529027641081856 --[[Flags.SecondFormLeadingBitsMin]] and secondFormLeadingBits <= 8070450532247928832 --[[Flags.SecondFormLeadingBitsMax]]
      end
      IsSNaN = function (highBits)
        return (System.band(highBits, 9079256848778919936 --[[Flags.NaNBits]])) == 9079256848778919936 --[[Flags.SNaN]]
      end
      return {
        IsFirstForm = IsFirstForm,
        IsInfinity = IsInfinity,
        IsNaN = IsNaN,
        IsNegative = IsNegative,
        IsNegativeInfinity = IsNegativeInfinity,
        IsPositiveInfinity = IsPositiveInfinity,
        IsQNaN = IsQNaN,
        IsSecondForm = IsSecondForm,
        IsSNaN = IsSNaN
      }
    end)
    static = function (this)
      __maxSignificand = MongoDBBson.UInt128.Parse("9999999999999999999999999999999999")
      __maxDecimalValue = Parse("79228162514264337593543950335")
      __minDecimalValue = Parse("-79228162514264337593543950335")
      __maxValue = Parse("9999999999999999999999999999999999E+6111")
      __minValue = Parse("-9999999999999999999999999999999999E+6111")
    end
    __ctor1__ = function (this, highBits, lowBits)
      if highBits == nil then
        return
      end
      this._highBits = highBits
      this._lowBits = lowBits
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor2__ = function (this, value)
      local bits = System.Double.GetBits(value)
      local isNegative = (System.band(bits:get(3), 0x80000000)) ~= 0
      local scale = System.toInt16(System.sr((System.band(bits:get(3), 0x00FF0000)), 16))
      local exponent = System.toInt16(- scale)
      local significandHigh = System.toUInt32(bits:get(2))
      local significandLow = System.bor((System.sl(System.toUInt32(bits:get(1)), 32)), System.toUInt32(bits:get(0)))

      this._highBits = System.bor(System.bor((isNegative and 9223372036854775808 --[[Flags.SignBit]] or 0), (System.sl(MapExponentToDecimal128BiasedExponent(exponent), 49))), significandHigh)
      this._lowBits = significandLow
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor3__ = function (this, value)
      -- TODO: implement this more efficiently
      local stringValue = MongoDBBsonIO.JsonConvert.ToString5(value)
      local decimal128Value = Parse(stringValue)
      this._highBits = MapIEEEHighBitsToDecimal128HighBits(GetIEEEHighBits(decimal128Value))
      this._lowBits = GetIEEELowBits(decimal128Value)
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor4__ = function (this, value)
      -- TODO: implement this more efficiently
      local stringValue = MongoDBBsonIO.JsonConvert.ToString6(value)
      local decimal128Value = Parse(stringValue)
      this._highBits = MapIEEEHighBitsToDecimal128HighBits(GetIEEEHighBits(decimal128Value))
      this._lowBits = GetIEEELowBits(decimal128Value)
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor5__ = function (this, value)
      if value >= 0 then
        this._highBits = 0
        this._lowBits = value
      else
        this._highBits = 9223372036854775808 --[[Flags.SignBit]]
        this._lowBits = (value == -2147483648 --[[Int32.MinValue]]) and 2147483648 --[[(ulong)int.MaxValue + 1]] or - value
      end
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor6__ = function (this, value)
      if value >= 0 then
        this._highBits = 0
        this._lowBits = System.toUInt64(value)
      else
        this._highBits = 9223372036854775808 --[[Flags.SignBit]]
        this._lowBits = (value == -9223372036854775808 --[[Int64.MinValue]]) and 9223372036854775808 --[[(ulong)long.MaxValue + 1]] or System.toUInt64(- value)
      end
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor7__ = function (this, value)
      this._highBits = 0
      this._lowBits = value
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="Decimal128"/> struct.
    -- </summary>
    __ctor8__ = function (this, value)
      this._highBits = 0
      this._lowBits = value
    end
    getMaxValue = function ()
      return __maxValue
    end
    getMinValue = function ()
      return __minValue
    end
    getNegativeInfinity = function ()
      return class(17870283321406128128 --[[Flags.NegativeInfinity]], 0)
    end
    getOne = function ()
      return class(0, 1)
    end
    getPositiveInfinity = function ()
      return class(8646911284551352320 --[[Flags.PositiveInfinity]], 0)
    end
    getQNaN = function ()
      return class(8935141660703064064 --[[Flags.QNaN]], 0)
    end
    getSNaN = function ()
      return class(9079256848778919936 --[[Flags.SNaN]], 0)
    end
    getZero = function ()
      return class(0, 0)
    end
    -- <summary>
    -- Implements the operator ==.
    -- </summary>
    -- <param name="rhs">The RHS.</param>
    -- <returns>
    -- The result of the operator.
    -- </returns>
    op_Equality = function (lhs, rhs)
      if IsNaN(lhs:__clone__()) or IsNaN(rhs:__clone__()) then
        return false
      else
        return Equals(lhs, rhs:__clone__())
      end
    end
    -- <summary>
    -- Implements the operator !=.
    -- </summary>
    -- <param name="rhs">The RHS.</param>
    -- <returns>
    -- The result of the operator.
    -- </returns>
    op_Inequality = function (lhs, rhs)
      return not (op_Equality(lhs, rhs))
    end
    -- <summary>
    -- Returns a value indicating whether a specified Decimal128 is greater than another specified Decimal128.
    -- </summary>
    -- <param name="y">The second value.</param>
    -- <returns>
    -- true if x &gt; y; otherwise, false.
    -- </returns>
    op_GreaterThan = function (x, y)
      return Compare(x:__clone__(), y:__clone__()) > 0
    end
    -- <summary>
    -- Returns a value indicating whether a specified Decimal128 is greater than or equal to another another specified Decimal128.
    -- </summary>
    -- <param name="y">The second value.</param>
    -- <returns>
    -- true if x &gt;= y; otherwise, false.
    -- </returns>
    op_GreaterThanOrEqual = function (x, y)
      return Compare(x:__clone__(), y:__clone__()) >= 0
    end
    -- <summary>
    -- Returns a value indicating whether a specified Decimal128 is less than another specified Decimal128.
    -- </summary>
    -- <param name="y">The second value.</param>
    -- <returns>
    -- true if x &lt; y; otherwise, false.
    -- </returns>
    op_LessThan = function (x, y)
      return Compare(x:__clone__(), y:__clone__()) < 0
    end
    -- <summary>
    -- Returns a value indicating whether a specified Decimal128 is less than or equal to another another specified Decimal128.
    -- </summary>
    -- <param name="y">The second value.</param>
    -- <returns>
    -- true if x &lt;= y; otherwise, false.
    -- </returns>
    op_LessThanOrEqual = function (x, y)
      return Compare(x:__clone__(), y:__clone__()) <= 0
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.Byte"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit = function (value)
      return ToByte1(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="char"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit1 = function (value)
      return System.toUInt16(ToUInt161(value:__clone__()))
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.Decimal"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit2 = function (value)
      return ToDecimal1(value:__clone__())
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.Byte"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit = function (value)
      return System.new(class, 5, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.Decimal"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit1 = function (value)
      return System.new(class, 2, value)
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="double"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit3 = function (value)
      return System.new(class, 3, value)
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="float"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit4 = function (value)
      return System.new(class, 4, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.Int32"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit2 = function (value)
      return System.new(class, 5, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.Int64"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit3 = function (value)
      return System.new(class, 6, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.SByte"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit4 = function (value)
      return System.new(class, 5, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.Int16"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit5 = function (value)
      return System.new(class, 5, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.UInt32"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit6 = function (value)
      return System.new(class, 7, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.UInt16"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit7 = function (value)
      return System.new(class, 5, value)
    end
    -- <summary>
    -- Performs an implicit conversion from <see cref="System.UInt64"/> to <see cref="Decimal128"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Implicit8 = function (value)
      return System.new(class, 8, value)
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="double"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit5 = function (value)
      return ToDouble1(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="float"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit6 = function (value)
      return ToSingle1(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.Int32"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit7 = function (value)
      return ToInt321(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.Int64"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit8 = function (value)
      return ToInt641(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.SByte"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit9 = function (value)
      return ToSByte1(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.Int16"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit10 = function (value)
      return ToInt161(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.UInt32"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit11 = function (value)
      return ToUInt321(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.UInt64"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit12 = function (value)
      return ToUInt641(value:__clone__())
    end
    -- <summary>
    -- Performs an explicit conversion from <see cref="Decimal128"/> to <see cref="System.UInt16"/>.
    -- </summary>
    -- <returns>
    -- The result of the conversion.
    -- </returns>
    op_Explicit13 = function (value)
      return ToUInt161(value:__clone__())
    end
    -- <summary>
    -- Compares two specified Decimal128 values and returns an integer that indicates whether the first value
    -- is greater than, less than, or equal to the second value.
    -- </summary>
    -- <param name="y">The second value.</param>
    -- <returns>Less than zero if x &lt; y, zero if x == y, and greater than zero if x &gt; y.</returns>
    Compare = function (x, y)
      return class.Decimal128Comparer.getInstance():Compare(x:__clone__(), y:__clone__())
    end
    -- <summary>
    -- Determines whether the specified Decimal128 instances are considered equal.
    -- </summary>
    -- <param name="y">The second Decimal128 object to compare.</param>
    -- <returns>True if the objects are considered equal; otherwise false. If both x and y are null, the method returns true.</returns>
    Equals1 = function (x, y)
      return Compare(x:__clone__(), y:__clone__()) == 0
    end
    -- <summary>
    -- Creates a new Decimal128 value from its components.
    -- </summary>
    -- <param name="exponent">The exponent.</param>
    -- <param name="significandHighBits">The signficand high bits.</param>
    -- <param name="significandLowBits">The significand low bits.</param>
    -- <returns>A Decimal128 value.</returns>
    FromComponents = function (isNegative, exponent, significandHighBits, significandLowBits)
      return FromComponents1(isNegative, exponent, System.new(MongoDBBson.UInt128, 2, significandHighBits, significandLowBits))
    end
    -- <summary>
    -- Creates a new Decimal128 value from the IEEE encoding bits.
    -- </summary>
    -- <param name="lowBits">The low bits.</param>
    -- <returns>A Decimal128 value.</returns>
    FromIEEEBits = function (highBits, lowBits)
      return class(MapIEEEHighBitsToDecimal128HighBits(highBits), lowBits)
    end
    -- <summary>
    -- Gets the exponent of a Decimal128 value.
    -- </summary>
    -- <returns>The exponent.</returns>
    GetExponent = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        return MapDecimal128BiasedExponentToExponent(System.toInt16(System.sr((System.band(d._highBits, 9222809086901354496 --[[Flags.FirstFormExponentBits]])), 49)))
      elseif class.Flags.IsSecondForm(d._highBits) then
        return MapDecimal128BiasedExponentToExponent(System.toInt16(System.sr((System.band(d._highBits, 2305702271725338624 --[[Flags.SecondFormExponentBits]])), 47)))
      else
        System.throw(System.InvalidOperationException("GetExponent cannot be called for Infinity or NaN."))
      end
    end
    -- <summary>
    -- Gets the high bits of the significand of a Decimal128 value.
    -- </summary>
    -- <returns>The high bits of the significand.</returns>
    GetSignificandHighBits = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        return System.band(d._highBits, 562949953421311 --[[Flags.FirstFormSignificandBits]])
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.InvalidOperationException("GetSignificandHighBits cannot be called for Infinity or NaN."))
      end
    end
    -- <summary>
    -- Gets the high bits of the significand of a Decimal128 value.
    -- </summary>
    -- <returns>The high bits of the significand.</returns>
    GetSignificandLowBits = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        return d._lowBits
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.InvalidOperationException("GetSignificandLowBits cannot be called for Infinity or NaN."))
      end
    end
    -- <summary>
    -- Returns a value indicating whether the specified number evaluates to negative or positive infinity.
    -- </summary>
    -- <returns>true if <paramref name="d" /> evaluates to negative or positive infinity; otherwise, false.</returns>
    IsInfinity = function (d)
      return class.Flags.IsInfinity(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number is not a number.
    -- </summary>
    -- <returns>true if <paramref name="d" /> is not a number; otherwise, false.</returns>
    IsNaN = function (d)
      return class.Flags.IsNaN(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number is negative.
    -- </summary>
    -- <returns>true if <paramref name="d" /> is negative; otherwise, false.</returns>
    IsNegative = function (d)
      return class.Flags.IsNegative(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number evaluates to negative infinity.
    -- </summary>
    -- <returns>true if <paramref name="d" /> evaluates to negative infinity; otherwise, false.</returns>
    IsNegativeInfinity = function (d)
      return class.Flags.IsNegativeInfinity(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number evaluates to positive infinity.
    -- </summary>
    -- <returns>true if <paramref name="d" /> evaluates to positive infinity; otherwise, false.</returns>
    IsPositiveInfinity = function (d)
      return class.Flags.IsPositiveInfinity(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number is a quiet not a number.
    -- </summary>
    -- <returns>true if <paramref name="d" /> is a quiet not a number; otherwise, false.</returns>
    IsQNaN = function (d)
      return class.Flags.IsQNaN(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number is a signaled not a number.
    -- </summary>
    -- <returns>true if <paramref name="d" /> is a signaled not a number; otherwise, false.</returns>
    IsSNaN = function (d)
      return class.Flags.IsSNaN(d._highBits)
    end
    -- <summary>
    -- Returns a value indicating whether the specified number is zero.
    -- </summary>
    -- <returns>
    -- <c>true</c> if the specified number is zero; otherwise, <c>false</c>.
    -- </returns>
    IsZero = function (d)
      if class.Flags.IsFirstForm(d._highBits) and GetSignificand(d:__clone__()):Equals(MongoDBBson.UInt128.getZero()) then
        return true
      elseif class.Flags.IsSecondForm(d._highBits) then
        -- all second form values are invalid representations and are interpreted as zero
        return true
      else
        return false
      end
    end
    -- <summary>
    -- Negates the specified x.
    -- </summary>
    -- <returns>The result of multiplying the value by negative one.</returns>
    Negate = function (x)
      return class(System.xor(x._highBits, 9223372036854775808 --[[Flags.SignBit]]), x._lowBits)
    end
    -- <summary>
    -- Converts the string representation of a number to its <see cref="Decimal128" /> equivalent.
    -- </summary>
    -- <returns>
    -- The equivalent to the number contained in <paramref name="s" />.
    -- </returns>
    Parse = function (s)
      local value
      local default
      default, value = TryParse(s)
      if not default then
        System.throw(System.FormatException(s .. " is not a valid Decimal128."))
      end

      return value:__clone__()
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 8-bit unsigned integer.
    -- </summary>
    -- <returns>A 8-bit unsigned integer equivalent to <paramref name="d" />.</returns>
    ToByte1 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), 0, 255 --[[Byte.MaxValue]])
        if default then
          return System.toByte(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to a Byte."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to a Byte."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent <see cref="decimal"/>.
    -- </summary>
    -- <returns>A <see cref="decimal"/> equivalent to <paramref name="d" />.</returns>
    ToDecimal1 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        if IsZero(d:__clone__()) then
          return 0 --[[Decimal.Zero]]
        elseif Compare(d:__clone__(), __minDecimalValue:__clone__()) < 0 or Compare(d:__clone__(), __maxDecimalValue:__clone__()) > 0 then
          System.throw(System.OverflowException("Value is too large or too small to be converted to a Decimal."))
        end

        local isNegative = IsNegative(d:__clone__())
        local exponent = GetExponent(d:__clone__())
        local significand = GetSignificand(d:__clone__())

        -- decimal significand must fit in 96 bits
        while (System.sr(significand:getHigh(), 32)) ~= 0 do
          local remainder
          -- ignored
          local default
          default, remainder = MongoDBBson.UInt128.Divide(significand:__clone__(), 10)
          significand = default
          exponent = exponent + 1
        end

        -- decimal exponents must be between 0 and -28
        if exponent > 0 then
          -- bring exponent within range
          while exponent > 0 do
            significand = MongoDBBson.UInt128.Multiply(significand:__clone__(), 10 --[[(uint)10]])
            exponent = exponent - 1
          end
        elseif exponent < - 28 then
          -- check if exponent is too far out of range to possibly be brought within range
          if exponent < - 56 then
            return 0 --[[Decimal.Zero]]
          end

          -- bring exponent within range
          while exponent < - 28 do
            local remainder
            -- ignored
            local default
            default, remainder = MongoDBBson.UInt128.Divide(significand:__clone__(), 10 --[[(uint)10]])
            significand = default
            exponent = exponent + 1
          end

          if significand:Equals(MongoDBBson.UInt128.getZero()) then
            return 0 --[[Decimal.Zero]]
          end
        end

        local lo = System.toInt32(significand:getLow())
        local mid = System.toInt32(System.sr(significand:getLow(), 32))
        local hi = System.toInt32(significand:getHigh())
        local scale = System.toByte(- exponent)

        return System.Double(lo, mid, hi, isNegative, scale)
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0 --[[Decimal.Zero]]
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to Decimal."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent <see cref="double"/>.
    -- </summary>
    -- <returns>A <see cref="double"/> equivalent to <paramref name="d" />.</returns>
    ToDouble1 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        -- TODO: implement this more efficiently
        local stringValue = ToString(d)
        return System.Double.Parse(stringValue)
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0.0
      elseif class.Flags.IsPositiveInfinity(d._highBits) then
        return System.Double.PositiveInfinity
      elseif class.Flags.IsNegativeInfinity(d._highBits) then
        return System.Double.NegativeInfinity
      else
        return System.Double.NaN
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 16-bit signed integer.
    -- </summary>
    -- <returns>A 16-bit signed integer equivalent to <paramref name="d" />.</returns>
    ToInt161 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local maxNegativeValue = 32768 --[[(ulong)short.MaxValue + 1]]
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), maxNegativeValue, 32767 --[[(ulong)short.MaxValue]])
        if default then
          return IsNegative(d:__clone__()) and ((value == maxNegativeValue) and -32768 --[[Int16.MinValue]] or System.toInt16(- System.toInt16(value))) or System.toInt16(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to an Int16."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to an Int16."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 32-bit signed integer.
    -- </summary>
    -- <returns>A 32-bit signed integer equivalent to <paramref name="d" />.</returns>
    ToInt321 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local maxNegativeValue = 2147483648 --[[(ulong)int.MaxValue + 1]]
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), maxNegativeValue, 2147483647 --[[Int32.MaxValue]])
        if default then
          return IsNegative(d:__clone__()) and ((value == maxNegativeValue) and -2147483648 --[[Int32.MinValue]] or - System.toInt32(value)) or System.toInt32(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to an Int32."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to an Int32."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 64-bit signed integer.
    -- </summary>
    -- <returns>A 64-bit signed integer equivalent to <paramref name="d" />.</returns>
    ToInt641 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local maxNegativeValue = 9223372036854775808 --[[(ulong)long.MaxValue + 1]]
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), maxNegativeValue, 9223372036854775807 --[[Int64.MaxValue]])
        if default then
          return IsNegative(d:__clone__()) and ((value == maxNegativeValue) and -9223372036854775808 --[[Int64.MinValue]] or - System.toInt64(value)) or System.toInt64(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to an Int64."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to an Int64."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 8-bit signed integer.
    -- </summary>
    -- <returns>A 8-bit signed integer equivalent to <paramref name="d" />.</returns>
    ToSByte1 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local maxNegativeValue = 128 --[[(ulong)sbyte.MaxValue + 1]]
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), maxNegativeValue, 127 --[[(ulong)sbyte.MaxValue]])
        if default then
          return IsNegative(d:__clone__()) and ((value == maxNegativeValue) and -128 --[[SByte.MinValue]] or System.toSByte(- System.toSByte(value))) or System.toSByte(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to an SByte."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to an SByte."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent <see cref="float"/>.
    -- </summary>
    -- <returns>A <see cref="float"/> equivalent to <paramref name="d" />.</returns>
    ToSingle1 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        -- TODO: implement this more efficiently
        local stringValue = ToString(d)
        return System.Single.Parse(stringValue)
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0 --[[(float)0.0]]
      elseif class.Flags.IsPositiveInfinity(d._highBits) then
        return System.Single.PositiveInfinity
      elseif class.Flags.IsNegativeInfinity(d._highBits) then
        return System.Single.NegativeInfinity
      else
        return System.Single.NaN
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 16-bit unsigned integer.
    -- </summary>
    -- <returns>A 16-bit unsigned integer equivalent to <paramref name="d" />.</returns>
    ToUInt161 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), 0, 65535 --[[UInt16.MaxValue]])
        if default then
          return System.toUInt16(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to a UInt16."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to a UInt16."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 32-bit unsigned integer.
    -- </summary>
    -- <returns>A 32-bit unsigned integer equivalent to <paramref name="d" />.</returns>
    ToUInt321 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), 0, 4294967295 --[[UInt32.MaxValue]])
        if default then
          return System.toUInt32(value)
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to a UInt32."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to a UInt32."))
      end
    end
    -- <summary>
    -- Converts the value of the specified <see cref="Decimal128"/> to the equivalent 64-bit unsigned integer.
    -- </summary>
    -- <returns>A 64-bit unsigned integer equivalent to <paramref name="d" />.</returns>
    ToUInt641 = function (d)
      if class.Flags.IsFirstForm(d._highBits) then
        local value
        local default
        default, value = TryTruncateToUInt64(d:__clone__(), 0, 18446744073709551615 --[[UInt64.MaxValue]])
        if default then
          return value
        else
          System.throw(System.OverflowException("Value is too large or too small to be converted to a UInt64."))
        end
      elseif class.Flags.IsSecondForm(d._highBits) then
        return 0
      else
        System.throw(System.OverflowException("Infinity or NaN cannot be converted to a UInt64."))
      end
    end
    -- <summary>
    -- Converts the string representation of a number to its <see cref="Decimal128" /> equivalent. A return value indicates whether the conversion succeeded or failed.
    -- </summary>
    -- <param name="result">When this method returns, contains the <see cref="Decimal128" /> number that is equivalent to the numeric value contained in <paramref name="s" />, if the conversion succeeded, or is zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is null, is not a number in a valid format, or represents a number less than the min value or greater than the max value. This parameter is passed uninitialized.</param>
    -- <returns>
    -- true if <paramref name="s" /> was converted successfully; otherwise, false.
    -- </returns>
    TryParse = function (s, result)
      if s == nil or #s == 0 then
        result = System.default(class)
        return false, result
      end


      local match = SystemRegularExpressions.Regex.Match(s, pattern)
      if not match:getSuccess() then
        if s:Equals("Inf", 5 --[[StringComparison.OrdinalIgnoreCase]]) or s:Equals("Infinity", 5 --[[StringComparison.OrdinalIgnoreCase]]) or s:Equals("+Inf", 5 --[[StringComparison.OrdinalIgnoreCase]]) or s:Equals("+Infinity", 5 --[[StringComparison.OrdinalIgnoreCase]]) then
          result = getPositiveInfinity()
          return true, result
        end

        if s:Equals("-Inf", 5 --[[StringComparison.OrdinalIgnoreCase]]) or s:Equals("-Infinity", 5 --[[StringComparison.OrdinalIgnoreCase]]) then
          result = getNegativeInfinity()
          return true, result
        end

        if s:Equals("NaN", 5 --[[StringComparison.OrdinalIgnoreCase]]) or s:Equals("-NaN", 5 --[[StringComparison.OrdinalIgnoreCase]]) then
          result = getQNaN()
          return true, result
        end

        result = System.default(class)
        return false, result
      end

      local isNegative = match:getGroups():get("sign"):getValue() == "-"

      local exponent = 0
      if match:getGroups():get("exponent"):getLength() ~= 0 then
        local default
        default, exponent = System.Int32.TryParse(match:getGroups():get("exponentDigits"):getValue(), nil)
        if not default then
          result = System.default(class)
          return false, result
        end
        if match:getGroups():get("exponentSign"):getValue() == "-" then
          exponent = - exponent
        end
      end

      local significandString = match:getGroups():get("significand"):getValue()

      local decimalPointIndex
      decimalPointIndex = significandString:IndexOf(46 --[['.']])
      if decimalPointIndex ~= - 1 then
        exponent = exponent - (#significandString - (decimalPointIndex + 1))
        significandString = significandString:Substring(0, decimalPointIndex) .. significandString:Substring(decimalPointIndex + 1)
      end

      significandString = RemoveLeadingZeroes(significandString)
      local default
      default, exponent = ClampOrRound(exponent, significandString)
      significandString = default

      if exponent > 6111 --[[Decimal128.__exponentMax]] or exponent < -6176 --[[Decimal128.__exponentMin]] then
        result = System.default(class)
        return false, result
      end
      if #significandString > 34 then
        result = System.default(class)
        return false, result
      end

      local significand = MongoDBBson.UInt128.Parse(significandString)

      result = FromComponents1(isNegative, System.toInt16(exponent), significand:__clone__())
      return true, result
    end
    ClampOrRound = function (exponent, significandString)
      if exponent > 6111 --[[Decimal128.__exponentMax]] then
        if significandString == "0" then
          -- since significand is zero simply use the largest possible exponent
          exponent = 6111 --[[Decimal128.__exponentMax]]
        else
          -- use clamping to bring the exponent into range
          local numberOfTrailingZeroesToAdd = exponent - 6111 --[[Decimal128.__exponentMax]]
          local digitsAvailable = 34 - #significandString
          if numberOfTrailingZeroesToAdd <= digitsAvailable then
            exponent = 6111 --[[Decimal128.__exponentMax]]
            significandString = significandString .. System.String(48 --[['0']], numberOfTrailingZeroesToAdd)
          end
        end
      elseif exponent < -6176 --[[Decimal128.__exponentMin]] then
        if significandString == "0" then
          -- since significand is zero simply use the smallest possible exponent
          exponent = -6176 --[[Decimal128.__exponentMin]]
        else
          -- use exact rounding to bring the exponent into range
          local numberOfTrailingZeroesToRemove = -6176 --[[Decimal128.__exponentMin]] - exponent
          if numberOfTrailingZeroesToRemove < #significandString then
            local trailingDigits = significandString:Substring(#significandString - numberOfTrailingZeroesToRemove)
            if SystemRegularExpressions.Regex.IsMatch(trailingDigits, "^0+$") then
              exponent = -6176 --[[Decimal128.__exponentMin]]
              significandString = significandString:Substring(0, #significandString - numberOfTrailingZeroesToRemove)
            end
          end
        end
      elseif #significandString > 34 then
        -- use exact rounding to reduce significand to 34 digits
        local numberOfTrailingZeroesToRemove = #significandString - 34
        if exponent + numberOfTrailingZeroesToRemove <= 6111 --[[Decimal128.__exponentMax]] then
          local trailingDigits = significandString:Substring(#significandString - numberOfTrailingZeroesToRemove)
          if SystemRegularExpressions.Regex.IsMatch(trailingDigits, "^0+$") then
            exponent = exponent + numberOfTrailingZeroesToRemove
            significandString = significandString:Substring(0, #significandString - numberOfTrailingZeroesToRemove)
          end
        end
      end

      return significandString, exponent
    end
    TryDecreaseExponent = function (significand, exponent, goal)
      if significand:Equals(MongoDBBson.UInt128.getZero()) then
        exponent = goal
        return significand, exponent
      end

      while exponent > goal do
        local significandTimes10 = MongoDBBson.UInt128.Multiply(significand:__clone__(), 10 --[[(uint)10]])
        if significandTimes10:CompareTo(__maxSignificand) > 0 then
          break
        end
        exponent = exponent - 1
        significand = significandTimes10:__clone__()
      end
      return significand, exponent
    end
    FromComponents1 = function (isNegative, exponent, significand)
      if exponent < -6176 --[[Decimal128.__exponentMin]] or exponent > 6111 --[[Decimal128.__exponentMax]] then
        System.throw(System.ArgumentOutOfRangeException("exponent" --[[nameof(exponent)]]))
      end
      if significand:CompareTo(__maxSignificand:__clone__()) > 0 then
        System.throw(System.ArgumentOutOfRangeException("significand" --[[nameof(significand)]]))
      end

      local biasedExponent = MapExponentToDecimal128BiasedExponent(exponent)
      local highBits = System.bor((System.sl(biasedExponent, 49)), significand:getHigh())
      if isNegative then
        highBits = System.bor(9223372036854775808 --[[Flags.SignBit]], highBits)
      end

      return class(highBits, significand:getLow())
    end
    GetSignificand = function (d)
      return System.new(MongoDBBson.UInt128, 2, GetSignificandHighBits(d:__clone__()), GetSignificandLowBits(d:__clone__()))
    end
    TryIncreaseExponent = function (significand, exponent, goal)
      if significand:Equals(MongoDBBson.UInt128.getZero()) then
        exponent = goal
        return significand, exponent
      end

      while exponent < goal do
        local remainder
        local default
        default, remainder = MongoDBBson.UInt128.Divide(significand:__clone__(), 10 --[[(uint)10]])
        local significandDividedBy10 = default
        if remainder ~= 0 then
          break
        end
        exponent = exponent + 1
        significand = significandDividedBy10:__clone__()
      end
      return significand, exponent
    end
    MapDecimal128BiasedExponentToExponent = function (biasedExponent)
      if biasedExponent <= 6111 then
        return biasedExponent
      else
        return System.toInt16(biasedExponent - 12288)
      end
    end
    MapDecimal128HighBitsToIEEEHighBits = function (highBits)
      -- for Decimal128Bias from    0 to  6111: IEEEBias = Decimal128Bias + 6176
      -- for Decimal128Bias from 6112 to 12287: IEEEBias = Decimal128Bias - 6112

      if class.Flags.IsFirstForm(highBits) then
        local exponentBits = System.band(highBits, 9222809086901354496 --[[Flags.FirstFormExponentBits]])
        if exponentBits <= (3440187165357637632 --[[6111L << 49]]) then
          return highBits + (3476778912330022912 --[[6176L << 49]])
        else
          return highBits - (3440750115311058944 --[[6112L << 49]])
        end
      elseif class.Flags.IsSecondForm(highBits) then
        local exponentBits = System.band(highBits, 2305702271725338624 --[[Flags.SecondFormExponentBits]])
        if exponentBits <= (860046791339409408 --[[6111L << 47]]) then
          return highBits + (869194728082505728 --[[6176L << 47]])
        else
          return highBits - (860187528827764736 --[[6112L << 47]])
        end
      else
        return highBits
      end
    end
    MapExponentToDecimal128BiasedExponent = function (exponent)
      -- internally we use a different bias than IEEE so that a Decimal128 struct filled with zero bytes is a true Decimal128 zero
      -- Decimal128Bias is defined as:
      -- exponents from     0 to 6111: biasedExponent = exponent
      -- exponents from -6176 to   -1: biasedExponent = exponent + 12288

      if exponent >= 0 then
        return exponent
      else
        return System.toInt16(exponent + 12288)
      end
    end
    MapIEEEHighBitsToDecimal128HighBits = function (highBits)
      -- for IEEEBias from    0 to  6175: Decimal128Bias = IEEEBias + 6112
      -- for IEEEBias from 6176 to 12287: Decimal128Bias = IEEEBias - 6176

      if class.Flags.IsFirstForm(highBits) then
        local exponentBits = System.band(highBits, 9222809086901354496 --[[Flags.FirstFormExponentBits]])
        if exponentBits <= (3476215962376601600 --[[6175L << 49]]) then
          return highBits + (3440750115311058944 --[[6112L << 49]])
        else
          return highBits - (3476778912330022912 --[[6176L << 49]])
        end
      elseif class.Flags.IsSecondForm(highBits) then
        local exponentBits = System.band(highBits, 2305702271725338624 --[[Flags.SecondFormExponentBits]])
        if exponentBits <= (869053990594150400 --[[6175L << 47]]) then
          return highBits + (860187528827764736 --[[6112L << 47]])
        else
          return highBits - (869194728082505728 --[[6176L << 47]])
        end
      else
        return highBits
      end
    end
    RemoveLeadingZeroes = function (significandString)
      if significandString:get(0) == 48 --[['0']] and #significandString > 1 then
        significandString = SystemRegularExpressions.Regex.Replace(significandString, "^0+", "")
        return (#significandString == 0) and "0" or significandString
      else
        return significandString
      end
    end
    CompareTo = function (this, other)
      return Compare(this, other:__clone__())
    end
    Equals = function (this, other)
      return Equals1(this, other:__clone__())
    end
    EqualsObj = function (this, obj)
      if obj == nil or obj:GetType() ~= System.typeof(class) then
        return false
      else
        return Equals(this, System.cast(class, obj))
      end
    end
    GetHashCode = function (this)
      local hash = 17
      hash = 37 * hash + this._highBits:GetHashCode()
      hash = 37 * hash + this._lowBits:GetHashCode()
      return hash
    end
    -- <summary>
    -- Gets the high order 64 bits of the binary representation of this instance.
    -- </summary>
    GetIEEEHighBits = function (this)
      return MapDecimal128HighBitsToIEEEHighBits(this._highBits)
    end
    -- <summary>
    -- Gets the low order 64 bits of the binary representation of this instance.
    -- </summary>
    GetIEEELowBits = function (this)
      return this._lowBits
    end
    ToString = function (this)
      if class.Flags.IsFirstForm(this._highBits) then
        local exponent = GetExponent(this)
        local significand = GetSignificand(this)
        local coefficientString = significand:ToString()
        local adjustedExponent = exponent + #coefficientString - 1

        local result
        if exponent > 0 or adjustedExponent < - 6 then
          result = ToStringWithExponentialNotation(this, coefficientString, adjustedExponent)
        else
          result = ToStringWithoutExponentialNotation(this, coefficientString, exponent)
        end

        if class.Flags.IsNegative(this._highBits) then
          result = "-" .. result
        end

        return result
      elseif class.Flags.IsSecondForm(this._highBits) then
        -- invalid representation treated as zero
        local exponent = GetExponent(this)
        if exponent == 0 then
          return class.Flags.IsNegative(this._highBits) and "-0" or "0"
        else
          local exponentString = exponent:ToString(SystemGlobalization.NumberFormatInfo.getInvariantInfo())
          if exponent > 0 then
            exponentString = "+" .. exponentString
          end
          return (class.Flags.IsNegative(this._highBits) and "-0E" or "0E") .. exponentString
        end
      elseif class.Flags.IsNegativeInfinity(this._highBits) then
        return "-Infinity"
      elseif class.Flags.IsPositiveInfinity(this._highBits) then
        return "Infinity"
      else
        return "NaN"
      end
    end
    GetTypeCode = function (this)
      return 1 --[[TypeCode.Object]]
    end
    ToBoolean = function (this, provider)
      return not (Equals1(this, getZero()) or IsNaN(this))
    end
    ToByte = function (this, provider)
      return ToByte1(this)
    end
    ToChar = function (this, provider)
      System.throw(System.InvalidCastException("Invalid cast from Decima128 to Char."))
    end
    ToDateTime = function (this, provider)
      System.throw(System.InvalidCastException("Invalid cast from Decima128 to DateTime."))
    end
    ToDecimal = function (this, provider)
      return ToDecimal1(this)
    end
    ToDouble = function (this, provider)
      return ToDouble1(this)
    end
    ToInt16 = function (this, provider)
      return ToInt161(this)
    end
    ToInt32 = function (this, provider)
      return ToInt321(this)
    end
    ToInt64 = function (this, provider)
      return ToInt641(this)
    end
    ToSByte = function (this, provider)
      return ToSByte1(this)
    end
    ToSingle = function (this, provider)
      return ToSingle1(this)
    end
    ToString1 = function (this, provider)
      return ToString(this)
    end
    ToType = function (this, conversionType, provider)
      local convertible = this
      repeat
        local default = System.Type.GetTypeCode(conversionType)
        if default == 3 --[[TypeCode.Boolean]] then
          return convertible:ToBoolean(provider)
        elseif default == 6 --[[TypeCode.Byte]] then
          return convertible:ToByte(provider)
        elseif default == 4 --[[TypeCode.Char]] then
          return convertible:ToChar(provider)
        elseif default == 16 --[[TypeCode.DateTime]] then
          return convertible:ToDateTime(provider)
        elseif default == 15 --[[TypeCode.Decimal]] then
          return convertible:ToDecimal(provider)
        elseif default == 14 --[[TypeCode.Double]] then
          return convertible:ToDouble(provider)
        elseif default == 7 --[[TypeCode.Int16]] then
          return convertible:ToInt16(provider)
        elseif default == 9 --[[TypeCode.Int32]] then
          return convertible:ToInt32(provider)
        elseif default == 11 --[[TypeCode.Int64]] then
          return convertible:ToInt64(provider)
        elseif default == 5 --[[TypeCode.SByte]] then
          return convertible:ToSByte(provider)
        elseif default == 13 --[[TypeCode.Single]] then
          return convertible:ToSingle(provider)
        elseif default == 18 --[[TypeCode.String]] then
          return convertible:ToString(provider)
        elseif default == 8 --[[TypeCode.UInt16]] then
          return convertible:ToUInt16(provider)
        elseif default == 10 --[[TypeCode.UInt32]] then
          return convertible:ToUInt32(provider)
        elseif default == 12 --[[TypeCode.UInt64]] then
          return convertible:ToUInt64(provider)
        else
          System.throw(System.InvalidCastException())
        end
      until 1
    end
    ToUInt16 = function (this, provider)
      return ToUInt161(this)
    end
    ToUInt32 = function (this, provider)
      return ToUInt321(this)
    end
    ToUInt64 = function (this, provider)
      return ToUInt641(this)
    end
    ToStringWithExponentialNotation = function (this, coefficientString, adjustedExponent)
      if #coefficientString > 1 then
        coefficientString = coefficientString:Substring(0, 1) .. "." .. coefficientString:Substring(1)
      end
      local exponentString = adjustedExponent:ToString(SystemGlobalization.NumberFormatInfo.getInvariantInfo())
      if adjustedExponent >= 0 then
        exponentString = "+" .. exponentString
      end
      return coefficientString .. "E" .. exponentString
    end
    ToStringWithoutExponentialNotation = function (this, coefficientString, exponent)
      if exponent == 0 then
        return coefficientString
      else
        local exponentAbsoluteValue = math.Abs(exponent)
        local minimumCoefficientStringLength = exponentAbsoluteValue + 1
        if #coefficientString < minimumCoefficientStringLength then
          coefficientString = coefficientString:PadLeft(minimumCoefficientStringLength, 48 --[['0']])
        end
        local decimalPointIndex = #coefficientString - exponentAbsoluteValue
        return coefficientString:Substring(0, decimalPointIndex) .. "." .. coefficientString:Substring(decimalPointIndex)
      end
    end
    TryTruncateToUInt64 = function (d, maxNegativeValue, maxPositiveValue, value)
      if IsZero(d:__clone__()) then
        value = 0
        return true, value
      end

      local exponent = GetExponent(d:__clone__())
      local significand = GetSignificand(d:__clone__())

      if exponent < 0 then
        while exponent < 0 do
          local remainder
          -- ignored because we are truncating
          local default
          default, remainder = MongoDBBson.UInt128.Divide(significand:__clone__(), 10 --[[(uint)10]])
          significand = default
          if significand:Equals(MongoDBBson.UInt128.getZero()) then
            value = 0
            return true, value
          end
          exponent = exponent + 1
        end
      elseif exponent > 0 then
        while exponent > 0 do
          significand = MongoDBBson.UInt128.Multiply(significand:__clone__(), 10 --[[(uint)10]])
          if significand:CompareTo(__maxSignificand:__clone__()) > 0 then
            value = 0
            return false, value
          end
          exponent = exponent - 1
        end
      end

      if exponent ~= 0 then
        value = 0
        return false, value
      end

      if significand:getHigh() ~= 0 or significand:getLow() > (IsNegative(d:__clone__()) and maxNegativeValue or maxPositiveValue) then
        value = 0
        return false, value
      end

      value = significand:getLow()
      return true, value
    end
    class = {
      base = function (out)
        return {
          System.IConvertible,
          System.IComparable_1(out.MongoDB.Bson.Decimal128),
          System.IEquatable_1(out.MongoDB.Bson.Decimal128)
        }
      end,
      getMaxValue = getMaxValue,
      getMinValue = getMinValue,
      getNegativeInfinity = getNegativeInfinity,
      getOne = getOne,
      getPositiveInfinity = getPositiveInfinity,
      getQNaN = getQNaN,
      getSNaN = getSNaN,
      getZero = getZero,
      op_Equality = op_Equality,
      op_Inequality = op_Inequality,
      op_GreaterThan = op_GreaterThan,
      op_GreaterThanOrEqual = op_GreaterThanOrEqual,
      op_LessThan = op_LessThan,
      op_LessThanOrEqual = op_LessThanOrEqual,
      op_Explicit = op_Explicit,
      op_Explicit1 = op_Explicit1,
      op_Explicit2 = op_Explicit2,
      op_Implicit = op_Implicit,
      op_Implicit1 = op_Implicit1,
      op_Explicit3 = op_Explicit3,
      op_Explicit4 = op_Explicit4,
      op_Implicit2 = op_Implicit2,
      op_Implicit3 = op_Implicit3,
      op_Implicit4 = op_Implicit4,
      op_Implicit5 = op_Implicit5,
      op_Implicit6 = op_Implicit6,
      op_Implicit7 = op_Implicit7,
      op_Implicit8 = op_Implicit8,
      op_Explicit5 = op_Explicit5,
      op_Explicit6 = op_Explicit6,
      op_Explicit7 = op_Explicit7,
      op_Explicit8 = op_Explicit8,
      op_Explicit9 = op_Explicit9,
      op_Explicit10 = op_Explicit10,
      op_Explicit11 = op_Explicit11,
      op_Explicit12 = op_Explicit12,
      op_Explicit13 = op_Explicit13,
      Compare = Compare,
      Equals1 = Equals1,
      FromComponents = FromComponents,
      FromIEEEBits = FromIEEEBits,
      GetExponent = GetExponent,
      GetSignificandHighBits = GetSignificandHighBits,
      GetSignificandLowBits = GetSignificandLowBits,
      IsInfinity = IsInfinity,
      IsNaN = IsNaN,
      IsNegative = IsNegative,
      IsNegativeInfinity = IsNegativeInfinity,
      IsPositiveInfinity = IsPositiveInfinity,
      IsQNaN = IsQNaN,
      IsSNaN = IsSNaN,
      IsZero = IsZero,
      Negate = Negate,
      Parse = Parse,
      ToByte1 = ToByte1,
      ToDecimal1 = ToDecimal1,
      ToDouble1 = ToDouble1,
      ToInt161 = ToInt161,
      ToInt321 = ToInt321,
      ToInt641 = ToInt641,
      ToSByte1 = ToSByte1,
      ToSingle1 = ToSingle1,
      ToUInt161 = ToUInt161,
      ToUInt321 = ToUInt321,
      ToUInt641 = ToUInt641,
      TryParse = TryParse,
      _highBits = 0,
      _lowBits = 0,
      CompareTo = CompareTo,
      Equals = Equals,
      EqualsObj = EqualsObj,
      GetHashCode = GetHashCode,
      GetIEEEHighBits = GetIEEEHighBits,
      GetIEEELowBits = GetIEEELowBits,
      ToString = ToString,
      GetTypeCode = GetTypeCode,
      ToBoolean = ToBoolean,
      ToByte = ToByte,
      ToChar = ToChar,
      ToDateTime = ToDateTime,
      ToDecimal = ToDecimal,
      ToDouble = ToDouble,
      ToInt16 = ToInt16,
      ToInt32 = ToInt32,
      ToInt64 = ToInt64,
      ToSByte = ToSByte,
      ToSingle = ToSingle,
      ToString1 = ToString1,
      ToType = ToType,
      ToUInt16 = ToUInt16,
      ToUInt32 = ToUInt32,
      ToUInt64 = ToUInt64,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__,
        __ctor3__,
        __ctor4__,
        __ctor5__,
        __ctor6__,
        __ctor7__,
        __ctor8__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "__maxDecimalValue", 0x9, class },
            { "__maxSignificand", 0x9, out.MongoDB.Bson.UInt128 },
            { "__maxValue", 0x9, class },
            { "__minDecimalValue", 0x9, class },
            { "__minValue", 0x9, class },
            { "_highBits", 0x1, System.UInt64 },
            { "_lowBits", 0x1, System.UInt64 }
          },
          properties = {
            { "MaxValue", 0x20E, class, getMaxValue },
            { "MinValue", 0x20E, class, getMinValue },
            { "NegativeInfinity", 0x20E, class, getNegativeInfinity },
            { "One", 0x20E, class, getOne },
            { "PositiveInfinity", 0x20E, class, getPositiveInfinity },
            { "QNaN", 0x20E, class, getQNaN },
            { "SNaN", 0x20E, class, getSNaN },
            { "Zero", 0x20E, class, getZero }
          },
          methods = {
            { ".ctor", 0x106, __ctor7__, System.UInt32, System.CLSCompliantAttribute(false) },
            { ".ctor", 0x106, __ctor8__, System.UInt64, System.CLSCompliantAttribute(false) },
            { "FromComponents", 0x48E, FromComponents, System.Boolean, System.Int16, System.UInt64, System.UInt64, class, System.CLSCompliantAttribute(false) },
            { "FromIEEEBits", 0x28E, FromIEEEBits, System.UInt64, System.UInt64, class, System.CLSCompliantAttribute(false) },
            { "GetIEEEHighBits", 0x86, GetIEEEHighBits, System.UInt64, System.CLSCompliantAttribute(false) },
            { "GetIEEELowBits", 0x86, GetIEEELowBits, System.UInt64, System.CLSCompliantAttribute(false) },
            { "GetSignificandHighBits", 0x18E, GetSignificandHighBits, class, System.UInt64, System.CLSCompliantAttribute(false) },
            { "GetSignificandLowBits", 0x18E, GetSignificandLowBits, class, System.UInt64, System.CLSCompliantAttribute(false) },
            { "ToSByte", 0x18E, ToSByte1, class, System.SByte, System.CLSCompliantAttribute(false) },
            { "ToUInt16", 0x18E, ToUInt161, class, System.UInt16, System.CLSCompliantAttribute(false) },
            { "ToUInt32", 0x18E, ToUInt321, class, System.UInt32, System.CLSCompliantAttribute(false) },
            { "ToUInt64", 0x18E, ToUInt641, class, System.UInt64, System.CLSCompliantAttribute(false) }
          }
        }
      end
    }
    return class
  end)
end)
