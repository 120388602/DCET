-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local SystemSecurity = System.Security
local ArrayByte = System.Array(System.Byte)
local ArrayChar = System.Array(System.Char)
local MongoDBBson
System.import(function (out)
  MongoDBBson = MongoDB.Bson
end)
System.namespace("MongoDB.Bson", function (namespace)
  -- <summary>
  -- Represents an ObjectId (see also BsonObjectId).
  -- </summary>
  namespace.struct("ObjectId", function (namespace)
    local __emptyInstance, __staticMachine, __staticPid, __staticIncrement, getEmpty, getTimestamp, getMachine, getPid, 
    getIncrement, getCreationTime, op_LessThan, op_LessThanOrEqual, op_Equality, op_Inequality, op_GreaterThanOrEqual, op_GreaterThan, 
    GenerateNewId, GenerateNewId1, GenerateNewId2, Pack, Parse, TryParse, Unpack, GetAppDomainId, 
    GetCurrentProcessId, GetMachineHash, GetMachineName, GetPid, GetTimestampFromDateTime, FromByteArray, CompareTo, Equals, 
    EqualsObj, GetHashCode, ToByteArray, ToByteArray1, ToString, GetTypeCode, ToBoolean, ToByte, 
    ToChar, ToDateTime, ToDecimal, ToDouble, ToInt16, ToInt32, ToInt64, ToSByte, 
    ToSingle, ToString1, ToType, ToUInt16, ToUInt32, ToUInt64, class, static, 
    __ctor1__, __ctor2__, __ctor3__, __ctor4__, __ctor5__
    static = function (this)
      __emptyInstance = System.default(class)
      __staticMachine = System.band((GetMachineHash() + GetAppDomainId()), 0x00ffffff)
      __staticPid = GetPid()
      __staticIncrement = (System.Random()):Next()
    end
    -- <summary>
    -- Initializes a new instance of the ObjectId class.
    -- </summary>
    -- <param name="index">The index into the byte array where the ObjectId starts.</param>
    __ctor1__ = function (this, bytes, index)
      if index == nil then
        return
      end
      this._a, this._b, this._c = FromByteArray(bytes, index)
    end
    -- <summary>
    -- Initializes a new instance of the ObjectId class.
    -- </summary>
    __ctor2__ = function (this, bytes)
      if bytes == nil then
        System.throw(System.ArgumentNullException("bytes"))
      end
      if #bytes ~= 12 then
        System.throw(System.ArgumentException("Byte array must be 12 bytes long", "bytes"))
      end

      this._a, this._b, this._c = FromByteArray(bytes, 0)
    end
    -- <summary>
    -- Initializes a new instance of the ObjectId class.
    -- </summary>
    -- <param name="machine">The machine hash.</param>
    -- <param name="pid">The PID.</param>
    -- <param name="increment">The increment.</param>
    __ctor3__ = function (this, timestamp, machine, pid, increment)
      __ctor4__(this, GetTimestampFromDateTime(timestamp), machine, pid, increment)
    end
    -- <summary>
    -- Initializes a new instance of the ObjectId class.
    -- </summary>
    -- <param name="machine">The machine hash.</param>
    -- <param name="pid">The PID.</param>
    -- <param name="increment">The increment.</param>
    __ctor4__ = function (this, timestamp, machine, pid, increment)
      if (System.band(machine, 0xff000000)) ~= 0 then
        System.throw(System.ArgumentOutOfRangeException("machine", "The machine value must be between 0 and 16777215 (it must fit in 3 bytes)."))
      end
      if (System.band(increment, 0xff000000)) ~= 0 then
        System.throw(System.ArgumentOutOfRangeException("increment", "The increment value must be between 0 and 16777215 (it must fit in 3 bytes)."))
      end

      this._a = timestamp
      this._b = System.bor((System.sl(machine, 8)), (System.band((System.sr(pid, 8)), 0xff)))
      this._c = System.bor((System.sl(pid, 24)), increment)
    end
    -- <summary>
    -- Initializes a new instance of the ObjectId class.
    -- </summary>
    __ctor5__ = function (this, value)
      if value == nil then
        System.throw(System.ArgumentNullException("value"))
      end

      local bytes = MongoDBBson.BsonUtils.ParseHexString(value)
      this._a, this._b, this._c = FromByteArray(bytes, 0)
    end
    getEmpty = function ()
      return __emptyInstance:__clone__()
    end
    getTimestamp = function (this)
      return this._a
    end
    getMachine = function (this)
      return System.band((System.sr(this._b, 8)), 0xffffff)
    end
    getPid = function (this)
      return System.toInt16(System.bor((System.band((System.sl(this._b, 8)), 0xff00)), (System.band((System.sr(this._c, 24)), 0x00ff))))
    end
    getIncrement = function (this)
      return System.band(this._c, 0xffffff)
    end
    getCreationTime = function (this)
      return MongoDBBson.BsonConstants.getUnixEpoch():AddSeconds(getTimestamp(this))
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId</param>
    -- <returns>True if the first ObjectId is less than the second ObjectId.</returns>
    op_LessThan = function (lhs, rhs)
      return CompareTo(lhs, rhs:__clone__()) < 0
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId</param>
    -- <returns>True if the first ObjectId is less than or equal to the second ObjectId.</returns>
    op_LessThanOrEqual = function (lhs, rhs)
      return CompareTo(lhs, rhs:__clone__()) <= 0
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId.</param>
    -- <returns>True if the two ObjectIds are equal.</returns>
    op_Equality = function (lhs, rhs)
      return Equals(lhs, rhs:__clone__())
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId.</param>
    -- <returns>True if the two ObjectIds are not equal.</returns>
    op_Inequality = function (lhs, rhs)
      return not (op_Equality(lhs, rhs))
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId</param>
    -- <returns>True if the first ObjectId is greather than or equal to the second ObjectId.</returns>
    op_GreaterThanOrEqual = function (lhs, rhs)
      return CompareTo(lhs, rhs:__clone__()) >= 0
    end
    -- <summary>
    -- Compares two ObjectIds.
    -- </summary>
    -- <param name="rhs">The other ObjectId</param>
    -- <returns>True if the first ObjectId is greather than the second ObjectId.</returns>
    op_GreaterThan = function (lhs, rhs)
      return CompareTo(lhs, rhs:__clone__()) > 0
    end
    -- <summary>
    -- Generates a new ObjectId with a unique value.
    -- </summary>
    GenerateNewId = function ()
      return GenerateNewId2(GetTimestampFromDateTime(System.DateTime.getUtcNow()))
    end
    -- <summary>
    -- Generates a new ObjectId with a unique value (with the timestamp component based on a given DateTime).
    -- </summary>
    -- <returns>An ObjectId.</returns>
    GenerateNewId1 = function (timestamp)
      return GenerateNewId2(GetTimestampFromDateTime(timestamp))
    end
    -- <summary>
    -- Generates a new ObjectId with a unique value (with the given timestamp).
    -- </summary>
    -- <returns>An ObjectId.</returns>
    GenerateNewId2 = function (timestamp)
      local default
      default, __staticIncrement = System.Interlocked.Increment(__staticIncrement)
      local increment = System.band(default, 0x00ffffff)
      -- only use low order 3 bytes
      return System.new(class, 4, timestamp, __staticMachine, __staticPid, increment)
    end
    -- <summary>
    -- Packs the components of an ObjectId into a byte array.
    -- </summary>
    -- <param name="machine">The machine hash.</param>
    -- <param name="pid">The PID.</param>
    -- <param name="increment">The increment.</param>
    -- <returns>A byte array.</returns>
    Pack = function (timestamp, machine, pid, increment)
      if (System.band(machine, 0xff000000)) ~= 0 then
        System.throw(System.ArgumentOutOfRangeException("machine", "The machine value must be between 0 and 16777215 (it must fit in 3 bytes)."))
      end
      if (System.band(increment, 0xff000000)) ~= 0 then
        System.throw(System.ArgumentOutOfRangeException("increment", "The increment value must be between 0 and 16777215 (it must fit in 3 bytes)."))
      end

      local bytes = ArrayByte:new(12)
      bytes:set(0, System.toByte(System.sr(timestamp, 24)))
      bytes:set(1, System.toByte(System.sr(timestamp, 16)))
      bytes:set(2, System.toByte(System.sr(timestamp, 8)))
      bytes:set(3, System.toByte(timestamp))
      bytes:set(4, System.toByte(System.sr(machine, 16)))
      bytes:set(5, System.toByte(System.sr(machine, 8)))
      bytes:set(6, System.toByte(machine))
      bytes:set(7, System.toByte(System.sr(pid, 8)))
      bytes:set(8, System.toByte(pid))
      bytes:set(9, System.toByte(System.sr(increment, 16)))
      bytes:set(10, System.toByte(System.sr(increment, 8)))
      bytes:set(11, System.toByte(increment))
      return bytes
    end
    -- <summary>
    -- Parses a string and creates a new ObjectId.
    -- </summary>
    -- <returns>A ObjectId.</returns>
    Parse = function (s)
      if s == nil then
        System.throw(System.ArgumentNullException("s"))
      end

      local objectId
      local default
      default, objectId = TryParse(s)
      if default then
        return objectId:__clone__()
      else
        local message = System.String.Format("'{0}' is not a valid 24 digit hex string.", s)
        System.throw(System.FormatException(message))
      end
    end
    -- <summary>
    -- Tries to parse a string and create a new ObjectId.
    -- </summary>
    -- <param name="objectId">The new ObjectId.</param>
    -- <returns>True if the string was parsed successfully.</returns>
    TryParse = function (s, objectId)
      -- don't throw ArgumentNullException if s is null
      if s ~= nil and #s == 24 then
        local bytes
        local default
        default, bytes = MongoDBBson.BsonUtils.TryParseHexString(s)
        if default then
          objectId = System.new(class, 2, bytes)
          return true, objectId
        end
      end

      objectId = System.default(class)
      return false, objectId
    end
    -- <summary>
    -- Unpacks a byte array into the components of an ObjectId.
    -- </summary>
    -- <param name="timestamp">The timestamp.</param>
    -- <param name="machine">The machine hash.</param>
    -- <param name="pid">The PID.</param>
    -- <param name="increment">The increment.</param>
    Unpack = function (bytes, timestamp, machine, pid, increment)
      if bytes == nil then
        System.throw(System.ArgumentNullException("bytes"))
      end
      if #bytes ~= 12 then
        System.throw(System.ArgumentOutOfRangeException("bytes", "Byte array must be 12 bytes long."))
      end

      timestamp = (System.sl(bytes:get(0), 24)) + (System.sl(bytes:get(1), 16)) + (System.sl(bytes:get(2), 8)) + bytes:get(3)
      machine = (System.sl(bytes:get(4), 16)) + (System.sl(bytes:get(5), 8)) + bytes:get(6)
      pid = System.toInt16((System.sl(bytes:get(7), 8)) + bytes:get(8))
      increment = (System.sl(bytes:get(9), 16)) + (System.sl(bytes:get(10), 8)) + bytes:get(11)
      return timestamp, machine, pid, increment
    end
    GetAppDomainId = function ()
      return System.AppDomain.getCurrentDomain():getId()
    end
    -- <summary>
    -- Gets the current process id.  This method exists because of how CAS operates on the call stack, checking
    -- for permissions before executing the method.  Hence, if we inlined this call, the calling method would not execute
    -- before throwing an exception requiring the try/catch at an even higher level that we don't necessarily control.
    -- </summary>
    GetCurrentProcessId = function ()
      return System.Process.GetCurrentProcess():getId()
    end
    GetMachineHash = function ()
      -- use instead of Dns.HostName so it will work offline
      local machineName = GetMachineName()
      return System.band(0x00ffffff, machineName:GetHashCode())
      -- use first 3 bytes of hash
    end
    GetMachineName = function ()
      return System.Environment.getMachineName()
    end
    GetPid = function ()
      local default, extern = System.try(function ()
        return true, System.toInt16(GetCurrentProcessId())
        -- use low order two bytes only
      end, function (default)
        if System.is(default, SystemSecurity.SecurityException) then
          return true, 0
        else
          return 1, default
        end
      end)
      if default then
        return extern
      end
    end
    GetTimestampFromDateTime = function (timestamp)
      local secondsSinceEpoch = System.ToInt64(math.Floor((MongoDBBson.BsonUtils.ToUniversalTime(timestamp) - MongoDBBson.BsonConstants.getUnixEpoch()):getTotalSeconds()))
      if secondsSinceEpoch < -2147483648 --[[Int32.MinValue]] or secondsSinceEpoch > 2147483647 --[[Int32.MaxValue]] then
        System.throw(System.ArgumentOutOfRangeException("timestamp"))
      end
      return System.toInt32(secondsSinceEpoch)
    end
    FromByteArray = function (bytes, offset, a, b, c)
      a = System.bor(System.bor(System.bor((System.sl(bytes:get(offset), 24)), (System.sl(bytes:get(offset + 1), 16))), (System.sl(bytes:get(offset + 2), 8))), bytes:get(offset + 3))
      b = System.bor(System.bor(System.bor((System.sl(bytes:get(offset + 4), 24)), (System.sl(bytes:get(offset + 5), 16))), (System.sl(bytes:get(offset + 6), 8))), bytes:get(offset + 7))
      c = System.bor(System.bor(System.bor((System.sl(bytes:get(offset + 8), 24)), (System.sl(bytes:get(offset + 9), 16))), (System.sl(bytes:get(offset + 10), 8))), bytes:get(offset + 11))
      return a, b, c
    end
    -- <summary>
    -- Compares this ObjectId to another ObjectId.
    -- </summary>
    -- <returns>A 32-bit signed integer that indicates whether this ObjectId is less than, equal to, or greather than the other.</returns>
    CompareTo = function (this, other)
      local result = (System.toUInt32(this._a)):CompareTo(System.toUInt32(other._a))
      if result ~= 0 then
        return result
      end
      result = (System.toUInt32(this._b)):CompareTo(System.toUInt32(other._b))
      if result ~= 0 then
        return result
      end
      return (System.toUInt32(this._c)):CompareTo(System.toUInt32(other._c))
    end
    -- <summary>
    -- Compares this ObjectId to another ObjectId.
    -- </summary>
    -- <returns>True if the two ObjectIds are equal.</returns>
    Equals = function (this, rhs)
      return this._a == rhs._a and this._b == rhs._b and this._c == rhs._c
    end
    -- <summary>
    -- Compares this ObjectId to another object.
    -- </summary>
    -- <returns>True if the other object is an ObjectId and equal to this one.</returns>
    EqualsObj = function (this, obj)
      if System.is(obj, class) then
        return Equals(this, System.cast(class, obj))
      else
        return false
      end
    end
    -- <summary>
    -- Gets the hash code.
    -- </summary>
    GetHashCode = function (this)
      local hash = 17
      hash = 37 * hash + this._a:GetHashCode()
      hash = 37 * hash + this._b:GetHashCode()
      hash = 37 * hash + this._c:GetHashCode()
      return hash
    end
    -- <summary>
    -- Converts the ObjectId to a byte array.
    -- </summary>
    ToByteArray = function (this)
      local bytes = ArrayByte:new(12)
      ToByteArray1(this, bytes, 0)
      return bytes
    end
    -- <summary>
    -- Converts the ObjectId to a byte array.
    -- </summary>
    -- <param name="offset">The offset.</param>
    ToByteArray1 = function (this, destination, offset)
      if destination == nil then
        System.throw(System.ArgumentNullException("destination"))
      end
      if offset + 12 > #destination then
        System.throw(System.ArgumentException("Not enough room in destination buffer.", "offset"))
      end

      destination:set(offset + 0, System.toByte(System.sr(this._a, 24)))
      destination:set(offset + 1, System.toByte(System.sr(this._a, 16)))
      destination:set(offset + 2, System.toByte(System.sr(this._a, 8)))
      destination:set(offset + 3, System.toByte(this._a))
      destination:set(offset + 4, System.toByte(System.sr(this._b, 24)))
      destination:set(offset + 5, System.toByte(System.sr(this._b, 16)))
      destination:set(offset + 6, System.toByte(System.sr(this._b, 8)))
      destination:set(offset + 7, System.toByte(this._b))
      destination:set(offset + 8, System.toByte(System.sr(this._c, 24)))
      destination:set(offset + 9, System.toByte(System.sr(this._c, 16)))
      destination:set(offset + 10, System.toByte(System.sr(this._c, 8)))
      destination:set(offset + 11, System.toByte(this._c))
    end
    -- <summary>
    -- Returns a string representation of the value.
    -- </summary>
    ToString = function (this)
      local c = ArrayChar:new(24)
      c:set(0, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 28)), 0x0f)))
      c:set(1, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 24)), 0x0f)))
      c:set(2, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 20)), 0x0f)))
      c:set(3, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 16)), 0x0f)))
      c:set(4, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 12)), 0x0f)))
      c:set(5, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 8)), 0x0f)))
      c:set(6, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._a, 4)), 0x0f)))
      c:set(7, MongoDBBson.BsonUtils.ToHexChar(System.band(this._a, 0x0f)))
      c:set(8, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 28)), 0x0f)))
      c:set(9, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 24)), 0x0f)))
      c:set(10, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 20)), 0x0f)))
      c:set(11, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 16)), 0x0f)))
      c:set(12, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 12)), 0x0f)))
      c:set(13, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 8)), 0x0f)))
      c:set(14, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._b, 4)), 0x0f)))
      c:set(15, MongoDBBson.BsonUtils.ToHexChar(System.band(this._b, 0x0f)))
      c:set(16, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 28)), 0x0f)))
      c:set(17, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 24)), 0x0f)))
      c:set(18, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 20)), 0x0f)))
      c:set(19, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 16)), 0x0f)))
      c:set(20, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 12)), 0x0f)))
      c:set(21, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 8)), 0x0f)))
      c:set(22, MongoDBBson.BsonUtils.ToHexChar(System.band((System.sr(this._c, 4)), 0x0f)))
      c:set(23, MongoDBBson.BsonUtils.ToHexChar(System.band(this._c, 0x0f)))
      return System.String(c)
    end
    GetTypeCode = function (this)
      return 1 --[[TypeCode.Object]]
    end
    ToBoolean = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToByte = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToChar = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToDateTime = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToDecimal = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToDouble = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToInt16 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToInt32 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToInt64 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToSByte = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToSingle = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToString1 = function (this, provider)
      return ToString(this)
    end
    ToType = function (this, conversionType, provider)
      repeat
        local default = System.Type.GetTypeCode(conversionType)
        if default == 18 --[[TypeCode.String]] then
          return this:ToString(provider)
        elseif default == 1 --[[TypeCode.Object]] then
          if conversionType == System.typeof(System.Object) or conversionType == System.typeof(class) then
            return this
          end
          if conversionType == System.typeof(MongoDBBson.BsonObjectId) then
            return MongoDBBson.BsonObjectId(this)
          end
          if conversionType == System.typeof(MongoDBBson.BsonString) then
            return MongoDBBson.BsonString(this:ToString(provider))
          end
          break
        end
      until 1

      System.throw(System.InvalidCastException())
    end
    ToUInt16 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToUInt32 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    ToUInt64 = function (this, provider)
      System.throw(System.InvalidCastException())
    end
    class = {
      base = function (out)
        return {
          System.IComparable_1(out.MongoDB.Bson.ObjectId),
          System.IEquatable_1(out.MongoDB.Bson.ObjectId),
          System.IConvertible
        }
      end,
      _a = 0,
      _b = 0,
      _c = 0,
      getEmpty = getEmpty,
      getTimestamp = getTimestamp,
      getMachine = getMachine,
      getPid = getPid,
      getIncrement = getIncrement,
      getCreationTime = getCreationTime,
      op_LessThan = op_LessThan,
      op_LessThanOrEqual = op_LessThanOrEqual,
      op_Equality = op_Equality,
      op_Inequality = op_Inequality,
      op_GreaterThanOrEqual = op_GreaterThanOrEqual,
      op_GreaterThan = op_GreaterThan,
      GenerateNewId = GenerateNewId,
      GenerateNewId1 = GenerateNewId1,
      GenerateNewId2 = GenerateNewId2,
      Pack = Pack,
      Parse = Parse,
      TryParse = TryParse,
      Unpack = Unpack,
      CompareTo = CompareTo,
      Equals = Equals,
      EqualsObj = EqualsObj,
      GetHashCode = GetHashCode,
      ToByteArray = ToByteArray,
      ToByteArray1 = ToByteArray1,
      ToString = ToString,
      GetTypeCode = GetTypeCode,
      ToBoolean = ToBoolean,
      ToByte = ToByte,
      ToChar = ToChar,
      ToDateTime = ToDateTime,
      ToDecimal = ToDecimal,
      ToDouble = ToDouble,
      ToInt16 = ToInt16,
      ToInt32 = ToInt32,
      ToInt64 = ToInt64,
      ToSByte = ToSByte,
      ToSingle = ToSingle,
      ToString1 = ToString1,
      ToType = ToType,
      ToUInt16 = ToUInt16,
      ToUInt32 = ToUInt32,
      ToUInt64 = ToUInt64,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__,
        __ctor3__,
        __ctor4__,
        __ctor5__
      },
      __metadata__ = function (out)
        return {
          fields = {
            { "__emptyInstance", 0x9, class },
            { "__staticIncrement", 0x9, System.Int32 },
            { "__staticMachine", 0x9, System.Int32 },
            { "__staticPid", 0x9, System.Int16 },
            { "_a", 0x1, System.Int32 },
            { "_b", 0x1, System.Int32 },
            { "_c", 0x1, System.Int32 }
          },
          properties = {
            { "CreationTime", 0x206, System.DateTime, getCreationTime },
            { "Empty", 0x20E, class, getEmpty },
            { "Increment", 0x206, System.Int32, getIncrement },
            { "Machine", 0x206, System.Int32, getMachine },
            { "Pid", 0x206, System.Int16, getPid },
            { "Timestamp", 0x206, System.Int32, getTimestamp }
          },
          methods = {
            { "GetCurrentProcessId", 0x89, GetCurrentProcessId, System.Int32, System.MethodImplAttribute(8 --[[MethodImplOptions.NoInlining]]) }
          }
        }
      end
    }
    return class
  end)
end)
