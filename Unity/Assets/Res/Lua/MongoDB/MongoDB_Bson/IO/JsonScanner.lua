-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local ArrayChar = System.Array(System.Char)
local MongoDBBson
local MongoDBBsonIO
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- A static class that represents a JSON scanner.
  -- </summary>
  namespace.class("JsonScanner", function (namespace)
    local GetNextToken, FormatMessage, GetNumberToken, GetRegularExpressionToken, GetStringToken, GetUnquotedStringToken
    -- <summary>
    -- Gets the next JsonToken from a JsonBuffer.
    -- </summary>
    -- <returns>The next token.</returns>
    GetNextToken = function (buffer)
      -- skip leading whitespace
      local c = buffer:Read()
      while c ~= - 1 and System.Char.IsWhiteSpace(System.toUInt16(c)) do
        c = buffer:Read()
      end
      if c == - 1 then
        return MongoDBBsonIO.JsonToken(17 --[[JsonTokenType.EndOfFile]], "<eof>")
      end

      -- leading character determines token type
      repeat
        local default = c
        if default == 123 --[['{']] then
          return MongoDBBsonIO.JsonToken(2 --[[JsonTokenType.BeginObject]], "{")
        elseif default == 125 --[['}']] then
          return MongoDBBsonIO.JsonToken(6 --[[JsonTokenType.EndObject]], "}")
        elseif default == 91 --[['[']] then
          return MongoDBBsonIO.JsonToken(1 --[[JsonTokenType.BeginArray]], "[")
        elseif default == 93 --[[']']] then
          return MongoDBBsonIO.JsonToken(3 --[[JsonTokenType.EndArray]], "]")
        elseif default == 40 --[['(']] then
          return MongoDBBsonIO.JsonToken(4 --[[JsonTokenType.LeftParen]], "(")
        elseif default == 41 --[[')']] then
          return MongoDBBsonIO.JsonToken(5 --[[JsonTokenType.RightParen]], ")")
        elseif default == 58 --[[':']] then
          return MongoDBBsonIO.JsonToken(7 --[[JsonTokenType.Colon]], ":")
        elseif default == 44 --[[',']] then
          return MongoDBBsonIO.JsonToken(8 --[[JsonTokenType.Comma]], ",")
        elseif default == 39 --[['\'']] or default == 34 --[['"']] then
          return GetStringToken(buffer, System.toUInt16(c))
        elseif default == 47 --[['/']] then
          return GetRegularExpressionToken(buffer)
        else
          if c == 45 --[['-']] or System.Char.IsDigit(System.toUInt16(c)) then
            return GetNumberToken(buffer, c)
          elseif c == 36 --[['$']] or c == 95 --[['_']] or System.Char.IsLetter(System.toUInt16(c)) then
            return GetUnquotedStringToken(buffer)
          else
            buffer:UnRead(c)
            System.throw(System.FormatException(FormatMessage("Invalid JSON input", buffer, buffer:getPosition())))
          end
        end
      until 1
    end
    FormatMessage = function (message, buffer, start)
      local maxLength = 20
      local snippet = buffer:GetSnippet(start, maxLength)
      return System.String.Format("{0} '{1}'.", message, snippet)
    end
    GetNumberToken = function (buffer, firstChar)
      local c = firstChar

      -- leading digit or '-' has already been read
      local start = buffer:getPosition() - 1
      local state
      repeat
        local default = c
        if default == 45 --[['-']] then
          state = 0 --[[NumberState.SawLeadingMinus]]
          break
        elseif default == 48 --[['0']] then
          state = 1 --[[NumberState.SawLeadingZero]]
          break
        else
          state = 2 --[[NumberState.SawIntegerDigits]]
          break
        end
      until 1
      local type = 12 --[[JsonTokenType.Int64]]
      -- assume integer until proved otherwise

      while true do
        c = buffer:Read()
        repeat
          local extern = state
          if extern == 0 --[[NumberState.SawLeadingMinus]] then
            repeat
              local ref = c
              if ref == 48 --[['0']] then
                state = 1 --[[NumberState.SawLeadingZero]]
                break
              elseif ref == 73 --[['I']] then
                state = 8 --[[NumberState.SawMinusI]]
                break
              else
                if System.Char.IsDigit(System.toUInt16(c)) then
                  state = 2 --[[NumberState.SawIntegerDigits]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 1 --[[NumberState.SawLeadingZero]] then
            repeat
              local ref = c
              if ref == 46 --[['.']] then
                state = 3 --[[NumberState.SawDecimalPoint]]
                break
              elseif ref == 101 --[['e']] or ref == 69 --[['E']] then
                state = 5 --[[NumberState.SawExponentLetter]]
                break
              elseif ref == 44 --[[',']] or ref == 125 --[['}']] or ref == 93 --[[']']] or ref == 41 --[[')']] or ref == - 1 then
                state = 9 --[[NumberState.Done]]
                break
              else
                if System.Char.IsWhiteSpace(System.toUInt16(c)) then
                  state = 9 --[[NumberState.Done]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 2 --[[NumberState.SawIntegerDigits]] then
            repeat
              local ref = c
              if ref == 46 --[['.']] then
                state = 3 --[[NumberState.SawDecimalPoint]]
                break
              elseif ref == 101 --[['e']] or ref == 69 --[['E']] then
                state = 5 --[[NumberState.SawExponentLetter]]
                break
              elseif ref == 44 --[[',']] or ref == 125 --[['}']] or ref == 93 --[[']']] or ref == 41 --[[')']] or ref == - 1 then
                state = 9 --[[NumberState.Done]]
                break
              else
                if System.Char.IsDigit(System.toUInt16(c)) then
                  state = 2 --[[NumberState.SawIntegerDigits]]
                elseif System.Char.IsWhiteSpace(System.toUInt16(c)) then
                  state = 9 --[[NumberState.Done]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 3 --[[NumberState.SawDecimalPoint]] then
            type = 10 --[[JsonTokenType.Double]]
            if System.Char.IsDigit(System.toUInt16(c)) then
              state = 4 --[[NumberState.SawFractionDigits]]
            else
              state = 10 --[[NumberState.Invalid]]
            end
            break
          elseif extern == 4 --[[NumberState.SawFractionDigits]] then
            repeat
              local ref = c
              if ref == 101 --[['e']] or ref == 69 --[['E']] then
                state = 5 --[[NumberState.SawExponentLetter]]
                break
              elseif ref == 44 --[[',']] or ref == 125 --[['}']] or ref == 93 --[[']']] or ref == 41 --[[')']] or ref == - 1 then
                state = 9 --[[NumberState.Done]]
                break
              else
                if System.Char.IsDigit(System.toUInt16(c)) then
                  state = 4 --[[NumberState.SawFractionDigits]]
                elseif System.Char.IsWhiteSpace(System.toUInt16(c)) then
                  state = 9 --[[NumberState.Done]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 5 --[[NumberState.SawExponentLetter]] then
            type = 10 --[[JsonTokenType.Double]]
            repeat
              local ref = c
              if ref == 43 --[['+']] or ref == 45 --[['-']] then
                state = 6 --[[NumberState.SawExponentSign]]
                break
              else
                if System.Char.IsDigit(System.toUInt16(c)) then
                  state = 7 --[[NumberState.SawExponentDigits]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 6 --[[NumberState.SawExponentSign]] then
            if System.Char.IsDigit(System.toUInt16(c)) then
              state = 7 --[[NumberState.SawExponentDigits]]
            else
              state = 10 --[[NumberState.Invalid]]
            end
            break
          elseif extern == 7 --[[NumberState.SawExponentDigits]] then
            repeat
              local ref = c
              if ref == 44 --[[',']] or ref == 125 --[['}']] or ref == 93 --[[']']] or ref == 41 --[[')']] or ref == - 1 then
                state = 9 --[[NumberState.Done]]
                break
              else
                if System.Char.IsDigit(System.toUInt16(c)) then
                  state = 7 --[[NumberState.SawExponentDigits]]
                elseif System.Char.IsWhiteSpace(System.toUInt16(c)) then
                  state = 9 --[[NumberState.Done]]
                else
                  state = 10 --[[NumberState.Invalid]]
                end
                break
              end
            until 1
            break
          elseif extern == 8 --[[NumberState.SawMinusI]] then
            local sawMinusInfinity = true
            local nfinity = ArrayChar(110 --[['n']], 102 --[['f']], 105 --[['i']], 110 --[['n']], 105 --[['i']], 116 --[['t']], 121 --[['y']])
            for i = 0, #nfinity - 1 do
              if c ~= nfinity:get(i) then
                sawMinusInfinity = false
                break
              end
              c = buffer:Read()
            end
            if sawMinusInfinity then
              type = 10 --[[JsonTokenType.Double]]
              repeat
                local ref = c
                if ref == 44 --[[',']] or ref == 125 --[['}']] or ref == 93 --[[']']] or ref == 41 --[[')']] or ref == - 1 then
                  state = 9 --[[NumberState.Done]]
                  break
                else
                  if System.Char.IsWhiteSpace(System.toUInt16(c)) then
                    state = 9 --[[NumberState.Done]]
                  else
                    state = 10 --[[NumberState.Invalid]]
                  end
                  break
                end
              until 1
            else
              state = 10 --[[NumberState.Invalid]]
            end
            break
          end
        until 1

        repeat
          local ref = state
          if ref == 9 --[[NumberState.Done]] then
            buffer:UnRead(c)
            local lexeme = buffer:GetSubstring(start, buffer:getPosition() - start)
            if type == 10 --[[JsonTokenType.Double]] then
              local value = MongoDBBsonIO.JsonConvert.ToDouble(lexeme)
              return MongoDBBsonIO.DoubleJsonToken(lexeme, value)
            else
              local value = MongoDBBsonIO.JsonConvert.ToInt64(lexeme)
              if value < -2147483648 --[[Int32.MinValue]] or value > 2147483647 --[[Int32.MaxValue]] then
                return MongoDBBsonIO.Int64JsonToken(lexeme, value)
              else
                return MongoDBBsonIO.Int32JsonToken(lexeme, System.toInt32(value))
              end
            end
          elseif ref == 10 --[[NumberState.Invalid]] then
            System.throw(System.FormatException(FormatMessage("Invalid JSON number", buffer, start)))
          end
        until 1
      end
    end
    GetRegularExpressionToken = function (buffer)
      -- opening slash has already been read
      local start = buffer:getPosition() - 1
      local state = 0 --[[RegularExpressionState.InPattern]]
      while true do
        local c = buffer:Read()
        repeat
          local default = state
          if default == 0 --[[RegularExpressionState.InPattern]] then
            repeat
              local extern = c
              if extern == 47 --[['/']] then
                state = 2 --[[RegularExpressionState.InOptions]]
                break
              elseif extern == 92 --[['\\']] then
                state = 1 --[[RegularExpressionState.InEscapeSequence]]
                break
              else
                state = 0 --[[RegularExpressionState.InPattern]]
                break
              end
            until 1
            break
          elseif default == 1 --[[RegularExpressionState.InEscapeSequence]] then
            state = 0 --[[RegularExpressionState.InPattern]]
            break
          elseif default == 2 --[[RegularExpressionState.InOptions]] then
            repeat
              local extern = c
              if extern == 105 --[['i']] or extern == 109 --[['m']] or extern == 120 --[['x']] or extern == 115 --[['s']] then
                state = 2 --[[RegularExpressionState.InOptions]]
                break
              elseif extern == 44 --[[',']] or extern == 125 --[['}']] or extern == 93 --[[']']] or extern == 41 --[[')']] or extern == - 1 then
                state = 3 --[[RegularExpressionState.Done]]
                break
              else
                if System.Char.IsWhiteSpace(System.toUInt16(c)) then
                  state = 3 --[[RegularExpressionState.Done]]
                else
                  state = 4 --[[RegularExpressionState.Invalid]]
                end
                break
              end
            until 1
            break
          end
        until 1

        repeat
          local extern = state
          if extern == 3 --[[RegularExpressionState.Done]] then
            buffer:UnRead(c)
            local lexeme = buffer:GetSubstring(start, buffer:getPosition() - start)
            local regex = MongoDBBson.BsonRegularExpression(lexeme)
            return MongoDBBsonIO.RegularExpressionJsonToken(lexeme, regex)
          elseif extern == 4 --[[RegularExpressionState.Invalid]] then
            System.throw(System.FormatException(FormatMessage("Invalid JSON regular expression", buffer, start)))
          end
        until 1
      end
    end
    GetStringToken = function (buffer, quoteCharacter)
      -- opening quote has already been read
      local start = buffer:getPosition() - 1
      local sb = System.StringBuilder()
      while true do
        local c = buffer:Read()
        repeat
          local default = c
          if default == 92 --[['\\']] then
            c = buffer:Read()
            repeat
              local extern = c
              if extern == 39 --[['\'']] then
                sb:AppendChar(39 --[['\'']])
                break
              elseif extern == 34 --[['"']] then
                sb:AppendChar(34 --[['"']])
                break
              elseif extern == 92 --[['\\']] then
                sb:AppendChar(92 --[['\\']])
                break
              elseif extern == 47 --[['/']] then
                sb:AppendChar(47 --[['/']])
                break
              elseif extern == 98 --[['b']] then
                sb:AppendChar(8 --[['\b']])
                break
              elseif extern == 102 --[['f']] then
                sb:AppendChar(12 --[['\f']])
                break
              elseif extern == 110 --[['n']] then
                sb:AppendChar(10 --[['\n']])
                break
              elseif extern == 114 --[['r']] then
                sb:AppendChar(13 --[['\r']])
                break
              elseif extern == 116 --[['t']] then
                sb:AppendChar(9 --[['\t']])
                break
              elseif extern == 117 --[['u']] then
                local u1 = buffer:Read()
                local u2 = buffer:Read()
                local u3 = buffer:Read()
                local u4 = buffer:Read()
                if u4 ~= - 1 then
                  local hex = System.String(ArrayChar(System.toUInt16(u1), System.toUInt16(u2), System.toUInt16(u3), System.toUInt16(u4)))
                  local n = System.Convert.ToInt32(hex, 16)
                  sb:AppendChar(System.toUInt16(n))
                end
                break
              else
                if c ~= - 1 then
                  local message = System.String.Format("Invalid escape sequence in JSON string '\\{0}'.", System.toUInt16(c))
                  System.throw(System.FormatException(message))
                end
                break
              end
            until 1
            break
          else
            if c == quoteCharacter then
              local lexeme = buffer:GetSubstring(start, buffer:getPosition() - start)
              return MongoDBBsonIO.StringJsonToken(15 --[[JsonTokenType.String]], lexeme, sb:ToString())
            end
            if c ~= - 1 then
              sb:AppendChar(System.toUInt16(c))
            end
            break
          end
        until 1
        if c == - 1 then
          System.throw(System.FormatException(FormatMessage("End of file in JSON string.", buffer, start)))
        end
      end
    end
    GetUnquotedStringToken = function (buffer)
      -- opening letter or $ has already been read
      local start = buffer:getPosition() - 1
      local c = buffer:Read()
      while c == 36 --[['$']] or c == 95 --[['_']] or System.Char.IsLetterOrDigit(System.toUInt16(c)) do
        c = buffer:Read()
      end
      buffer:UnRead(c)
      local lexeme = buffer:GetSubstring(start, buffer:getPosition() - start)
      return MongoDBBsonIO.StringJsonToken(16 --[[JsonTokenType.UnquotedString]], lexeme, lexeme)
    end
    return {
      GetNextToken = GetNextToken
    }
  end)
end)
