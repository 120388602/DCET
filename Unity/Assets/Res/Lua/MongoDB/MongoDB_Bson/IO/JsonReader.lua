-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local SystemGlobalization = System.Globalization
local SystemRegularExpressions = System.Text.RegularExpressions
local ListInt64 = System.List(System.Int64)
local ArrayString = System.Array(System.String)
local ArrayArrayString = System.Array(ArrayString)
local MongoDBBson
local MongoDBBsonIO
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- Represents a BSON reader for a JSON string.
  -- </summary>
  namespace.class("JsonReader", function (namespace)
    local __variableLengthIso8601Formats, __fixedLengthIso8601Formats, Close, GetBookmark, IsAtEndOfFile, ReadBinaryData, ReadBoolean, ReadBsonType, 
    ReadBytes, ReadDateTime, ReadDecimal128, ReadDouble, ReadEndArray, ReadEndDocument, ReadInt32, ReadInt64, 
    ReadJavaScript, ReadJavaScriptWithScope, ReadMaxKey, ReadMinKey, ReadName, ReadNull, ReadObjectId, ReadRegularExpression, 
    ReadStartArray, ReadStartDocument, ReadString, ReadSymbol, ReadTimestamp, ReadUndefined, ReturnToBookmark, SkipName, 
    SkipValue, Dispose1, FormatInvalidTokenMessage, FormatJavaScriptDateTimeString, GetNextState, ParseBinDataConstructor, ParseBinDataExtendedJson, ParseHexDataConstructor, 
    ParseJavaScriptExtendedJson, ParseISODateTimeConstructor, ParseDateTimeExtendedJson, ParseDateTimeConstructor, ParseExtendedJson, ParseJavaScriptDateTimeString, ParseMaxKeyExtendedJson, ParseMinKeyExtendedJson, 
    ParseNew, ParseNumberConstructor, ParseNumberDecimalConstructor, ParseNumberLongConstructor, ParseNumberDecimalExtendedJson, ParseNumberIntExtendedJson, ParseNumberLongExtendedJson, ParseObjectIdConstructor, 
    ParseObjectIdExtendedJson, ParseRegularExpressionConstructor, ParseRegularExpressionExtendedJson, ParseSymbolExtendedJson, ParseTimestampConstructor, ParseTimestampExtendedJson, ParseTimestampExtendedJsonNewRepresentation, ParseTimestampExtendedJsonOldRepresentation, 
    ParseUndefinedExtendedJson, ParseUUIDConstructor, PopToken, PushToken, VerifyString, VerifyToken, static, __ctor1__, 
    __ctor2__, __ctor3__, __ctor4__, __ctor5__
    static = function (this)
      __variableLengthIso8601Formats = ArrayString("yyyy-MM-ddTHH:mm:ss.FFFFFFFK", "yyyy-MM-ddTHH:mm:ss.FFFFFFFzz", "yyyyMMddTHHmmss.FFFFFFFK", "yyyyMMddTHHmmss.FFFFFFFzz")
      __fixedLengthIso8601Formats = ArrayArrayString(nil, nil, nil, nil, ArrayString("yyyy"), nil, nil, ArrayString("yyyy-MM"), ArrayString("yyyyMMdd"), nil, ArrayString("yyyy-MM-dd"), ArrayString("yyyyMMddTHH"), ArrayString("yyyyMMddTHHZ"), ArrayString("yyyy-MM-ddTHH", "yyyyMMddTHHmm"), ArrayString("yyyy-MM-ddTHHZ", "yyyyMMddTHHmmZ", "yyyyMMddTHHzz"), nil, ArrayString("yyyy-MM-ddTHH:mm", "yyyy-MM-ddTHHzz", "yyyyMMddTHHmmssZ", "yyyyMMddTHHmmzz"), ArrayString("yyyy-MM-ddTHH:mmZ", "yyyyMMddTHHzzz"), ArrayString("yyyyMMddTHHmmsszz"), ArrayString("yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHHzzz", "yyyy-MM-ddTHH:mmzz", "yyyyMMddTHHmmzzz"), nil, nil, ArrayString("yyyy-MM-ddTHH:mmzzz", "yyyy-MM-ddTHH:mm:sszz"))
    end
    -- <summary>
    -- Initializes a new instance of the JsonReader class.
    -- </summary>
    __ctor1__ = function (this, json)
      __ctor2__(this, json, MongoDBBsonIO.JsonReaderSettings.getDefaults())
    end
    -- <summary>
    -- Initializes a new instance of the JsonReader class.
    -- </summary>
    -- <param name="settings">The reader settings.</param>
    __ctor2__ = function (this, json, settings)
      __ctor5__(this, MongoDBBsonIO.JsonBuffer(json), settings)
    end
    -- <summary>
    -- Initializes a new instance of the JsonReader class.
    -- </summary>
    __ctor3__ = function (this, textReader)
      __ctor4__(this, textReader, MongoDBBsonIO.JsonReaderSettings.getDefaults())
    end
    -- <summary>
    -- Initializes a new instance of the JsonReader class.
    -- </summary>
    -- <param name="settings">The reader settings.</param>
    __ctor4__ = function (this, textReader, settings)
      __ctor5__(this, System.new(MongoDBBsonIO.JsonBuffer, 2, textReader), settings)
    end
    __ctor5__ = function (this, buffer, settings)
      MongoDBBsonIO.BsonReader.__ctor__(this, settings)
      this._buffer = buffer
      this._jsonReaderSettings = settings
      -- already frozen by base class
      this._context = System.new(MongoDBBsonIO.JsonReaderContext, 2, nil, 0 --[[ContextType.TopLevel]])
    end
    -- <summary>
    -- Closes the reader.
    -- </summary>
    Close = function (this)
      -- Close can be called on Disposed objects
      this:setState(8 --[[BsonReaderState.Closed]])
    end
    -- <summary>
    -- Gets a bookmark to the reader's current position and state.
    -- </summary>
    GetBookmark = function (this)
      return MongoDBBsonIO.JsonReaderBookmark(this:getState(), this:getCurrentBsonType(), this:getCurrentName(), this._context, this._currentToken, this._currentValue, this._pushedToken, this._buffer:getPosition())
    end
    -- <summary>
    -- Determines whether this reader is at end of file.
    -- </summary>
    -- Whether this reader is at end of file.
    -- </returns>
    IsAtEndOfFile = function (this)
      local c
      while true do
        c = this._buffer:Read()
        if not (c ~= - 1) then
          break
        end
        if not System.Char.IsWhiteSpace(System.toUInt16(c)) then
          this._buffer:UnRead(c)
          return false
        end
      end
      return true
    end
    -- <summary>
    -- Reads BSON binary data from the reader.
    -- </summary>
    ReadBinaryData = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadBinaryData", 5 --[[BsonType.Binary]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsBsonBinaryData()
    end
    -- <summary>
    -- Reads a BSON boolean from the reader.
    -- </summary>
    ReadBoolean = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadBoolean", 8 --[[BsonType.Boolean]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsBoolean()
    end
    -- <summary>
    -- Reads a BsonType from the reader.
    -- </summary>
    ReadBsonType = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this:getState() == 0 --[[BsonReaderState.Initial]] or this:getState() == 4 --[[BsonReaderState.ScopeDocument]] then
        if this:getState() == 0 --[[BsonReaderState.Initial]] then
          this._buffer:ResetBuffer()
        end

        -- in JSON the top level value can be of any type so fall through
        this:setState(1 --[[BsonReaderState.Type]])
      end
      if this:getState() ~= 1 --[[BsonReaderState.Type]] then
        this:ThrowInvalidState("ReadBsonType", System.Array(System.Int32)(1 --[[BsonReaderState.Type]]))
      end

      if this._context:getContextType() == 1 --[[ContextType.Document]] then
        local nameToken = PopToken(this)
        repeat
          local default = nameToken:getType()
          if default == 15 --[[JsonTokenType.String]] or default == 16 --[[JsonTokenType.UnquotedString]] then
            this:setCurrentName(nameToken:getStringValue())
            break
          elseif default == 6 --[[JsonTokenType.EndObject]] then
            this:setState(5 --[[BsonReaderState.EndOfDocument]])
            return 0 --[[BsonType.EndOfDocument]]
          else
            local message = System.String.Format("JSON reader was expecting a name but found '{0}'.", nameToken:getLexeme())
            System.throw(System.FormatException(message))
          end
        until 1

        local colonToken = PopToken(this)
        if colonToken:getType() ~= 7 --[[JsonTokenType.Colon]] then
          local message = System.String.Format("JSON reader was expecting ':' but found '{0}'.", colonToken:getLexeme())
          System.throw(System.FormatException(message))
        end
      end

      local valueToken = PopToken(this)
      if this._context:getContextType() == 2 --[[ContextType.Array]] and valueToken:getType() == 3 --[[JsonTokenType.EndArray]] then
        this:setState(6 --[[BsonReaderState.EndOfArray]])
        return 0 --[[BsonType.EndOfDocument]]
      end

      local noValueFound = false
      repeat
        local default = valueToken:getType()
        if default == 1 --[[JsonTokenType.BeginArray]] then
          this:setCurrentBsonType(4 --[[BsonType.Array]])
          break
        elseif default == 2 --[[JsonTokenType.BeginObject]] then
          this:setCurrentBsonType(ParseExtendedJson(this))
          break
        elseif default == 9 --[[JsonTokenType.DateTime]] then
          this:setCurrentBsonType(9 --[[BsonType.DateTime]])
          this._currentValue = valueToken:getDateTimeValue()
          break
        elseif default == 10 --[[JsonTokenType.Double]] then
          this:setCurrentBsonType(1 --[[BsonType.Double]])
          this._currentValue = MongoDBBson.BsonValue.op_Implicit9(valueToken:getDoubleValue())
          break
        elseif default == 17 --[[JsonTokenType.EndOfFile]] then
          this:setCurrentBsonType(0 --[[BsonType.EndOfDocument]])
          break
        elseif default == 11 --[[JsonTokenType.Int32]] then
          this:setCurrentBsonType(16 --[[BsonType.Int32]])
          this._currentValue = MongoDBBson.BsonValue.op_Implicit14(valueToken:getInt32Value())
          break
        elseif default == 12 --[[JsonTokenType.Int64]] then
          this:setCurrentBsonType(18 --[[BsonType.Int64]])
          this._currentValue = MongoDBBson.BsonValue.op_Implicit16(valueToken:getInt64Value())
          break
        elseif default == 13 --[[JsonTokenType.ObjectId]] then
          this:setCurrentBsonType(7 --[[BsonType.ObjectId]])
          this._currentValue = MongoDBBson.BsonValue.op_Implicit18(valueToken:getObjectIdValue())
          break
        elseif default == 14 --[[JsonTokenType.RegularExpression]] then
          this:setCurrentBsonType(11 --[[BsonType.RegularExpression]])
          this._currentValue = valueToken:getRegularExpressionValue()
          break
        elseif default == 15 --[[JsonTokenType.String]] then
          this:setCurrentBsonType(2 --[[BsonType.String]])
          this._currentValue = MongoDBBson.BsonValue.op_Implicit21(valueToken:getStringValue())
          break
        elseif default == 16 --[[JsonTokenType.UnquotedString]] then
          repeat
            local extern = valueToken:getLexeme()
            if extern == "false" or extern == "true" then
              this:setCurrentBsonType(8 --[[BsonType.Boolean]])
              this._currentValue = MongoDBBson.BsonValue.op_Implicit(MongoDBBsonIO.JsonConvert.ToBoolean(valueToken:getLexeme()))
              break
            elseif extern == "Infinity" then
              this:setCurrentBsonType(1 --[[BsonType.Double]])
              this._currentValue = MongoDBBson.BsonValue.op_Implicit9(System.Double.PositiveInfinity)
              break
            elseif extern == "NaN" then
              this:setCurrentBsonType(1 --[[BsonType.Double]])
              this._currentValue = MongoDBBson.BsonValue.op_Implicit9(System.Double.NaN)
              break
            elseif extern == "null" then
              this:setCurrentBsonType(10 --[[BsonType.Null]])
              break
            elseif extern == "undefined" then
              this:setCurrentBsonType(6 --[[BsonType.Undefined]])
              break
            elseif extern == "BinData" then
              this:setCurrentBsonType(5 --[[BsonType.Binary]])
              this._currentValue = ParseBinDataConstructor(this)
              break
            elseif extern == "Date" then
              this:setCurrentBsonType(2 --[[BsonType.String]])
              this._currentValue = ParseDateTimeConstructor(this, false)
              break
            elseif extern == "HexData" then
              this:setCurrentBsonType(5 --[[BsonType.Binary]])
              this._currentValue = ParseHexDataConstructor(this)
              break
            elseif extern == "ISODate" then
              this:setCurrentBsonType(9 --[[BsonType.DateTime]])
              this._currentValue = ParseISODateTimeConstructor(this)
              break
            elseif extern == "MaxKey" then
              this:setCurrentBsonType(127 --[[BsonType.MaxKey]])
              this._currentValue = MongoDBBson.BsonMaxKey.getValue()
              break
            elseif extern == "MinKey" then
              this:setCurrentBsonType(255 --[[BsonType.MinKey]])
              this._currentValue = MongoDBBson.BsonMinKey.getValue()
              break
            elseif extern == "NumberDecimal" then
              this:setCurrentBsonType(19 --[[BsonType.Decimal128]])
              this._currentValue = ParseNumberDecimalConstructor(this)
              break
            elseif extern == "Number" or extern == "NumberInt" then
              this:setCurrentBsonType(16 --[[BsonType.Int32]])
              this._currentValue = ParseNumberConstructor(this)
              break
            elseif extern == "NumberLong" then
              this:setCurrentBsonType(18 --[[BsonType.Int64]])
              this._currentValue = ParseNumberLongConstructor(this)
              break
            elseif extern == "ObjectId" then
              this:setCurrentBsonType(7 --[[BsonType.ObjectId]])
              this._currentValue = ParseObjectIdConstructor(this)
              break
            elseif extern == "RegExp" then
              this:setCurrentBsonType(11 --[[BsonType.RegularExpression]])
              this._currentValue = ParseRegularExpressionConstructor(this)
              break
            elseif extern == "Timestamp" then
              this:setCurrentBsonType(17 --[[BsonType.Timestamp]])
              this._currentValue = ParseTimestampConstructor(this)
              break
            elseif extern == "UUID" or extern == "GUID" or extern == "CSUUID" or extern == "CSGUID" or extern == "JUUID" or extern == "JGUID" or extern == "PYUUID" or extern == "PYGUID" then
              this:setCurrentBsonType(5 --[[BsonType.Binary]])
              this._currentValue = ParseUUIDConstructor(this, valueToken:getLexeme())
              break
            elseif extern == "new" then
              local ref
              ref, this._currentValue = ParseNew(this)
              this:setCurrentBsonType(ref)
              break
            else
              noValueFound = true
              break
            end
          until 1
          break
        else
          noValueFound = true
          break
        end
      until 1
      if noValueFound then
        local message = System.String.Format("JSON reader was expecting a value but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      this._currentToken = valueToken

      if this._context:getContextType() == 2 --[[ContextType.Array]] or this._context:getContextType() == 1 --[[ContextType.Document]] then
        local commaToken = PopToken(this)
        if commaToken:getType() ~= 8 --[[JsonTokenType.Comma]] then
          PushToken(this, commaToken)
        end
      end

      repeat
        local extern = this._context:getContextType()
        if extern == 2 --[[ContextType.Array]] or extern == 3 --[[ContextType.JavaScriptWithScope]] or extern == 0 --[[ContextType.TopLevel]] then
          this:setState(3 --[[BsonReaderState.Value]])
          break
        else
          this:setState(2 --[[BsonReaderState.Name]])
          break
        end
      until 1
      return this:getCurrentBsonType()
    end
    -- <summary>
    -- Reads BSON binary data from the reader.
    -- </summary>
    ReadBytes = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadBinaryData", 5 --[[BsonType.Binary]])
      this:setState(GetNextState(this))
      local binaryData = this._currentValue:getAsBsonBinaryData()

      local subType = binaryData:getSubType()
      if subType ~= 0 --[[BsonBinarySubType.Binary]] and subType ~= 2 --[[BsonBinarySubType.OldBinary]] then
        local message = System.String.Format("ReadBytes requires the binary sub type to be Binary, not {0}.", subType)
        System.throw(System.FormatException(message))
      end

      return binaryData:getBytes()
    end
    -- <summary>
    -- Reads a BSON DateTime from the reader.
    -- </summary>
    ReadDateTime = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadDateTime", 9 --[[BsonType.DateTime]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsBsonDateTime():getMillisecondsSinceEpoch()
    end
    ReadDecimal128 = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadDecimal128" --[[nameof(ReadDecimal128)]], 19 --[[BsonType.Decimal128]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsDecimal128()
    end
    -- <summary>
    -- Reads a BSON Double from the reader.
    -- </summary>
    ReadDouble = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadDouble", 1 --[[BsonType.Double]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsDouble()
    end
    -- <summary>
    -- Reads the end of a BSON array from the reader.
    -- </summary>
    ReadEndArray = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this._context:getContextType() ~= 2 --[[ContextType.Array]] then
        this:ThrowInvalidContextType("ReadEndArray", this._context:getContextType(), System.Array(System.Int32)(2 --[[ContextType.Array]]))
      end
      if this:getState() == 1 --[[BsonReaderState.Type]] then
        this:ReadBsonType()
        -- will set state to EndOfArray if at end of array
      end
      if this:getState() ~= 6 --[[BsonReaderState.EndOfArray]] then
        this:ThrowInvalidState("ReadEndArray", System.Array(System.Int32)(6 --[[BsonReaderState.EndOfArray]]))
      end

      this._context = this._context:PopContext()
      repeat
        local default = this._context:getContextType()
        if default == 2 --[[ContextType.Array]] then
          this:setState(1 --[[BsonReaderState.Type]])
          break
        elseif default == 1 --[[ContextType.Document]] then
          this:setState(1 --[[BsonReaderState.Type]])
          break
        elseif default == 0 --[[ContextType.TopLevel]] then
          this:setState(0 --[[BsonReaderState.Initial]])
          break
        else
          System.throw(System.new(MongoDBBson.BsonInternalException, 2, "Unexpected ContextType."))
        end
      until 1

      if this._context:getContextType() == 2 --[[ContextType.Array]] or this._context:getContextType() == 1 --[[ContextType.Document]] then
        local commaToken = PopToken(this)
        if commaToken:getType() ~= 8 --[[JsonTokenType.Comma]] then
          PushToken(this, commaToken)
        end
      end
    end
    -- <summary>
    -- Reads the end of a BSON document from the reader.
    -- </summary>
    ReadEndDocument = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this._context:getContextType() ~= 1 --[[ContextType.Document]] and this._context:getContextType() ~= 4 --[[ContextType.ScopeDocument]] then
        this:ThrowInvalidContextType("ReadEndDocument", this._context:getContextType(), System.Array(System.Int32)(1 --[[ContextType.Document]], 4 --[[ContextType.ScopeDocument]]))
      end
      if this:getState() == 1 --[[BsonReaderState.Type]] then
        this:ReadBsonType()
        -- will set state to EndOfDocument if at end of document
      end
      if this:getState() ~= 5 --[[BsonReaderState.EndOfDocument]] then
        this:ThrowInvalidState("ReadEndDocument", System.Array(System.Int32)(5 --[[BsonReaderState.EndOfDocument]]))
      end

      this._context = this._context:PopContext()
      if this._context ~= nil and this._context:getContextType() == 3 --[[ContextType.JavaScriptWithScope]] then
        this._context = this._context:PopContext()
        -- JavaScriptWithScope
        VerifyToken(this, "}")
        -- outermost closing bracket for JavaScriptWithScope
      end
      repeat
        local default = this._context:getContextType()
        if default == 2 --[[ContextType.Array]] then
          this:setState(1 --[[BsonReaderState.Type]])
          break
        elseif default == 1 --[[ContextType.Document]] then
          this:setState(1 --[[BsonReaderState.Type]])
          break
        elseif default == 0 --[[ContextType.TopLevel]] then
          this:setState(0 --[[BsonReaderState.Initial]])
          break
        else
          System.throw(System.new(MongoDBBson.BsonInternalException, 2, "Unexpected ContextType"))
        end
      until 1

      if this._context:getContextType() == 2 --[[ContextType.Array]] or this._context:getContextType() == 1 --[[ContextType.Document]] then
        local commaToken = PopToken(this)
        if commaToken:getType() ~= 8 --[[JsonTokenType.Comma]] then
          PushToken(this, commaToken)
        end
      end
    end
    -- <summary>
    -- Reads a BSON Int32 from the reader.
    -- </summary>
    ReadInt32 = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadInt32", 16 --[[BsonType.Int32]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsInt32()
    end
    -- <summary>
    -- Reads a BSON Int64 from the reader.
    -- </summary>
    ReadInt64 = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadInt64", 18 --[[BsonType.Int64]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsInt64()
    end
    -- <summary>
    -- Reads a BSON JavaScript from the reader.
    -- </summary>
    ReadJavaScript = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadJavaScript", 13 --[[BsonType.JavaScript]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsString()
    end
    -- <summary>
    -- Reads a BSON JavaScript with scope from the reader (call ReadStartDocument next to read the scope).
    -- </summary>
    ReadJavaScriptWithScope = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadJavaScriptWithScope", 15 --[[BsonType.JavaScriptWithScope]])
      this._context = System.new(MongoDBBsonIO.JsonReaderContext, 2, this._context, 3 --[[ContextType.JavaScriptWithScope]])
      this:setState(4 --[[BsonReaderState.ScopeDocument]])
      return this._currentValue:getAsString()
    end
    -- <summary>
    -- Reads a BSON MaxKey from the reader.
    -- </summary>
    ReadMaxKey = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadMaxKey", 127 --[[BsonType.MaxKey]])
      this:setState(GetNextState(this))
    end
    -- <summary>
    -- Reads a BSON MinKey from the reader.
    -- </summary>
    ReadMinKey = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadMinKey", 255 --[[BsonType.MinKey]])
      this:setState(GetNextState(this))
    end
    -- <summary>
    -- Reads the name of an element from the reader.
    -- </summary>
    -- <returns>
    -- The name of the element.
    -- </returns>
    ReadName = function (this, nameDecoder)
      if nameDecoder == nil then
        System.throw(System.ArgumentNullException("nameDecoder"))
      end

      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this:getState() == 1 --[[BsonReaderState.Type]] then
        this:ReadBsonType()
      end
      if this:getState() ~= 2 --[[BsonReaderState.Name]] then
        this:ThrowInvalidState("ReadName", System.Array(System.Int32)(2 --[[BsonReaderState.Name]]))
      end

      nameDecoder:Inform(this:getCurrentName())
      this:setState(3 --[[BsonReaderState.Value]])
      return this:getCurrentName()
    end
    -- <summary>
    -- Reads a BSON null from the reader.
    -- </summary>
    ReadNull = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadNull", 10 --[[BsonType.Null]])
      this:setState(GetNextState(this))
    end
    -- <summary>
    -- Reads a BSON ObjectId from the reader.
    -- </summary>
    ReadObjectId = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadObjectId", 7 --[[BsonType.ObjectId]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsObjectId()
    end
    -- <summary>
    -- Reads a BSON regular expression from the reader.
    -- </summary>
    ReadRegularExpression = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadRegularExpression", 11 --[[BsonType.RegularExpression]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsBsonRegularExpression()
    end
    -- <summary>
    -- Reads the start of a BSON array.
    -- </summary>
    ReadStartArray = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadStartArray", 4 --[[BsonType.Array]])

      this._context = System.new(MongoDBBsonIO.JsonReaderContext, 2, this._context, 2 --[[ContextType.Array]])
      this:setState(1 --[[BsonReaderState.Type]])
    end
    -- <summary>
    -- Reads the start of a BSON document.
    -- </summary>
    ReadStartDocument = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadStartDocument", 3 --[[BsonType.Document]])

      this._context = System.new(MongoDBBsonIO.JsonReaderContext, 2, this._context, 1 --[[ContextType.Document]])
      this:setState(1 --[[BsonReaderState.Type]])
    end
    -- <summary>
    -- Reads a BSON string from the reader.
    -- </summary>
    ReadString = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadString", 2 --[[BsonType.String]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsString()
    end
    -- <summary>
    -- Reads a BSON symbol from the reader.
    -- </summary>
    ReadSymbol = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadSymbol", 14 --[[BsonType.Symbol]])
      this:setState(GetNextState(this))
      return this._currentValue:getAsString()
    end
    -- <summary>
    -- Reads a BSON timestamp from the reader.
    -- </summary>
    ReadTimestamp = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadTimestamp", 17 --[[BsonType.Timestamp]])
      this:setState(GetNextState(this))
      local timestamp = this._currentValue:getAsBsonTimestamp()
      return timestamp:getValue()
    end
    -- <summary>
    -- Reads a BSON undefined from the reader.
    -- </summary>
    ReadUndefined = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      this:VerifyBsonType("ReadUndefined", 6 --[[BsonType.Undefined]])
      this:setState(GetNextState(this))
    end
    -- <summary>
    -- Returns the reader to previously bookmarked position and state.
    -- </summary>
    ReturnToBookmark = function (this, bookmark)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      local jsonReaderBookmark = System.cast(MongoDBBsonIO.JsonReaderBookmark, bookmark)
      this:setState(jsonReaderBookmark:getState())
      this:setCurrentBsonType(jsonReaderBookmark:getCurrentBsonType())
      this:setCurrentName(jsonReaderBookmark:getCurrentName())
      this._context = jsonReaderBookmark:CloneContext()
      this._currentToken = jsonReaderBookmark:getCurrentToken()
      this._currentValue = jsonReaderBookmark:getCurrentValue()
      this._pushedToken = jsonReaderBookmark:getPushedToken()
      this._buffer:setPosition(jsonReaderBookmark:getPosition())
    end
    -- <summary>
    -- Skips the name (reader must be positioned on a name).
    -- </summary>
    SkipName = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this:getState() ~= 2 --[[BsonReaderState.Name]] then
        this:ThrowInvalidState("SkipName", System.Array(System.Int32)(2 --[[BsonReaderState.Name]]))
      end

      this:setState(3 --[[BsonReaderState.Value]])
    end
    -- <summary>
    -- Skips the value (reader must be positioned on a value).
    -- </summary>
    SkipValue = function (this)
      if this:getDisposed() then
        this:ThrowObjectDisposedException()
      end
      if this:getState() ~= 3 --[[BsonReaderState.Value]] then
        this:ThrowInvalidState("SkipValue", System.Array(System.Int32)(3 --[[BsonReaderState.Value]]))
      end

      repeat
        local default = this:getCurrentBsonType()
        if default == 4 --[[BsonType.Array]] then
          this:ReadStartArray()
          while this:ReadBsonType() ~= 0 --[[BsonType.EndOfDocument]] do
            this:SkipValue()
          end
          this:ReadEndArray()
          break
        elseif default == 5 --[[BsonType.Binary]] then
          this:ReadBinaryData()
          break
        elseif default == 8 --[[BsonType.Boolean]] then
          this:ReadBoolean()
          break
        elseif default == 9 --[[BsonType.DateTime]] then
          this:ReadDateTime()
          break
        elseif default == 3 --[[BsonType.Document]] then
          this:ReadStartDocument()
          while this:ReadBsonType() ~= 0 --[[BsonType.EndOfDocument]] do
            this:SkipName()
            this:SkipValue()
          end
          this:ReadEndDocument()
          break
        elseif default == 1 --[[BsonType.Double]] then
          this:ReadDouble()
          break
        elseif default == 16 --[[BsonType.Int32]] then
          this:ReadInt32()
          break
        elseif default == 18 --[[BsonType.Int64]] then
          this:ReadInt64()
          break
        elseif default == 13 --[[BsonType.JavaScript]] then
          this:ReadJavaScript()
          break
        elseif default == 15 --[[BsonType.JavaScriptWithScope]] then
          this:ReadJavaScriptWithScope()
          this:ReadStartDocument()
          while this:ReadBsonType() ~= 0 --[[BsonType.EndOfDocument]] do
            this:SkipName()
            this:SkipValue()
          end
          this:ReadEndDocument()
          break
        elseif default == 127 --[[BsonType.MaxKey]] then
          this:ReadMaxKey()
          break
        elseif default == 255 --[[BsonType.MinKey]] then
          this:ReadMinKey()
          break
        elseif default == 10 --[[BsonType.Null]] then
          this:ReadNull()
          break
        elseif default == 7 --[[BsonType.ObjectId]] then
          this:ReadObjectId()
          break
        elseif default == 11 --[[BsonType.RegularExpression]] then
          this:ReadRegularExpression()
          break
        elseif default == 2 --[[BsonType.String]] then
          this:ReadString()
          break
        elseif default == 14 --[[BsonType.Symbol]] then
          this:ReadSymbol()
          break
        elseif default == 17 --[[BsonType.Timestamp]] then
          this:ReadTimestamp()
          break
        elseif default == 6 --[[BsonType.Undefined]] then
          this:ReadUndefined()
          break
        else
          System.throw(System.new(MongoDBBson.BsonInternalException, 2, "Invalid BsonType."))
        end
      until 1
    end
    -- <summary>
    -- Disposes of any resources used by the reader.
    -- </summary>
    Dispose1 = function (this, disposing)
      if disposing then
        System.try(function ()
          this:Close()
        end, function (default)
        end)
        -- ignore exceptions
      end
      MongoDBBsonIO.BsonReader.Dispose1(this, disposing)
    end
    FormatInvalidTokenMessage = function (this, token)
      return System.String.Format("Invalid JSON token: '{0}'", token:getLexeme())
    end
    FormatJavaScriptDateTimeString = function (this, dateTime)
      local utc = MongoDBBson.BsonUtils.ToUniversalTime(dateTime)
      local local_ = MongoDBBson.BsonUtils.ToLocalTime(utc)
      local offset = local_ - utc
      local offsetSign = "+"
      if offset < System.TimeSpan.Zero then
        offset = -offset
        offsetSign = "-"
      end
      local timeZone = System.TimeZoneInfo.getLocal()
      local default
      if local_:IsDaylightSavingTime() then
        default = timeZone:getDaylightName()
      else
        default = timeZone:getStandardName()
      end
      local timeZoneName = default
      local dateTimeString = System.String.Format("{0} GMT{1}{2:D2}{3:D2} ({4})", local_:ToString("ddd MMM dd yyyy HH:mm:ss"), offsetSign, offset:getHours(), offset:getMinutes(), timeZoneName)
      return dateTimeString
    end
    GetNextState = function (this)
      repeat
        local default = this._context:getContextType()
        if default == 2 --[[ContextType.Array]] or default == 1 --[[ContextType.Document]] then
          return 1 --[[BsonReaderState.Type]]
        elseif default == 0 --[[ContextType.TopLevel]] then
          return 0 --[[BsonReaderState.Initial]]
        else
          System.throw(System.new(MongoDBBson.BsonInternalException, 2, "Unexpected ContextType."))
        end
      until 1
    end
    ParseBinDataConstructor = function (this)
      VerifyToken(this, "(")
      local subTypeToken = PopToken(this)
      if subTypeToken:getType() ~= 11 --[[JsonTokenType.Int32]] then
        local message = System.String.Format("JSON reader expected a binary subtype but found '{0}'.", subTypeToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ",")
      local bytesToken = PopToken(this)
      if bytesToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", bytesToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      local bytes = System.Convert.FromBase64String(bytesToken:getStringValue())
      local subType = subTypeToken:getInt32Value()
      local guidRepresentation
      repeat
        local default = subType
        if default == 3 --[[BsonBinarySubType.UuidLegacy]] then
          guidRepresentation = this._jsonReaderSettings:getGuidRepresentation()
          break
        elseif default == 4 --[[BsonBinarySubType.UuidStandard]] then
          guidRepresentation = 1 --[[GuidRepresentation.Standard]]
          break
        else
          guidRepresentation = 0 --[[GuidRepresentation.Unspecified]]
          break
        end
      until 1
      return System.new(MongoDBBson.BsonBinaryData, 3, bytes, subType, guidRepresentation)
    end
    ParseBinDataExtendedJson = function (this)
      VerifyToken(this, ":")

      local bytesToken = PopToken(this)
      if bytesToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", bytesToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      local bytes = System.Convert.FromBase64String(bytesToken:getStringValue())

      VerifyToken(this, ",")
      VerifyString(this, "$type")
      VerifyToken(this, ":")

      local subType
      local subTypeToken = PopToken(this)
      if subTypeToken:getType() == 15 --[[JsonTokenType.String]] then
        subType = System.Convert.ToInt32(subTypeToken:getStringValue(), 16)
      elseif subTypeToken:getType() == 11 --[[JsonTokenType.Int32]] or subTypeToken:getType() == 12 --[[JsonTokenType.Int64]] then
        subType = subTypeToken:getInt32Value()
      else
        local message = System.String.Format("JSON reader expected a string or integer but found '{0}'.", subTypeToken:getLexeme())
        System.throw(System.FormatException(message))
      end

      VerifyToken(this, "}")

      local guidRepresentation
      repeat
        local default = subType
        if default == 3 --[[BsonBinarySubType.UuidLegacy]] then
          guidRepresentation = this._jsonReaderSettings:getGuidRepresentation()
          break
        elseif default == 4 --[[BsonBinarySubType.UuidStandard]] then
          guidRepresentation = 1 --[[GuidRepresentation.Standard]]
          break
        else
          guidRepresentation = 0 --[[GuidRepresentation.Unspecified]]
          break
        end
      until 1

      return System.new(MongoDBBson.BsonBinaryData, 3, bytes, subType, guidRepresentation)
    end
    ParseHexDataConstructor = function (this)
      VerifyToken(this, "(")
      local subTypeToken = PopToken(this)
      if subTypeToken:getType() ~= 11 --[[JsonTokenType.Int32]] then
        local message = System.String.Format("JSON reader expected a binary subtype but found '{0}'.", subTypeToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ",")
      local bytesToken = PopToken(this)
      if bytesToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", bytesToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      local bytes = MongoDBBson.BsonUtils.ParseHexString(bytesToken:getStringValue())
      local subType = subTypeToken:getInt32Value()
      local guidRepresentation
      repeat
        local default = subType
        if default == 3 --[[BsonBinarySubType.UuidLegacy]] then
          guidRepresentation = this._jsonReaderSettings:getGuidRepresentation()
          break
        elseif default == 4 --[[BsonBinarySubType.UuidStandard]] then
          guidRepresentation = 1 --[[GuidRepresentation.Standard]]
          break
        else
          guidRepresentation = 0 --[[GuidRepresentation.Unspecified]]
          break
        end
      until 1
      return System.new(MongoDBBson.BsonBinaryData, 3, bytes, subType, guidRepresentation)
    end
    ParseJavaScriptExtendedJson = function (this, value)
      VerifyToken(this, ":")
      local codeToken = PopToken(this)
      if codeToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", codeToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      local nextToken = PopToken(this)
      repeat
        local default = nextToken:getType()
        if default == 8 --[[JsonTokenType.Comma]] then
          VerifyString(this, "$scope")
          VerifyToken(this, ":")
          this:setState(3 --[[BsonReaderState.Value]])
          value = MongoDBBson.BsonValue.op_Implicit21(codeToken:getStringValue())
          return 15 --[[BsonType.JavaScriptWithScope]], value
        elseif default == 6 --[[JsonTokenType.EndObject]] then
          value = MongoDBBson.BsonValue.op_Implicit21(codeToken:getStringValue())
          return 13 --[[BsonType.JavaScript]], value
        else
          local message = System.String.Format("JSON reader expected ',' or '}}' but found '{0}'.", codeToken:getLexeme())
          System.throw(System.FormatException(message))
        end
      until 1
    end
    ParseISODateTimeConstructor = function (this)
      VerifyToken(this, "(")
      local valueToken = PopToken(this)
      if valueToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      local value = valueToken:getStringValue()
      local formats = nil
      if not value:Contains(".") and #value < #__fixedLengthIso8601Formats then
        formats = __fixedLengthIso8601Formats:get(#value)
      end
      if formats == nil then
        formats = __variableLengthIso8601Formats
      end
      local utcDateTime = System.DateTime.ParseExact(value, formats, nil, 80 --[[DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal]])
      return MongoDBBson.BsonDateTime(utcDateTime)
    end
    ParseDateTimeExtendedJson = function (this)
      VerifyToken(this, ":")
      local valueToken = PopToken(this)

      local millisecondsSinceEpoch
      if valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        millisecondsSinceEpoch = valueToken:getInt64Value()
      elseif valueToken:getType() == 15 --[[JsonTokenType.String]] then
        local dateTime
        local dateTimeStyles = 80 --[[DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal]]
        local default
        default, dateTime = System.DateTime.TryParse(valueToken:getStringValue(), SystemGlobalization.CultureInfo.getInvariantCulture(), dateTimeStyles, nil)
        if not default then
          local message = System.String.Format("Invalid $date string: '{0}'.", valueToken:getStringValue())
          System.throw(System.FormatException(message))
        end
        millisecondsSinceEpoch = MongoDBBson.BsonUtils.ToMillisecondsSinceEpoch(dateTime)
      elseif valueToken:getType() == 2 --[[JsonTokenType.BeginObject]] then
        VerifyToken(this, "$numberLong")
        VerifyToken(this, ":")
        local millisecondsSinceEpochToken = PopToken(this)
        if millisecondsSinceEpochToken:getType() == 15 --[[JsonTokenType.String]] then
          millisecondsSinceEpoch = System.Int64.Parse(millisecondsSinceEpochToken:getStringValue(), SystemGlobalization.CultureInfo.getInvariantCulture())
        elseif millisecondsSinceEpochToken:getType() == 11 --[[JsonTokenType.Int32]] or millisecondsSinceEpochToken:getType() == 12 --[[JsonTokenType.Int64]] then
          millisecondsSinceEpoch = millisecondsSinceEpochToken:getInt64Value()
        else
          local message = System.String.Format("JSON reader expected an integer or a string for {{ $date : {{ $numberLong : ... }} }} but found a '{0}'.", valueToken:getLexeme())
          System.throw(System.FormatException(message))
        end
        VerifyToken(this, "}")
      else
        local message = System.String.Format("JSON reader expected an ISO 8601 string, an integer, or {{ $numberLong : ... }} for $date but found a '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end

      VerifyToken(this, "}")
      return System.new(MongoDBBson.BsonDateTime, 2, millisecondsSinceEpoch)
    end
    ParseDateTimeConstructor = function (this, withNew)
      VerifyToken(this, "(")

      -- Date when used without "new" behaves differently (JavaScript has some weird parts)
      if not withNew then
        VerifyToken(this, ")")
        local dateTimeString = FormatJavaScriptDateTimeString(this, System.DateTime.getUtcNow())
        return MongoDBBson.BsonString(dateTimeString)
      end

      local token = PopToken(this)
      if token:getLexeme() == ")" then
        return MongoDBBson.BsonDateTime(System.DateTime.getUtcNow())
      elseif token:getType() == 15 --[[JsonTokenType.String]] then
        VerifyToken(this, ")")
        local dateTimeString = token:getStringValue()
        local dateTime = ParseJavaScriptDateTimeString(this, dateTimeString)
        return MongoDBBson.BsonDateTime(dateTime)
      elseif token:getType() == 11 --[[JsonTokenType.Int32]] or token:getType() == 12 --[[JsonTokenType.Int64]] then
        local args = ListInt64()
        while true do
          args:Add(token:getInt64Value())
          token = PopToken(this)
          if token:getLexeme() == ")" then
            break
          end
          if token:getLexeme() ~= "," then
            local message = System.String.Format("JSON reader expected a ',' or a ')' but found '{0}'.", token:getLexeme())
            System.throw(System.FormatException(message))
          end
          token = PopToken(this)
          if token:getType() ~= 11 --[[JsonTokenType.Int32]] and token:getType() ~= 12 --[[JsonTokenType.Int64]] then
            local message = System.String.Format("JSON reader expected an integer but found '{0}'.", token:getLexeme())
            System.throw(System.FormatException(message))
          end
        end
        repeat
          local default = #args
          if default == 1 then
            return System.new(MongoDBBson.BsonDateTime, 2, args:get(0))
          elseif default == 3 or default == 4 or default == 5 or default == 6 or default == 7 then
            local year = System.toInt32(args:get(0))
            local month = System.toInt32(args:get(1)) + 1
            local day = System.toInt32(args:get(2))
            local hours = (#args >= 4) and System.toInt32(args:get(3)) or 0
            local minutes = (#args >= 5) and System.toInt32(args:get(4)) or 0
            local seconds = (#args >= 6) and System.toInt32(args:get(5)) or 0
            local milliseconds = (#args == 7) and System.toInt32(args:get(6)) or 0
            local dateTime = System.DateTime(year, month, day, hours, minutes, seconds, milliseconds, 1 --[[DateTimeKind.Utc]])
            return MongoDBBson.BsonDateTime(dateTime)
          else
            local message = System.String.Format("JSON reader expected 1 or 3-7 integers but found {0}.", #args)
            System.throw(System.FormatException(message))
          end
        until 1
      else
        local message = System.String.Format("JSON reader expected an integer or a string but found '{0}'.", token:getLexeme())
        System.throw(System.FormatException(message))
      end
    end
    ParseExtendedJson = function (this)
      local nameToken = PopToken(this)
      if nameToken:getType() == 15 --[[JsonTokenType.String]] or nameToken:getType() == 16 --[[JsonTokenType.UnquotedString]] then
        repeat
          local default = nameToken:getStringValue()
          if default == "$binary" then
            this._currentValue = ParseBinDataExtendedJson(this)
            return 5 --[[BsonType.Binary]]
          elseif default == "$code" then
            local extern
            extern, this._currentValue = ParseJavaScriptExtendedJson(this)
            return extern
          elseif default == "$date" then
            this._currentValue = ParseDateTimeExtendedJson(this)
            return 9 --[[BsonType.DateTime]]
          elseif default == "$maxkey" or default == "$maxKey" then
            this._currentValue = ParseMaxKeyExtendedJson(this)
            return 127 --[[BsonType.MaxKey]]
          elseif default == "$minkey" or default == "$minKey" then
            this._currentValue = ParseMinKeyExtendedJson(this)
            return 255 --[[BsonType.MinKey]]
          elseif default == "$numberDecimal" then
            this._currentValue = ParseNumberDecimalExtendedJson(this)
            return 19 --[[BsonType.Decimal128]]
          elseif default == "$numberInt" then
            this._currentValue = ParseNumberIntExtendedJson(this)
            return 16 --[[BsonType.Int32]]
          elseif default == "$numberLong" then
            this._currentValue = ParseNumberLongExtendedJson(this)
            return 18 --[[BsonType.Int64]]
          elseif default == "$oid" then
            this._currentValue = ParseObjectIdExtendedJson(this)
            return 7 --[[BsonType.ObjectId]]
          elseif default == "$regex" then
            this._currentValue = ParseRegularExpressionExtendedJson(this)
            return 11 --[[BsonType.RegularExpression]]
          elseif default == "$symbol" then
            this._currentValue = ParseSymbolExtendedJson(this)
            return 14 --[[BsonType.Symbol]]
          elseif default == "$timestamp" then
            this._currentValue = ParseTimestampExtendedJson(this)
            return 17 --[[BsonType.Timestamp]]
          elseif default == "$undefined" then
            this._currentValue = ParseUndefinedExtendedJson(this)
            return 6 --[[BsonType.Undefined]]
          end
        until 1
      end
      PushToken(this, nameToken)
      return 3 --[[BsonType.Document]]
    end
    ParseJavaScriptDateTimeString = function (this, dateTimeString)
      -- if DateTime.TryParse succeeds we're done, otherwise assume it's an RFC 822 formatted DateTime string
      local dateTime
      local default
      default, dateTime = System.DateTime.TryParse(dateTimeString, nil)
      if default then
        return dateTime
      else
        local rfc822DateTimePattern = "^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun)), )?(?<day>\\d{1,2}) +(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (?<year>\\d{2}|\\d{4}) (?<hour>\\d{1,2}):(?<minutes>\\d{1,2}):(?<seconds>\\d{1,2}(.\\d{1,7})?) (?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\\d{4}))$" --[[@"^((?<dayOfWeek>(Mon|Tue|Wed|Thu|Fri|Sat|Sun)), )?" +
                    @"(?<day>\d{1,2}) +" +
                    @"(?<monthName>Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) " +
                    @"(?<year>\d{2}|\d{4}) " +
                    @"(?<hour>\d{1,2}):" +
                    @"(?<minutes>\d{1,2}):" +
                    @"(?<seconds>\d{1,2}(.\d{1,7})?) " +
                    @"(?<zone>UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-Z]|([+-]\d{4}))$"]]
        local match = SystemRegularExpressions.Regex.Match(dateTimeString, rfc822DateTimePattern)
        if match:getSuccess() then
          local day = System.Int32.Parse(match:getGroups():get("day"):getValue())

          local month
          local monthName = match:getGroups():get("monthName"):getValue()
          repeat
            local extern = monthName
            if extern == "Jan" then
              month = 1
              break
            elseif extern == "Feb" then
              month = 2
              break
            elseif extern == "Mar" then
              month = 3
              break
            elseif extern == "Apr" then
              month = 4
              break
            elseif extern == "May" then
              month = 5
              break
            elseif extern == "Jun" then
              month = 6
              break
            elseif extern == "Jul" then
              month = 7
              break
            elseif extern == "Aug" then
              month = 8
              break
            elseif extern == "Sep" then
              month = 9
              break
            elseif extern == "Oct" then
              month = 10
              break
            elseif extern == "Nov" then
              month = 11
              break
            elseif extern == "Dec" then
              month = 12
              break
            else
              local message = System.String.Format("\"{0}\" is not a valid RFC 822 month name.", monthName)
              System.throw(System.FormatException(message))
            end
          until 1

          local yearString = match:getGroups():get("year"):getValue()
          local year = System.Int32.Parse(yearString)
          if #yearString == 2 then
            year = year + 2000
            if year - System.DateTime.getUtcNow():getYear() >= 19 then
              year = year - 100
            end
          end

          local hour = System.Int32.Parse(match:getGroups():get("hour"):getValue())
          local minutes = System.Int32.Parse(match:getGroups():get("minutes"):getValue())
          local secondsString = match:getGroups():get("seconds"):getValue()
          local seconds
          local milliseconds
          if secondsString:IndexOf(46 --[['.']]) ~= - 1 then
            local timeSpan = System.TimeSpan.FromSeconds(System.Double.Parse(secondsString))
            seconds = timeSpan:getSeconds()
            milliseconds = timeSpan:getTotalMilliseconds() - seconds * 1000
          else
            seconds = System.Int32.Parse(secondsString)
            milliseconds = 0
          end

          dateTime = System.DateTime(year, month, day, hour, minutes, seconds, 0, 1 --[[DateTimeKind.Utc]]):AddMilliseconds(milliseconds)

          -- check day of week before converting to UTC
          local dayOfWeekString = match:getGroups():get("dayOfWeek"):getValue()
          if dayOfWeekString ~= "" then
            local dayOfWeek
            repeat
              local ref = dayOfWeekString
              if ref == "Mon" then
                dayOfWeek = 1 --[[DayOfWeek.Monday]]
                break
              elseif ref == "Tue" then
                dayOfWeek = 2 --[[DayOfWeek.Tuesday]]
                break
              elseif ref == "Wed" then
                dayOfWeek = 3 --[[DayOfWeek.Wednesday]]
                break
              elseif ref == "Thu" then
                dayOfWeek = 4 --[[DayOfWeek.Thursday]]
                break
              elseif ref == "Fri" then
                dayOfWeek = 5 --[[DayOfWeek.Friday]]
                break
              elseif ref == "Sat" then
                dayOfWeek = 6 --[[DayOfWeek.Saturday]]
                break
              elseif ref == "Sun" then
                dayOfWeek = 0 --[[DayOfWeek.Sunday]]
                break
              else
                local message = System.String.Format("\"{0}\" is not a valid RFC 822 day name.", dayOfWeekString)
                System.throw(System.FormatException(message))
              end
            until 1
            if dateTime:getDayOfWeek() ~= dayOfWeek then
              local message = System.String.Format("\"{0}\" is not the right day of the week for {1}.", dayOfWeekString, dateTime:ToString("o"))
              System.throw(System.FormatException(message))
            end
          end

          local offset
          local zone = match:getGroups():get("zone"):getValue()
          repeat
            local ref = zone
            if ref == "UT" or ref == "GMT" or ref == "Z" then
              offset = System.TimeSpan.Zero
              break
            elseif ref == "EST" then
              offset = System.TimeSpan.FromHours(- 5)
              break
            elseif ref == "EDT" then
              offset = System.TimeSpan.FromHours(- 4)
              break
            elseif ref == "CST" then
              offset = System.TimeSpan.FromHours(- 6)
              break
            elseif ref == "CDT" then
              offset = System.TimeSpan.FromHours(- 5)
              break
            elseif ref == "MST" then
              offset = System.TimeSpan.FromHours(- 7)
              break
            elseif ref == "MDT" then
              offset = System.TimeSpan.FromHours(- 6)
              break
            elseif ref == "PST" then
              offset = System.TimeSpan.FromHours(- 8)
              break
            elseif ref == "PDT" then
              offset = System.TimeSpan.FromHours(- 7)
              break
            elseif ref == "A" then
              offset = System.TimeSpan.FromHours(- 1)
              break
            elseif ref == "B" then
              offset = System.TimeSpan.FromHours(- 2)
              break
            elseif ref == "C" then
              offset = System.TimeSpan.FromHours(- 3)
              break
            elseif ref == "D" then
              offset = System.TimeSpan.FromHours(- 4)
              break
            elseif ref == "E" then
              offset = System.TimeSpan.FromHours(- 5)
              break
            elseif ref == "F" then
              offset = System.TimeSpan.FromHours(- 6)
              break
            elseif ref == "G" then
              offset = System.TimeSpan.FromHours(- 7)
              break
            elseif ref == "H" then
              offset = System.TimeSpan.FromHours(- 8)
              break
            elseif ref == "I" then
              offset = System.TimeSpan.FromHours(- 9)
              break
            elseif ref == "K" then
              offset = System.TimeSpan.FromHours(- 10)
              break
            elseif ref == "L" then
              offset = System.TimeSpan.FromHours(- 11)
              break
            elseif ref == "M" then
              offset = System.TimeSpan.FromHours(- 12)
              break
            elseif ref == "N" then
              offset = System.TimeSpan.FromHours(1)
              break
            elseif ref == "O" then
              offset = System.TimeSpan.FromHours(2)
              break
            elseif ref == "P" then
              offset = System.TimeSpan.FromHours(3)
              break
            elseif ref == "Q" then
              offset = System.TimeSpan.FromHours(4)
              break
            elseif ref == "R" then
              offset = System.TimeSpan.FromHours(5)
              break
            elseif ref == "S" then
              offset = System.TimeSpan.FromHours(6)
              break
            elseif ref == "T" then
              offset = System.TimeSpan.FromHours(7)
              break
            elseif ref == "U" then
              offset = System.TimeSpan.FromHours(8)
              break
            elseif ref == "V" then
              offset = System.TimeSpan.FromHours(9)
              break
            elseif ref == "W" then
              offset = System.TimeSpan.FromHours(10)
              break
            elseif ref == "X" then
              offset = System.TimeSpan.FromHours(11)
              break
            elseif ref == "Y" then
              offset = System.TimeSpan.FromHours(12)
              break
            else
              local offsetSign = zone:Substring(0)
              local offsetHours = zone:Substring(1, 2)
              local offsetMinutes = zone:Substring(3, 2)
              offset = System.TimeSpan.FromHours(System.Int32.Parse(offsetHours)) + System.TimeSpan.FromMinutes(System.Int32.Parse(offsetMinutes))
              if offsetSign == "-" then
                offset = -offset
              end
              break
            end
          until 1

          return dateTime:Add(-offset)
        else
          local message = System.String.Format("The DateTime string \"{0}\" is not a valid DateTime string for either .NET or JavaScript.", dateTimeString)
          System.throw(System.FormatException(message))
        end
      end
    end
    ParseMaxKeyExtendedJson = function (this)
      VerifyToken(this, ":")
      VerifyToken(this, "1")
      VerifyToken(this, "}")
      return MongoDBBson.BsonMaxKey.getValue()
    end
    ParseMinKeyExtendedJson = function (this)
      VerifyToken(this, ":")
      VerifyToken(this, "1")
      VerifyToken(this, "}")
      return MongoDBBson.BsonMinKey.getValue()
    end
    ParseNew = function (this, value)
      local typeToken = PopToken(this)
      if typeToken:getType() ~= 16 --[[JsonTokenType.UnquotedString]] then
        local message = System.String.Format("JSON reader expected a type name but found '{0}'.", typeToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      repeat
        local default = typeToken:getLexeme()
        if default == "BinData" then
          value = ParseBinDataConstructor(this)
          return 5 --[[BsonType.Binary]], value
        elseif default == "Date" then
          value = ParseDateTimeConstructor(this, true)
          return 9 --[[BsonType.DateTime]], value
        elseif default == "HexData" then
          value = ParseHexDataConstructor(this)
          return 5 --[[BsonType.Binary]], value
        elseif default == "ISODate" then
          value = ParseISODateTimeConstructor(this)
          return 9 --[[BsonType.DateTime]], value
        elseif default == "NumberDecimal" then
          value = ParseNumberDecimalConstructor(this)
          return 19 --[[BsonType.Decimal128]], value
        elseif default == "NumberInt" then
          value = ParseNumberConstructor(this)
          return 16 --[[BsonType.Int32]], value
        elseif default == "NumberLong" then
          value = ParseNumberLongConstructor(this)
          return 18 --[[BsonType.Int64]], value
        elseif default == "ObjectId" then
          value = ParseObjectIdConstructor(this)
          return 7 --[[BsonType.ObjectId]], value
        elseif default == "RegExp" then
          value = ParseRegularExpressionConstructor(this)
          return 11 --[[BsonType.RegularExpression]], value
        elseif default == "Timestamp" then
          value = ParseTimestampConstructor(this)
          return 17 --[[BsonType.Timestamp]], value
        elseif default == "UUID" or default == "GUID" or default == "CSUUID" or default == "CSGUID" or default == "JUUID" or default == "JGUID" or default == "PYUUID" or default == "PYGUID" then
          value = ParseUUIDConstructor(this, typeToken:getLexeme())
          return 5 --[[BsonType.Binary]], value
        else
          local message = System.String.Format("JSON reader expected a type name but found '{0}'.", typeToken:getLexeme())
          System.throw(System.FormatException(message))
        end
      until 1
    end
    ParseNumberConstructor = function (this)
      VerifyToken(this, "(")
      local valueToken = PopToken(this)
      local value
      if valueToken:getIsNumber() then
        value = valueToken:getInt32Value()
      elseif valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = System.Int32.Parse(valueToken:getStringValue())
      else
        local message = System.String.Format("JSON reader expected an integer or a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      return MongoDBBson.BsonInt32.op_Implicit22(value)
    end
    ParseNumberDecimalConstructor = function (this)
      VerifyToken(this, "(")
      local valueToken = PopToken(this)
      local value
      if valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = MongoDBBson.Decimal128.Parse(valueToken:getStringValue())
      elseif valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        value = System.new(MongoDBBson.Decimal128, 6, valueToken:getInt64Value())
      else
        local message = System.String.Format("JSON reader expected an integer or a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      return MongoDBBson.BsonDecimal128.op_Implicit22(value)
    end
    ParseNumberLongConstructor = function (this)
      VerifyToken(this, "(")
      local valueToken = PopToken(this)
      local value
      if valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        value = valueToken:getInt64Value()
      elseif valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = System.Int64.Parse(valueToken:getStringValue())
      else
        local message = System.String.Format("JSON reader expected an integer or a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      return MongoDBBson.BsonInt64.op_Implicit22(value)
    end
    ParseNumberDecimalExtendedJson = function (this)
      VerifyToken(this, ":")

      local value
      local valueToken = PopToken(this)
      if valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = MongoDBBson.Decimal128.Parse(valueToken:getStringValue())
      elseif valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        value = System.new(MongoDBBson.Decimal128, 6, valueToken:getInt64Value())
      else
        local message = System.String.Format("JSON reader expected a string or an integer but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end

      VerifyToken(this, "}")
      return MongoDBBson.BsonDecimal128.op_Implicit22(value)
    end
    ParseNumberIntExtendedJson = function (this)
      VerifyToken(this, ":")

      local value
      local valueToken = PopToken(this)
      if valueToken:getType() == 11 --[[JsonTokenType.Int32]] then
        value = valueToken:getInt32Value()
      elseif valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = MongoDBBsonIO.JsonConvert.ToInt32(valueToken:getStringValue())
      else
        local message = System.String.Format("JSON reader expected an integer but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end

      VerifyToken(this, "}")
      return MongoDBBson.BsonInt32.op_Implicit22(value)
    end
    ParseNumberLongExtendedJson = function (this)
      VerifyToken(this, ":")

      local value
      local valueToken = PopToken(this)
      if valueToken:getType() == 15 --[[JsonTokenType.String]] then
        value = System.Int64.Parse(valueToken:getStringValue(), SystemGlobalization.CultureInfo.getInvariantCulture())
      elseif valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        value = valueToken:getInt64Value()
      else
        local message = System.String.Format("JSON reader expected a string or an integer but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end

      VerifyToken(this, "}")
      return MongoDBBson.BsonInt64.op_Implicit22(value)
    end
    ParseObjectIdConstructor = function (this)
      VerifyToken(this, "(")
      local valueToken = PopToken(this)
      if valueToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      return MongoDBBson.BsonObjectId(MongoDBBson.ObjectId.Parse(valueToken:getStringValue()))
    end
    ParseObjectIdExtendedJson = function (this)
      VerifyToken(this, ":")
      local valueToken = PopToken(this)
      if valueToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, "}")
      return MongoDBBson.BsonObjectId(MongoDBBson.ObjectId.Parse(valueToken:getStringValue()))
    end
    ParseRegularExpressionConstructor = function (this)
      VerifyToken(this, "(")
      local patternToken = PopToken(this)
      if patternToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", patternToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      local options = ""
      local commaToken = PopToken(this)
      if commaToken:getLexeme() == "," then
        local optionsToken = PopToken(this)
        if optionsToken:getType() ~= 15 --[[JsonTokenType.String]] then
          local message = System.String.Format("JSON reader expected a string but found '{0}'.", optionsToken:getLexeme())
          System.throw(System.FormatException(message))
        end
        options = optionsToken:getStringValue()
      else
        PushToken(this, commaToken)
      end
      VerifyToken(this, ")")
      return System.new(MongoDBBson.BsonRegularExpression, 2, patternToken:getStringValue(), options)
    end
    ParseRegularExpressionExtendedJson = function (this)
      VerifyToken(this, ":")
      local patternToken = PopToken(this)
      if patternToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", patternToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      local options = ""
      local commaToken = PopToken(this)
      if commaToken:getLexeme() == "," then
        VerifyString(this, "$options")
        VerifyToken(this, ":")
        local optionsToken = PopToken(this)
        if optionsToken:getType() ~= 15 --[[JsonTokenType.String]] then
          local message = System.String.Format("JSON reader expected a string but found '{0}'.", optionsToken:getLexeme())
          System.throw(System.FormatException(message))
        end
        options = optionsToken:getStringValue()
      else
        PushToken(this, commaToken)
      end
      VerifyToken(this, "}")
      return System.new(MongoDBBson.BsonRegularExpression, 2, patternToken:getStringValue(), options)
    end
    ParseSymbolExtendedJson = function (this)
      VerifyToken(this, ":")
      local nameToken = PopToken(this)
      if nameToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", nameToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, "}")
      return MongoDBBson.BsonString.op_Implicit22(nameToken:getStringValue())
      -- will be converted to a BsonSymbol at a higher level
    end
    ParseTimestampConstructor = function (this)
      VerifyToken(this, "(")
      local secondsSinceEpoch
      local secondsSinceEpochToken = PopToken(this)
      if secondsSinceEpochToken:getIsNumber() then
        secondsSinceEpoch = secondsSinceEpochToken:getInt32Value()
      else
        local message = System.String.Format("JSON reader expected a number but found '{0}'.", secondsSinceEpochToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ",")
      local increment
      local incrementToken = PopToken(this)
      if secondsSinceEpochToken:getIsNumber() then
        increment = incrementToken:getInt32Value()
      else
        local message = System.String.Format("JSON reader expected a number but found '{0}'.", secondsSinceEpochToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      return System.new(MongoDBBson.BsonTimestamp, 2, secondsSinceEpoch, increment)
    end
    ParseTimestampExtendedJson = function (this)
      VerifyToken(this, ":")
      local nextToken = PopToken(this)
      if nextToken:getType() == 2 --[[JsonTokenType.BeginObject]] then
        return ParseTimestampExtendedJsonNewRepresentation(this)
      else
        return ParseTimestampExtendedJsonOldRepresentation(this, nextToken)
      end
    end
    ParseTimestampExtendedJsonNewRepresentation = function (this)
      local timestamp = nil
      local increment = nil

      while true do
        local continue
        repeat
          local token = PopToken(this)
          if token:getType() ~= 15 --[[JsonTokenType.String]] and token:getType() ~= 16 --[[JsonTokenType.UnquotedString]] then
            System.throw(System.FormatException("JSON reader expected an element name but found '" .. token:getLexeme() .. "'."))
          end
          local name = token:getStringValue()

          token = PopToken(this)
          if token:getType() ~= 7 --[[JsonTokenType.Colon]] then
            System.throw(System.FormatException("JSON reader expected ':' but found '" .. name .. "'."))
          end

          token = PopToken(this)
          if token:getType() ~= 11 --[[JsonTokenType.Int32]] then
            System.throw(System.FormatException("JSON reader expected an integer but found '" .. token:getLexeme() .. "'."))
          end
          local value = token:getInt32Value()

          repeat
            local default = name
            if default == "t" then
              timestamp = value
              break
            elseif default == "i" then
              increment = value
              break
            else
              System.throw(System.FormatException("JSON reader expected 't' or 'i' element names but found '" .. name .. "'."))
            end
          until 1

          token = PopToken(this)
          if token:getType() == 8 --[[JsonTokenType.Comma]] then
            continue = true
            break
          elseif token:getType() == 6 --[[JsonTokenType.EndObject]] then
            break
          else
            System.throw(System.FormatException("JSON reader expected ',' or '}'  but found '" .. token:getLexeme() .. "'."))
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end
      VerifyToken(this, "}")

      if not (timestamp ~= nil) then
        System.throw(System.FormatException("JSON reader did not find the required \"t\" element."))
      end
      if not (increment ~= nil) then
        System.throw(System.FormatException("JSON reader did not find the required \"i\" element."))
      end

      return System.new(MongoDBBson.BsonTimestamp, 2, System.Nullable.Value(timestamp), System.Nullable.Value(increment))
    end
    ParseTimestampExtendedJsonOldRepresentation = function (this, valueToken)
      local value
      if valueToken:getType() == 11 --[[JsonTokenType.Int32]] or valueToken:getType() == 12 --[[JsonTokenType.Int64]] then
        value = valueToken:getInt64Value()
      elseif valueToken:getType() == 16 --[[JsonTokenType.UnquotedString]] and valueToken:getLexeme() == "NumberLong" then
        value = ParseNumberLongConstructor(this):getAsInt64()
      else
        local message = System.String.Format("JSON reader expected an integer but found '{0}'.", valueToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, "}")
      return MongoDBBson.BsonTimestamp(value)
    end
    ParseUndefinedExtendedJson = function (this)
      VerifyToken(this, ":")
      VerifyToken(this, "true")
      VerifyToken(this, "}")
      return MongoDBBson.BsonMaxKey.getValue()
    end
    ParseUUIDConstructor = function (this, uuidConstructorName)
      VerifyToken(this, "(")
      local bytesToken = PopToken(this)
      if bytesToken:getType() ~= 15 --[[JsonTokenType.String]] then
        local message = System.String.Format("JSON reader expected a string but found '{0}'.", bytesToken:getLexeme())
        System.throw(System.FormatException(message))
      end
      VerifyToken(this, ")")
      local hexString = bytesToken:getStringValue():Replace("{", ""):Replace("}", ""):Replace("-", "")
      local bytes = MongoDBBson.BsonUtils.ParseHexString(hexString)
      local guid = MongoDBBson.GuidConverter.FromBytes(bytes, 1 --[[GuidRepresentation.Standard]])
      local guidRepresentation
      repeat
        local default = uuidConstructorName
        if default == "CSUUID" or default == "CSGUID" then
          guidRepresentation = 2 --[[GuidRepresentation.CSharpLegacy]]
          break
        elseif default == "JUUID" or default == "JGUID" then
          guidRepresentation = 3 --[[GuidRepresentation.JavaLegacy]]
          break
        elseif default == "PYUUID" or default == "PYGUID" then
          guidRepresentation = 4 --[[GuidRepresentation.PythonLegacy]]
          break
        elseif default == "UUID" or default == "GUID" then
          guidRepresentation = 1 --[[GuidRepresentation.Standard]]
          break
        else
          System.throw(System.new(MongoDBBson.BsonInternalException, 2, "Unexpected uuidConstructorName"))
        end
      until 1
      bytes = MongoDBBson.GuidConverter.ToBytes(guid, guidRepresentation)
      local subType = (guidRepresentation == 1 --[[GuidRepresentation.Standard]]) and 4 --[[BsonBinarySubType.UuidStandard]] or 3 --[[BsonBinarySubType.UuidLegacy]]
      return System.new(MongoDBBson.BsonBinaryData, 3, bytes, subType, guidRepresentation)
    end
    PopToken = function (this)
      if this._pushedToken ~= nil then
        local token = this._pushedToken
        this._pushedToken = nil
        return token
      else
        return MongoDBBsonIO.JsonScanner.GetNextToken(this._buffer)
      end
    end
    PushToken = function (this, token)
      if this._pushedToken == nil then
        this._pushedToken = token
      else
        System.throw(System.new(MongoDBBson.BsonInternalException, 2, "There is already a pending token."))
      end
    end
    VerifyString = function (this, expectedString)
      local token = PopToken(this)
      if (token:getType() ~= 15 --[[JsonTokenType.String]] and token:getType() ~= 16 --[[JsonTokenType.UnquotedString]]) or token:getStringValue() ~= expectedString then
        local message = System.String.Format("JSON reader expected '{0}' but found '{1}'.", expectedString, token:getStringValue())
        System.throw(System.FormatException(message))
      end
    end
    VerifyToken = function (this, expectedLexeme)
      local token = PopToken(this)
      if token:getLexeme() ~= expectedLexeme then
        local message = System.String.Format("JSON reader expected '{0}' but found '{1}'.", expectedLexeme, token:getLexeme())
        System.throw(System.FormatException(message))
      end
    end
    return {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.BsonReader
        }
      end,
      Close = Close,
      GetBookmark = GetBookmark,
      IsAtEndOfFile = IsAtEndOfFile,
      ReadBinaryData = ReadBinaryData,
      ReadBoolean = ReadBoolean,
      ReadBsonType = ReadBsonType,
      ReadBytes = ReadBytes,
      ReadDateTime = ReadDateTime,
      ReadDecimal128 = ReadDecimal128,
      ReadDouble = ReadDouble,
      ReadEndArray = ReadEndArray,
      ReadEndDocument = ReadEndDocument,
      ReadInt32 = ReadInt32,
      ReadInt64 = ReadInt64,
      ReadJavaScript = ReadJavaScript,
      ReadJavaScriptWithScope = ReadJavaScriptWithScope,
      ReadMaxKey = ReadMaxKey,
      ReadMinKey = ReadMinKey,
      ReadName = ReadName,
      ReadNull = ReadNull,
      ReadObjectId = ReadObjectId,
      ReadRegularExpression = ReadRegularExpression,
      ReadStartArray = ReadStartArray,
      ReadStartDocument = ReadStartDocument,
      ReadString = ReadString,
      ReadSymbol = ReadSymbol,
      ReadTimestamp = ReadTimestamp,
      ReadUndefined = ReadUndefined,
      ReturnToBookmark = ReturnToBookmark,
      SkipName = SkipName,
      SkipValue = SkipValue,
      Dispose1 = Dispose1,
      static = static,
      __ctor__ = {
        __ctor1__,
        __ctor2__,
        __ctor3__,
        __ctor4__,
        __ctor5__
      }
    }
  end)
end)
