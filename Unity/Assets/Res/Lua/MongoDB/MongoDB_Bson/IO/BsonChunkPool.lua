-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local ArrayByte = System.Array(System.Byte)
local ArraySegmentByte = System.ArraySegment(System.Byte)
local MongoDBBsonChunkPool
local StackReferenceCountedChunk
System.import(function (out)
  MongoDBBsonChunkPool = MongoDB.Bson.IO.BsonChunkPool
  StackReferenceCountedChunk = System.Stack(MongoDBBsonChunkPool.ReferenceCountedChunk)
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- Represents a pool of chunks.
  -- </summary>
  namespace.class("BsonChunkPool", function (namespace)
    local __default, getDefault, setDefault, getChunkSize, getMaxChunkCount, getChunkCount, Dispose, GetChunk, 
    ReleaseChunk, ThrowIfDisposed, class, static, __ctor__
    namespace.class("DisposableChunk", function (namespace)
      local getBytes, Dispose, Fork, ThrowIfDisposed, class, __ctor__
      __ctor__ = function (this, referenceCountedChunk)
        this._referenceCountedChunk = referenceCountedChunk
        this._referenceCountedChunk:IncrementReferenceCount()
      end
      getBytes = function (this)
        ThrowIfDisposed(this)
        return ArraySegmentByte(this._referenceCountedChunk:getChunk())
      end
      Dispose = function (this)
        if not this._disposed then
          this._disposed = true
          this._referenceCountedChunk:DecrementReferenceCount()
        end
      end
      Fork = function (this)
        ThrowIfDisposed(this)
        return class(this._referenceCountedChunk)
      end
      ThrowIfDisposed = function (this)
        if this._disposed then
          System.throw(System.ObjectDisposedException(this:GetType():getName()))
        end
      end
      class = {
        base = function (out)
          return {
            out.MongoDB.Bson.IO.IBsonChunk
          }
        end,
        _disposed = false,
        getBytes = getBytes,
        Dispose = Dispose,
        Fork = Fork,
        __ctor__ = __ctor__
      }
      return class
    end)
    namespace.class("ReferenceCountedChunk", function (namespace)
      local getChunk, DecrementReferenceCount, IncrementReferenceCount, __ctor__
      __ctor__ = function (this, chunk, pool)
        this._chunk = chunk
        this._pool = pool
      end
      getChunk = function (this)
        return this._chunk
      end
      DecrementReferenceCount = function (this)
        local default
        default, this._referenceCount = System.Interlocked.Decrement(this._referenceCount)
        if default == 0 then
          ReleaseChunk(this._pool, this)
        end
      end
      IncrementReferenceCount = function (this)
        local _
        _, this._referenceCount = System.Interlocked.Increment(this._referenceCount)
      end
      return {
        _referenceCount = 0,
        getChunk = getChunk,
        DecrementReferenceCount = DecrementReferenceCount,
        IncrementReferenceCount = IncrementReferenceCount,
        __ctor__ = __ctor__
      }
    end)
    static = function (this)
      __default = class(8192, 65536 --[[64 * 1024]])
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="BsonChunkPool"/> class.
    -- </summary>
    -- <param name="chunkSize">The size of each chunk.</param>
    __ctor__ = function (this, maxChunkCount, chunkSize)
      this._chunks = StackReferenceCountedChunk()
      this._lock = System.Object()
      if maxChunkCount < 0 then
        System.throw(System.ArgumentOutOfRangeException("maxChunkCount"))
      end
      if chunkSize <= 0 then
        System.throw(System.ArgumentOutOfRangeException("chunkSize"))
      end

      this._maxChunkCount = maxChunkCount
      this._chunkSize = chunkSize
    end
    getDefault = function ()
      return __default
    end
    setDefault = function (value)
      if value == nil then
        System.throw(System.ArgumentNullException("value"))
      end
      __default = value
    end
    getChunkSize = function (this)
      return this._chunkSize
    end
    getMaxChunkCount = function (this)
      return this._maxChunkCount
    end
    getChunkCount = function (this)
      -- lock(_lock)
      do
        return #this._chunks
      end
    end
    Dispose = function (this)
      if not this._disposed then
        this._disposed = true
        this._chunks = nil
      end
    end
    GetChunk = function (this, requestedSize)
      ThrowIfDisposed(this)

      local referenceCountedChunk = nil
      -- lock(_lock)
      do
        if #this._chunks > 0 then
          referenceCountedChunk = this._chunks:Pop()
        end
      end

      if referenceCountedChunk == nil then
        local chunk = ArrayByte:new(this._chunkSize)
        referenceCountedChunk = class.ReferenceCountedChunk(chunk, this)
      end

      return class.DisposableChunk(referenceCountedChunk)
    end
    ReleaseChunk = function (this, chunk)
      if not this._disposed then
        -- lock(_lock)
        do
          if #this._chunks < this._maxChunkCount then
            this._chunks:Push(chunk)
          end
          -- otherwise just let it get garbage collected
        end
      end
    end
    ThrowIfDisposed = function (this)
      if this._disposed then
        System.throw(System.ObjectDisposedException(this:GetType():getName()))
      end
    end
    class = {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.IBsonChunkSource
        }
      end,
      getDefault = getDefault,
      setDefault = setDefault,
      _chunkSize = 0,
      _disposed = false,
      _maxChunkCount = 0,
      getChunkSize = getChunkSize,
      getMaxChunkCount = getMaxChunkCount,
      getChunkCount = getChunkCount,
      Dispose = Dispose,
      GetChunk = GetChunk,
      static = static,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
