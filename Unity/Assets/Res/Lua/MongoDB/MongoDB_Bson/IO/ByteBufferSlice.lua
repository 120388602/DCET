-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local ArraySegmentByte = System.ArraySegment(System.Byte)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- Represents a slice of a byte buffer.
  -- </summary>
  namespace.class("ByteBufferSlice", function (namespace)
    local getBuffer, getCapacity, getIsReadOnly, getLength, setLength, AccessBackingBytes, Clear, Dispose, 
    EnsureCapacity, GetByte, GetBytes, GetSlice, MakeReadOnly, SetByte, SetBytes, Dispose1, 
    EnsureValidPosition, EnsureValidPositionAndCount, EnsureValidPositionAndLength, ThrowIfDisposed, __ctor__
    -- <summary>
    -- Initializes a new instance of the <see cref="ByteBufferSlice"/> class.
    -- </summary>
    -- <param name="offset">The offset of the slice.</param>
    -- <param name="length">The length of the slice.</param>
    __ctor__ = function (this, buffer, offset, length)
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer"))
      end
      if not buffer:getIsReadOnly() then
        System.throw(System.ArgumentException("The buffer is not read only.", "buffer"))
      end
      if offset < 0 or offset > buffer:getLength() then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if length < 0 or offset + length > buffer:getLength() then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end

      this._buffer = buffer
      this._offset = offset
      this._length = length
    end
    getBuffer = function (this)
      ThrowIfDisposed(this)
      return this._buffer
    end
    getCapacity = function (this)
      ThrowIfDisposed(this)
      return this._length
    end
    getIsReadOnly = function (this)
      ThrowIfDisposed(this)
      return true
    end
    getLength = function (this)
      ThrowIfDisposed(this)
      return this._length
    end
    setLength = function (this, value)
      System.throw(System.NotSupportedException())
    end
    AccessBackingBytes = function (this, position)
      EnsureValidPosition(this, position)
      ThrowIfDisposed(this)

      local segment = this._buffer:AccessBackingBytes(position + this._offset)
      local count = math.Min(segment:getCount(), this._length - position)
      return ArraySegmentByte(segment:getArray(), segment:getOffset(), count)
    end
    Clear = function (this, position, count)
      EnsureValidPositionAndCount(this, position, count)
      ThrowIfDisposed(this)

      this._buffer:Clear(position + this._offset, count)
    end
    Dispose = function (this)
      this:Dispose1(true)
      System.GC.SuppressFinalize(this)
    end
    EnsureCapacity = function (this, minimumCapacity)
      System.throw(System.NotSupportedException())
    end
    GetByte = function (this, position)
      EnsureValidPosition(this, position)
      ThrowIfDisposed(this)

      return this._buffer:GetByte(position + this._offset)
    end
    GetBytes = function (this, position, destination, offset, count)
      EnsureValidPositionAndCount(this, position, count)
      ThrowIfDisposed(this)

      this._buffer:GetBytes(position + this._offset, destination, offset, count)
    end
    GetSlice = function (this, position, length)
      EnsureValidPositionAndLength(this, position, length)
      ThrowIfDisposed(this)

      return this._buffer:GetSlice(position + this._offset, length)
    end
    MakeReadOnly = function (this)
      ThrowIfDisposed(this)
    end
    SetByte = function (this, position, value)
      System.throw(System.NotSupportedException())
    end
    SetBytes = function (this, position, source, offset, count)
      System.throw(System.NotSupportedException())
    end
    -- <summary>
    -- Releases unmanaged and - optionally - managed resources.
    -- </summary>
    Dispose1 = function (this, disposing)
      if disposing and not this._disposed then
        this._buffer:Dispose()
      end
      this._disposed = true
    end
    EnsureValidPosition = function (this, position)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
    end
    EnsureValidPositionAndCount = function (this, position, count)
      EnsureValidPosition(this, position)
      if count < 0 or position + count > this._length then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end
    end
    EnsureValidPositionAndLength = function (this, position, length)
      EnsureValidPosition(this, position)
      if length < 0 or position + length > this._length then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end
    end
    ThrowIfDisposed = function (this)
      if this._disposed then
        System.throw(System.ObjectDisposedException(this:GetType():getName()))
      end
    end
    return {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.IByteBuffer
        }
      end,
      _disposed = false,
      _length = 0,
      _offset = 0,
      getBuffer = getBuffer,
      getCapacity = getCapacity,
      getIsReadOnly = getIsReadOnly,
      getLength = getLength,
      setLength = setLength,
      AccessBackingBytes = AccessBackingBytes,
      Clear = Clear,
      Dispose = Dispose,
      EnsureCapacity = EnsureCapacity,
      GetByte = GetByte,
      GetBytes = GetBytes,
      GetSlice = GetSlice,
      MakeReadOnly = MakeReadOnly,
      SetByte = SetByte,
      SetBytes = SetBytes,
      Dispose1 = Dispose1,
      __ctor__ = __ctor__
    }
  end)
end)
