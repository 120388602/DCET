-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local ArraySegmentByte = System.ArraySegment(System.Byte)
local MongoDBBsonIO
System.import(function (out)
  MongoDBBsonIO = MongoDB.Bson.IO
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- An IByteBuffer that is backed by a single chunk.
  -- </summary>
  namespace.class("SingleChunkBuffer", function (namespace)
    local getCapacity, getIsReadOnly, getLength, setLength, AccessBackingBytes, Clear, Dispose, EnsureCapacity, 
    GetByte, GetBytes, GetSlice, MakeReadOnly, SetByte, SetBytes, EnsureIsReadOnly, EnsureIsWritable, 
    ThrowIfDisposed, class, __ctor__
    -- <summary>
    -- Initializes a new instance of the <see cref="SingleChunkBuffer"/> class.
    -- </summary>
    -- <param name="length">The length.</param>
    -- <param name="isReadOnly">Whether the buffer is read only.</param>
    __ctor__ = function (this, chunk, length, isReadOnly)
      if chunk == nil then
        System.throw(System.ArgumentNullException("chunk"))
      end
      if length < 0 or length > chunk:getBytes():getCount() then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end

      this._chunk = chunk
      this._length = length
      this._isReadOnly = isReadOnly
    end
    getCapacity = function (this)
      ThrowIfDisposed(this)
      return this._isReadOnly and this._length or this._chunk:getBytes():getCount()
    end
    getIsReadOnly = function (this)
      ThrowIfDisposed(this)
      return this._isReadOnly
    end
    getLength = function (this)
      ThrowIfDisposed(this)
      return this._length
    end
    setLength = function (this, value)
      ThrowIfDisposed(this)
      if value < 0 or value > this._chunk:getBytes():getCount() then
        System.throw(System.ArgumentOutOfRangeException("value"))
      end
      EnsureIsWritable(this)

      this._length = value
    end
    AccessBackingBytes = function (this, position)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end

      local segment = this._chunk:getBytes()
      return ArraySegmentByte(segment:getArray(), segment:getOffset() + position, this._length - position)
    end
    Clear = function (this, position, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if count < 0 or position + count > this._length then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end
      EnsureIsWritable(this)

      local segment = this._chunk:getBytes()
      System.Array.ClearArray(segment:getArray(), segment:getOffset() + position, count)
    end
    Dispose = function (this)
      if not this._disposed then
        this._disposed = true
        this._chunk:Dispose()
        this._chunk = nil
      end
    end
    EnsureCapacity = function (this, minimumCapacity)
      if minimumCapacity < 0 then
        System.throw(System.ArgumentOutOfRangeException("minimumCapacity"))
      end
      ThrowIfDisposed(this)
      EnsureIsWritable(this)

      if this._chunk:getBytes():getCount() < minimumCapacity then
        System.throw(System.NotSupportedException("Capacity cannot be expanded for a SingleChunkBuffer."))
      end
    end
    GetByte = function (this, position)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end

      local segment = this._chunk:getBytes()
      return segment:getArray():get(segment:getOffset() + position)
    end
    GetBytes = function (this, position, destination, offset, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if destination == nil then
        System.throw(System.ArgumentNullException("destination"))
      end
      if offset < 0 or offset > #destination then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or position + count > this._length or offset + count > #destination then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end

      local segment = this._chunk:getBytes()
      System.Buffer.BlockCopy(segment:getArray(), segment:getOffset() + position, destination, offset, count)
    end
    GetSlice = function (this, position, length)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if length < 0 or position + length > this._length then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end
      EnsureIsReadOnly(this)

      local forkedBuffer = class(this._chunk:Fork(), this._length, true)
      return MongoDBBsonIO.ByteBufferSlice(forkedBuffer, position, length)
    end
    MakeReadOnly = function (this)
      ThrowIfDisposed(this)
      this._isReadOnly = true
    end
    SetByte = function (this, position, value)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      EnsureIsWritable(this)

      local segment = this._chunk:getBytes()
      segment:getArray():set(segment:getOffset() + position, value)
    end
    SetBytes = function (this, position, source, offset, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if source == nil then
        System.throw(System.ArgumentNullException("source"))
      end
      if offset < 0 or offset > #source then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or position + count > this._length or offset + count > #source then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end
      EnsureIsWritable(this)

      local segment = this._chunk:getBytes()
      System.Buffer.BlockCopy(source, offset, segment:getArray(), segment:getOffset() + position, count)
    end
    EnsureIsReadOnly = function (this)
      if not this._isReadOnly then
        System.throw(System.InvalidOperationException("MultiChunkBuffer is not read only."))
      end
    end
    EnsureIsWritable = function (this)
      if this._isReadOnly then
        System.throw(System.InvalidOperationException("MultiChunkBuffer is not writable."))
      end
    end
    ThrowIfDisposed = function (this)
      if this._disposed then
        System.throw(System.ObjectDisposedException(this:GetType():getName()))
      end
    end
    class = {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.IByteBuffer
        }
      end,
      _disposed = false,
      _isReadOnly = false,
      _length = 0,
      getCapacity = getCapacity,
      getIsReadOnly = getIsReadOnly,
      getLength = getLength,
      setLength = setLength,
      AccessBackingBytes = AccessBackingBytes,
      Clear = Clear,
      Dispose = Dispose,
      EnsureCapacity = EnsureCapacity,
      GetByte = GetByte,
      GetBytes = GetBytes,
      GetSlice = GetSlice,
      MakeReadOnly = MakeReadOnly,
      SetByte = SetByte,
      SetBytes = SetBytes,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
