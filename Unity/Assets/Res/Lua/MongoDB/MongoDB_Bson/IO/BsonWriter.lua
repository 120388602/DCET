-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local ArrayChar = System.Array(System.Char)
local MongoDBBson
local MongoDBBsonIO
local MongoDBBsonSerialization
local MongoDBSerializers
local StackBsonWriterSettings
local StackIElementNameValidator
System.import(function (out)
  MongoDBBson = MongoDB.Bson
  MongoDBBsonIO = MongoDB.Bson.IO
  MongoDBBsonSerialization = MongoDB.Bson.Serialization
  MongoDBSerializers = MongoDB.Bson.Serialization.Serializers
  StackBsonWriterSettings = System.Stack(MongoDBBsonIO.BsonWriterSettings)
  StackIElementNameValidator = System.Stack(MongoDBBsonIO.IElementNameValidator)
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- Represents a BSON writer for some external format (see subclasses).
  -- </summary>
  namespace.class("BsonWriter", function (namespace)
    local getSerializationDepth, getSettings, getState, setState, getDisposed, getName, Dispose, PopElementNameValidator, 
    PopSettings, PushElementNameValidator, PushSettings, WriteEndArray, WriteEndDocument, WriteName, WriteRawBsonArray, WriteRawBsonDocument, 
    WriteStartArray, WriteStartDocument, Dispose1, ThrowInvalidContextType, ThrowInvalidState, __ctor__
    -- <summary>
    -- Initializes a new instance of the BsonWriter class.
    -- </summary>
    __ctor__ = function (this, settings)
      this._childElementNameValidatorFactory = function ()
        return MongoDBBsonIO.NoOpElementNameValidator.getInstance()
      end
      this._elementNameValidator = MongoDBBsonIO.NoOpElementNameValidator.getInstance()
      this._elementNameValidatorStack = StackIElementNameValidator()
      this._settingsStack = StackBsonWriterSettings()
      if settings == nil then
        System.throw(System.ArgumentNullException("settings"))
      end

      this._settings = settings:FrozenCopy()
      this._state = 0 --[[BsonWriterState.Initial]]
    end
    getSerializationDepth = function (this)
      return this._serializationDepth
    end
    getSettings = function (this)
      return this._settings
    end
    getState = function (this)
      return this._state
    end
    setState = function (this, value)
      this._state = value
    end
    getDisposed = function (this)
      return this._disposed
    end
    getName = function (this)
      return this._name
    end
    -- <summary>
    -- Disposes of any resources used by the writer.
    -- </summary>
    Dispose = function (this)
      if not this._disposed then
        this:Dispose1(true)
        this._disposed = true
      end
    end
    -- <summary>
    -- Pops the element name validator.
    -- </summary>
    PopElementNameValidator = function (this)
      this._elementNameValidator = this._elementNameValidatorStack:Pop()
      this._childElementNameValidatorFactory = function ()
        return this._elementNameValidator
      end
    end
    PopSettings = function (this)
      this._settings = this._settingsStack:Pop()
    end
    -- <summary>
    -- Pushes the element name validator.
    -- </summary>
    PushElementNameValidator = function (this, validator)
      if validator == nil then
        System.throw(System.ArgumentNullException("validator"))
      end

      this._elementNameValidatorStack:Push(this._elementNameValidator)
      this._elementNameValidator = validator
      this._childElementNameValidatorFactory = function ()
        return this._elementNameValidator
      end
    end
    PushSettings = function (this, configurator)
      local newSettings = this._settings:Clone()
      configurator(newSettings)
      newSettings:Freeze()
      this._settingsStack:Push(this._settings)
      this._settings = newSettings
    end
    -- <summary>
    -- Writes the end of a BSON array to the writer.
    -- </summary>
    WriteEndArray = function (this)
      this._serializationDepth = this._serializationDepth - 1
    end
    -- <summary>
    -- Writes the end of a BSON document to the writer.
    -- </summary>
    WriteEndDocument = function (this)
      this._serializationDepth = this._serializationDepth - 1

      PopElementNameValidator(this)
    end
    -- <summary>
    -- Writes the name of an element to the writer.
    -- </summary>
    WriteName = function (this, name)
      if name == nil then
        System.throw(System.ArgumentNullException("name"))
      end
      if name:IndexOf(0 --[['\0']]) ~= - 1 then
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "Element names cannot contain nulls."))
      end
      if this._disposed then
        System.throw(System.ObjectDisposedException(this:GetType():getName()))
      end
      if this._state ~= 1 --[[BsonWriterState.Name]] then
        ThrowInvalidState(this, "WriteName", System.Array(System.Int32)(1 --[[BsonWriterState.Name]]))
      end

      if not this._elementNameValidator:IsValidElementName(name) then
        local message = System.String.Format("Element name '{0}' is not valid'.", name)
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, message))
      end
      this._childElementNameValidatorFactory = function ()
        return this._elementNameValidator:GetValidatorForChildContent(name)
      end

      this._name = name
      this._state = 2 --[[BsonWriterState.Value]]
    end
    -- <summary>
    -- Writes a raw BSON array.
    -- </summary>
    WriteRawBsonArray = function (this, slice)
      -- overridden in BsonBinaryWriter to write the raw bytes to the stream
      -- for all other streams, deserialize the raw bytes and serialize the resulting array instead

      System.using(MongoDBBsonIO.InputBufferChunkSource(MongoDBBsonIO.BsonChunkPool.getDefault(), 4096, 16384, 1048576), function (chunkSource)
        System.using(MongoDBBsonIO.MultiChunkBuffer(chunkSource), function (buffer)
          System.using(MongoDBBsonIO.ByteBufferStream(buffer, false), function (stream)
            -- wrap the array in a fake document so we can deserialize it
            local documentLength = slice:getLength() + 8
            buffer:EnsureCapacity(documentLength)
            stream:WriteInt32(documentLength)
            MongoDBBsonIO.BsonStreamExtensions.WriteBsonType(stream, 4 --[[BsonType.Array]])
            stream:WriteByte(120 --[[(byte)'x']])
            stream:WriteByte(0)
            MongoDBBsonIO.BsonStreamExtensions.WriteSlice(stream, slice)
            stream:WriteByte(0)
            buffer:MakeReadOnly()

            stream:setPosition(0)
            System.using(System.new(MongoDBBsonIO.BsonBinaryReader, 2, stream, MongoDBBsonIO.BsonBinaryReaderSettings.getDefaults()), function (reader)
              local deserializationContext = MongoDBBsonSerialization.BsonDeserializationContext.CreateRoot(reader)
              reader:ReadStartDocument()
              MongoDBBsonIO.IBsonReaderExtensions.ReadName1(reader, "x")
              local array = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonArraySerializer.getInstance(), deserializationContext, MongoDBBson.BsonArray)
              reader:ReadEndDocument()

              local serializationContext = MongoDBBsonSerialization.BsonSerializationContext.CreateRoot(this)
              MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize1(MongoDBSerializers.BsonArraySerializer.getInstance(), serializationContext, array, MongoDBBson.BsonArray)
            end)
          end)
        end)
      end)
    end
    -- <summary>
    -- Writes a raw BSON document.
    -- </summary>
    WriteRawBsonDocument = function (this, slice)
      -- overridden in BsonBinaryWriter to write the raw bytes to the stream
      -- for all other streams, deserialize the raw bytes and serialize the resulting document instead

      System.using(MongoDBBsonIO.ByteBufferStream(slice, false), function (stream)
        System.using(System.new(MongoDBBsonIO.BsonBinaryReader, 2, stream, MongoDBBsonIO.BsonBinaryReaderSettings.getDefaults()), function (bsonReader)
          local deserializationContext = MongoDBBsonSerialization.BsonDeserializationContext.CreateRoot(bsonReader)
          local document = MongoDBBsonSerialization.IBsonSerializerExtensions.Deserialize1(MongoDBSerializers.BsonDocumentSerializer.getInstance(), deserializationContext, MongoDBBson.BsonDocument)

          local serializationContext = MongoDBBsonSerialization.BsonSerializationContext.CreateRoot(this)
          MongoDBBsonSerialization.IBsonSerializerExtensions.Serialize1(MongoDBSerializers.BsonDocumentSerializer.getInstance(), serializationContext, document, MongoDBBson.BsonDocument)
        end)
      end)
    end
    -- <summary>
    -- Writes the start of a BSON array to the writer.
    -- </summary>
    WriteStartArray = function (this)
      this._serializationDepth = this._serializationDepth + 1
      if this._serializationDepth > this._settings:getMaxSerializationDepth() then
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "Maximum serialization depth exceeded (does the object being serialized have a circular reference?)."))
      end
    end
    -- <summary>
    -- Writes the start of a BSON document to the writer.
    -- </summary>
    WriteStartDocument = function (this)
      this._serializationDepth = this._serializationDepth + 1
      if this._serializationDepth > this._settings:getMaxSerializationDepth() then
        System.throw(System.new(MongoDBBson.BsonSerializationException, 2, "Maximum serialization depth exceeded (does the object being serialized have a circular reference?)."))
      end

      PushElementNameValidator(this, this._childElementNameValidatorFactory())
    end
    -- <summary>
    -- Disposes of any resources used by the writer.
    -- </summary>
    Dispose1 = function (this, disposing)
    end
    -- <summary>
    -- Throws an InvalidOperationException when the method called is not valid for the current ContextType.
    -- </summary>
    -- <param name="actualContextType">The actual ContextType.</param>
    -- <param name="validContextTypes">The valid ContextTypes.</param>
    ThrowInvalidContextType = function (this, methodName, actualContextType, validContextTypes)
      local validContextTypesString = System.String.JoinParams(" or ", Linq.ToArray(Linq.Select(validContextTypes, function (c)
        return c:EnumToString(MongoDBBsonIO.ContextType)
      end, System.String)))
      local message = System.String.Format("{0} can only be called when ContextType is {1}, not when ContextType is {2}.", methodName, validContextTypesString, actualContextType)
      System.throw(System.InvalidOperationException(message))
    end
    -- <summary>
    -- Throws an InvalidOperationException when the method called is not valid for the current state.
    -- </summary>
    -- <param name="validStates">The valid states.</param>
    ThrowInvalidState = function (this, methodName, validStates)
      local message
      if this._state == 0 --[[BsonWriterState.Initial]] or this._state == 3 --[[BsonWriterState.ScopeDocument]] or this._state == 4 --[[BsonWriterState.Done]] then
        if not methodName:StartsWith("End", 4 --[[StringComparison.Ordinal]]) and methodName ~= "WriteName" then
          local typeName = methodName:Substring(5)
          if typeName:StartsWith("Start", 4 --[[StringComparison.Ordinal]]) then
            typeName = typeName:Substring(5)
          end
          local article = "A"
          if Linq.Contains(ArrayChar(65 --[['A']], 69 --[['E']], 73 --[['I']], 79 --[['O']], 85 --[['U']]), typeName:get(0)) then
            article = "An"
          end
          message = System.String.Format("{0} {1} value cannot be written to the root level of a BSON document.", article, typeName)
          System.throw(System.InvalidOperationException(message))
        end
      end

      local validStatesString = System.String.JoinParams(" or ", Linq.ToArray(Linq.Select(validStates, function (s)
        return s:EnumToString(MongoDBBsonIO.BsonWriterState)
      end, System.String)))
      message = System.String.Format("{0} can only be called when State is {1}, not when State is {2}", methodName, validStatesString, this._state)
      System.throw(System.InvalidOperationException(message))
    end
    return {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.IBsonWriter
        }
      end,
      _disposed = false,
      _state = 0,
      _serializationDepth = 0,
      getSerializationDepth = getSerializationDepth,
      getSettings = getSettings,
      getState = getState,
      setState = setState,
      getDisposed = getDisposed,
      getName = getName,
      Dispose = Dispose,
      PopElementNameValidator = PopElementNameValidator,
      PopSettings = PopSettings,
      PushElementNameValidator = PushElementNameValidator,
      PushSettings = PushSettings,
      WriteEndArray = WriteEndArray,
      WriteEndDocument = WriteEndDocument,
      WriteName = WriteName,
      WriteRawBsonArray = WriteRawBsonArray,
      WriteRawBsonDocument = WriteRawBsonDocument,
      WriteStartArray = WriteStartArray,
      WriteStartDocument = WriteStartDocument,
      Dispose1 = Dispose1,
      ThrowInvalidContextType = ThrowInvalidContextType,
      ThrowInvalidState = ThrowInvalidState,
      __ctor__ = __ctor__
    }
  end)
end)
