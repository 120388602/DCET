-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local Linq = System.Linq.Enumerable
local ArrayByte = System.Array(System.Byte)
local ListInt32 = System.List(System.Int32)
local ArraySegmentByte = System.ArraySegment(System.Byte)
local MongoDBBsonIO
local ListIBsonChunk
System.import(function (out)
  MongoDBBsonIO = MongoDB.Bson.IO
  ListIBsonChunk = System.List(MongoDBBsonIO.IBsonChunk)
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- An IByteBuffer that is backed by multiple chunks.
  -- </summary>
  namespace.class("MultiChunkBuffer", function (namespace)
    local getCapacity, getChunkSource, getIsReadOnly, getLength, setLength, AccessBackingBytes, Clear, Dispose, 
    EnsureCapacity, GetByte, GetBytes, GetSlice, MakeReadOnly, SetByte, SetBytes, EnsureIsReadOnly, 
    EnsureIsWritable, ExpandCapacity, GetChunkIndex, ThrowIfDisposed, class, __ctor1__, __ctor2__
    -- <summary>
    -- Initializes a new instance of the <see cref="MultiChunkBuffer"/> class.
    -- </summary>
    -- <exception cref="System.ArgumentNullException">chunkPool</exception>
    __ctor1__ = function (this, chunkSource)
      if chunkSource == nil then
        System.throw(System.ArgumentNullException("chunkSource"))
      end

      this._chunks = ListIBsonChunk()
      this._chunkSource = chunkSource
      this._length = 0
      local default = ListInt32()
      default:Add(0)
      this._positions = default
    end
    -- <summary>
    -- Initializes a new instance of the <see cref="MultiChunkBuffer"/> class.
    -- </summary>
    -- <param name="length">The length.</param>
    -- <param name="isReadOnly">Whether the buffer is read only.</param>
    -- <exception cref="System.ArgumentNullException">chunks</exception>
    __ctor2__ = function (this, chunks, length, isReadOnly)
      if chunks == nil then
        System.throw(System.ArgumentNullException("chunks"))
      end
      local materializedList = ListIBsonChunk(chunks)

      local capacity = 0
      local default = ListInt32()
      default:Add(0)
      local positions = default
      for _, chunk in System.each(materializedList) do
        capacity = capacity + chunk:getBytes():getCount()
        positions:Add(capacity)
      end

      if (length ~= nil) and (System.Nullable.Value(length) < 0 or System.Nullable.Value(length) > capacity) then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end

      this._capacity = capacity
      this._chunks = materializedList
      this._isReadOnly = isReadOnly
      this._length = length or capacity
      this._positions = positions
    end
    getCapacity = function (this)
      ThrowIfDisposed(this)
      return this._isReadOnly and this._length or this._capacity
    end
    getChunkSource = function (this)
      return this._chunkSource
    end
    getIsReadOnly = function (this)
      ThrowIfDisposed(this)
      return this._isReadOnly
    end
    getLength = function (this)
      ThrowIfDisposed(this)
      return this._length
    end
    setLength = function (this, value)
      ThrowIfDisposed(this)
      if value < 0 or value > this._capacity then
        System.throw(System.ArgumentOutOfRangeException("value"))
      end
      EnsureIsWritable(this)

      this._length = value
    end
    AccessBackingBytes = function (this, position)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end

      local chunkIndex = GetChunkIndex(this, position)
      if chunkIndex < #this._chunks then
        local segment = this._chunks:get(chunkIndex):getBytes()
        local chunkOffset = position - this._positions:get(chunkIndex)
        local chunkRemaining = segment:getCount() - chunkOffset
        return ArraySegmentByte(segment:getArray(), segment:getOffset() + chunkOffset, chunkRemaining)
      else
        if #this._chunks > 0 then
          local segment = this._chunks:get(chunkIndex - 1):getBytes()
          return ArraySegmentByte(segment:getArray(), segment:getOffset() + segment:getCount(), 0)
        else
          return ArraySegmentByte(ArrayByte:new(0), 0, 0)
        end
      end
    end
    Clear = function (this, position, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if count < 0 or position + count > this._length then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end
      EnsureIsWritable(this)

      local chunkIndex = GetChunkIndex(this, position)
      local chunkOffset = position - this._positions:get(chunkIndex)
      while count > 0 do
        local segment = this._chunks:get(chunkIndex):getBytes()
        local chunkRemaining = segment:getCount() - chunkOffset
        local partialCount = math.Min(count, chunkRemaining)
        System.Array.ClearArray(segment:getArray(), segment:getOffset() + chunkOffset, partialCount)
        chunkIndex = chunkIndex + 1
        chunkOffset = 0
        count = count - partialCount
      end
    end
    Dispose = function (this)
      if not this._disposed then
        this._disposed = true
        for _, chunk in System.each(this._chunks) do
          chunk:Dispose()
        end
        this._chunks = nil
        this._positions = nil
      end
    end
    EnsureCapacity = function (this, minimumCapacity)
      if minimumCapacity < 0 then
        System.throw(System.ArgumentOutOfRangeException("minimumCapacity"))
      end
      ThrowIfDisposed(this)
      EnsureIsWritable(this)

      if this._capacity < minimumCapacity then
        ExpandCapacity(this, minimumCapacity)
      end
    end
    GetByte = function (this, position)
      ThrowIfDisposed(this)
      if position < 0 or position >= this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end

      local chunkIndex = GetChunkIndex(this, position)
      local chunkOffset = position - this._positions:get(chunkIndex)
      local segment = this._chunks:get(chunkIndex):getBytes()
      return segment:getArray():get(segment:getOffset() + chunkOffset)
    end
    GetBytes = function (this, position, destination, offset, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if destination == nil then
        System.throw(System.ArgumentNullException("destination"))
      end
      if offset < 0 or offset > #destination then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or position + count > this._length or offset + count > #destination then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end

      local chunkIndex = GetChunkIndex(this, position)
      local chunkOffset = position - this._positions:get(chunkIndex)
      while count > 0 do
        local segment = this._chunks:get(chunkIndex):getBytes()
        local chunkRemaining = segment:getCount() - chunkOffset
        local partialCount = math.Min(count, chunkRemaining)
        System.Buffer.BlockCopy(segment:getArray(), segment:getOffset() + chunkOffset, destination, offset, partialCount)
        chunkIndex = chunkIndex + 1
        chunkOffset = 0
        count = count - partialCount
        offset = offset + partialCount
      end
    end
    GetSlice = function (this, position, length)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if length < 0 or position + length > this._length then
        System.throw(System.ArgumentOutOfRangeException("length"))
      end
      EnsureIsReadOnly(this)

      if length == 0 then
        return MongoDBBsonIO.ByteArrayBuffer(ArrayByte:new(0), false)
      end

      local firstChunkIndex = GetChunkIndex(this, position)
      local lastChunkIndex = GetChunkIndex(this, position + length - 1)

      local forkedBuffer
      if firstChunkIndex == lastChunkIndex then
        local forkedChunk = this._chunks:get(firstChunkIndex):Fork()
        forkedBuffer = MongoDBBsonIO.SingleChunkBuffer(forkedChunk, forkedChunk:getBytes():getCount(), true)
      else
        local forkedChunks = Linq.Select(Linq.Take(Linq.Skip(this._chunks, firstChunkIndex), lastChunkIndex - firstChunkIndex + 1), function (c)
          return c:Fork()
        end, MongoDBBsonIO.IBsonChunk)
        local forkedBufferLength = this._positions:get(lastChunkIndex + 1) - this._positions:get(firstChunkIndex)
        forkedBuffer = System.new(class, 2, forkedChunks, forkedBufferLength, true)
      end

      local offset = position - this._positions:get(firstChunkIndex)
      return MongoDBBsonIO.ByteBufferSlice(forkedBuffer, offset, length)
    end
    MakeReadOnly = function (this)
      ThrowIfDisposed(this)
      this._isReadOnly = true
    end
    SetByte = function (this, position, value)
      ThrowIfDisposed(this)
      if position < 0 or position >= this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      EnsureIsWritable(this)

      local chunkIndex = GetChunkIndex(this, position)
      local chunkOffset = position - this._positions:get(chunkIndex)
      local segment = this._chunks:get(chunkIndex):getBytes()
      segment:getArray():set(segment:getOffset() + chunkOffset, value)
    end
    SetBytes = function (this, position, source, offset, count)
      ThrowIfDisposed(this)
      if position < 0 or position > this._length then
        System.throw(System.ArgumentOutOfRangeException("position"))
      end
      if source == nil then
        System.throw(System.ArgumentNullException("source"))
      end
      if offset < 0 or offset > #source then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or position + count > this._length or offset + count > #source then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end
      EnsureIsWritable(this)

      local chunkIndex = GetChunkIndex(this, position)
      local chunkOffset = position - this._positions:get(chunkIndex)
      while count > 0 do
        local segment = this._chunks:get(chunkIndex):getBytes()
        local chunkRemaining = segment:getCount() - chunkOffset
        local partialCount = math.Min(count, chunkRemaining)
        System.Buffer.BlockCopy(source, offset, segment:getArray(), segment:getOffset() + chunkOffset, partialCount)
        chunkIndex = chunkIndex + 1
        chunkOffset = 0
        offset = offset + partialCount
        count = count - partialCount
      end
    end
    EnsureIsReadOnly = function (this)
      if not this._isReadOnly then
        System.throw(System.InvalidOperationException("MultiChunkBuffer is not read only."))
      end
    end
    EnsureIsWritable = function (this)
      if this._isReadOnly then
        System.throw(System.InvalidOperationException("MultiChunkBuffer is not writable."))
      end
    end
    ExpandCapacity = function (this, minimumCapacity)
      if this._chunkSource == nil then
        System.throw(System.InvalidOperationException("Capacity cannot be expanded because this buffer was created without specifying a chunk source."))
      end

      while this._capacity < minimumCapacity do
        local chunk = this._chunkSource:GetChunk(minimumCapacity)
        this._chunks:Add(chunk)
        local newCapacity = this._capacity + chunk:getBytes():getCount()
        if newCapacity > 2147483647 --[[Int32.MaxValue]] then
          System.throw(System.InvalidOperationException("Capacity is limited to 2GB."))
        end
        this._capacity = System.toInt32(newCapacity)
        this._positions:Add(this._capacity)
      end
    end
    GetChunkIndex = function (this, position)
      -- locality of reference means this loop will only execute once most of the time
      while true do
        if this._chunkIndex + 1 < #this._positions and position >= this._positions:get(this._chunkIndex + 1) then
          this._chunkIndex = this._chunkIndex + 1
        elseif position < this._positions:get(this._chunkIndex) then
          this._chunkIndex = this._chunkIndex - 1
        else
          return this._chunkIndex
        end
      end
    end
    ThrowIfDisposed = function (this)
      if this._disposed then
        System.throw(System.ObjectDisposedException(this:GetType():getName()))
      end
    end
    class = {
      base = function (out)
        return {
          out.MongoDB.Bson.IO.IByteBuffer
        }
      end,
      _capacity = 0,
      _chunkIndex = 0,
      _disposed = false,
      _isReadOnly = false,
      _length = 0,
      getCapacity = getCapacity,
      getChunkSource = getChunkSource,
      getIsReadOnly = getIsReadOnly,
      getLength = getLength,
      setLength = setLength,
      AccessBackingBytes = AccessBackingBytes,
      Clear = Clear,
      Dispose = Dispose,
      EnsureCapacity = EnsureCapacity,
      GetByte = GetByte,
      GetBytes = GetBytes,
      GetSlice = GetSlice,
      MakeReadOnly = MakeReadOnly,
      SetByte = SetByte,
      SetBytes = SetBytes,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
    return class
  end)
end)
