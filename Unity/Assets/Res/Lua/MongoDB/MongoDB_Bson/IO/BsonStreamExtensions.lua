-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local SystemIO = System.IO
local ArrayByte = System.Array(System.Byte)
local ArrayBoolean = System.Array(System.Boolean)
local MongoDBBson
System.import(function (out)
  MongoDBBson = MongoDB.Bson
end)
System.namespace("MongoDB.Bson.IO", function (namespace)
  -- <summary>
  -- Represents extension methods on BsonStream.
  -- </summary>
  namespace.class("BsonStreamExtensions", function (namespace)
    local __validBsonTypes, BackpatchSize, ReadBinarySubType, ReadBoolean, ReadBsonType, ReadBytes, ReadBytes1, WriteBinarySubType, 
    WriteBoolean, WriteBsonType, WriteBytes, WriteSlice, static
    static = function (this)
      __validBsonTypes = ArrayBoolean:new(256)
      for _, bsonType in System.each(System.Enum.GetValues(System.typeof(MongoDBBson.BsonType))) do
        bsonType = System.cast(System.Int32, bsonType)
        __validBsonTypes:set(System.toByte(bsonType), true)
      end
    end
    -- <summary>
    -- Backpatches the size.
    -- </summary>
    -- <param name="startPosition">The start position.</param>
    BackpatchSize = function (stream, startPosition)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end
      if startPosition < 0 or startPosition > stream:getLength() then
        System.throw(System.ArgumentOutOfRangeException("startPosition"))
      end

      local size = stream:getPosition() - startPosition
      if size > 2147483647 --[[Int32.MaxValue]] then
        local message = System.String.Format("Size {0} is larger than {1} (Int32.MaxValue).", size, 2147483647 --[[Int32.MaxValue]])
        System.throw(System.FormatException(message))
      end

      local endPosition = stream:getPosition()
      stream:setPosition(startPosition)
      stream:WriteInt32(System.toInt32(size))
      stream:setPosition(endPosition)
    end
    -- <summary>
    -- Reads the binary sub type.
    -- </summary>
    -- <returns>The binary sub type.</returns>
    ReadBinarySubType = function (stream)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      local b = stream:ReadByte()
      if b == - 1 then
        System.throw(SystemIO.EndOfStreamException())
      end
      return b
    end
    -- <summary>
    -- Reads a boolean from the stream.
    -- </summary>
    -- <returns>A boolean.</returns>
    ReadBoolean = function (stream)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      local b = stream:ReadByte()
      if b == - 1 then
        System.throw(SystemIO.EndOfStreamException())
      end
      return b ~= 0
    end
    -- <summary>
    -- Reads the BSON type.
    -- </summary>
    -- <returns>The BSON type.</returns>
    ReadBsonType = function (stream)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      local b = stream:ReadByte()
      if b == - 1 then
        System.throw(SystemIO.EndOfStreamException())
      end
      if not __validBsonTypes:get(b) then
        local message = System.String.Format("Detected unknown BSON type \"\\x{0:x2}\". Are you using the latest driver version?", b)
        System.throw(System.FormatException(message))
      end
      return b
    end
    -- <summary>
    -- Reads bytes from the stream.
    -- </summary>
    -- <param name="buffer">The buffer.</param>
    -- <param name="offset">The offset.</param>
    -- <param name="count">The count.</param>
    ReadBytes = function (stream, buffer, offset, count)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer"))
      end
      if offset < 0 or offset > #buffer then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or offset + count > #buffer then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end

      if count == 1 then
        local b = stream:ReadByte()
        if b == - 1 then
          System.throw(SystemIO.EndOfStreamException())
        end
        buffer:set(offset, System.toByte(b))
      else
        while count > 0 do
          local bytesRead = stream:Read(buffer, offset, count)
          if bytesRead == 0 then
            System.throw(SystemIO.EndOfStreamException())
          end
          offset = offset + bytesRead
          count = count - bytesRead
        end
      end
    end
    -- <summary>
    -- Reads bytes from the stream.
    -- </summary>
    -- <param name="count">The count.</param>
    -- <returns>The bytes.</returns>
    ReadBytes1 = function (stream, count)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end
      if count < 0 then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end

      local bytes = ArrayByte:new(count)
      ReadBytes(stream, bytes, 0, count)
      return bytes
    end
    -- <summary>
    -- Writes a binary sub type to the stream.
    -- </summary>
    -- <param name="value">The value.</param>
    WriteBinarySubType = function (stream, value)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      stream:WriteByte(System.toByte(value))
    end
    -- <summary>
    -- Writes a boolean to the stream.
    -- </summary>
    -- <param name="value">The value.</param>
    WriteBoolean = function (stream, value)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      stream:WriteByte(value and 1 --[[(byte)1]] or 0 --[[(byte)0]])
    end
    -- <summary>
    -- Writes a BsonType to the stream.
    -- </summary>
    -- <param name="value">The value.</param>
    WriteBsonType = function (stream, value)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end

      stream:WriteByte(System.toByte(value))
    end
    -- <summary>
    -- Writes bytes to the stream.
    -- </summary>
    -- <param name="buffer">The buffer.</param>
    -- <param name="offset">The offset.</param>
    -- <param name="count">The count.</param>
    WriteBytes = function (stream, buffer, offset, count)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end
      if buffer == nil then
        System.throw(System.ArgumentNullException("buffer"))
      end
      if offset < 0 or offset > #buffer then
        System.throw(System.ArgumentOutOfRangeException("offset"))
      end
      if count < 0 or offset + count > #buffer then
        System.throw(System.ArgumentOutOfRangeException("count"))
      end

      if count == 1 then
        stream:WriteByte(buffer:get(offset))
      else
        stream:Write(buffer, offset, count)
      end
    end
    -- <summary>
    -- Writes a slice to the stream.
    -- </summary>
    -- <param name="slice">The slice.</param>
    WriteSlice = function (stream, slice)
      if stream == nil then
        System.throw(System.ArgumentNullException("stream"))
      end
      if slice == nil then
        System.throw(System.ArgumentNullException("slice"))
      end

      local position = 0
      local count = slice:getLength()

      while count > 0 do
        local segment = slice:AccessBackingBytes(position)
        local partialCount = math.Min(count, segment:getCount())
        WriteBytes(stream, segment:getArray(), segment:getOffset(), partialCount)
        position = position + partialCount
        count = count - partialCount
      end
    end
    return {
      BackpatchSize = BackpatchSize,
      ReadBinarySubType = ReadBinarySubType,
      ReadBoolean = ReadBoolean,
      ReadBsonType = ReadBsonType,
      ReadBytes = ReadBytes,
      ReadBytes1 = ReadBytes1,
      WriteBinarySubType = WriteBinarySubType,
      WriteBoolean = WriteBoolean,
      WriteBsonType = WriteBsonType,
      WriteBytes = WriteBytes,
      WriteSlice = WriteSlice,
      static = static
    }
  end)
end)
