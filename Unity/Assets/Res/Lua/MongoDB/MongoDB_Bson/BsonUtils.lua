-- Generated by CSharp.lua Compiler
--[[ Copyright 2010-present MongoDB Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
]]
local System = System
local SystemReflection = System.Reflection
local SystemRegularExpressions = System.Text.RegularExpressions
local ArrayByte = System.Array(System.Byte)
local ArrayChar = System.Array(System.Char)
local MongoDBBson
System.import(function (out)
  MongoDBBson = MongoDB.Bson
end)
System.namespace("MongoDB.Bson", function (namespace)
  -- <summary>
  -- A static class containing BSON utility methods.
  -- </summary>
  namespace.class("BsonUtils", function (namespace)
    local GetFriendlyTypeName, ParseHexString, ToDateTimeFromMillisecondsSinceEpoch, ToHexChar, ToHexString, ToLocalTime, ToMillisecondsSinceEpoch, ToUniversalTime, 
    TryParseHexString, TryParseHexChar
    -- <summary>
    -- Gets a friendly class name suitable for use in error messages.
    -- </summary>
    -- <returns>A friendly class name.</returns>
    GetFriendlyTypeName = function (type)
      local typeInfo = SystemReflection.IntrospectionExtensions.GetTypeInfo(type)
      if not typeInfo:getIsGenericType() then
        return type:getName()
      end

      local sb = System.StringBuilder()
      sb:AppendFormat("{0}<", SystemRegularExpressions.Regex.Replace(type:getName(), [[\`\d+$]], ""))
      for _, typeParameter in System.each(SystemReflection.IntrospectionExtensions.GetTypeInfo(type):GetGenericArguments()) do
        sb:AppendFormat("{0}, ", GetFriendlyTypeName(typeParameter))
      end
      sb:Remove(sb:getLength() - 2, 2)
      sb:Append(">")
      return sb:ToString()
    end
    -- <summary>
    -- Parses a hex string into its equivalent byte array.
    -- </summary>
    -- <returns>The byte equivalent of the hex string.</returns>
    ParseHexString = function (s)
      if s == nil then
        System.throw(System.ArgumentNullException("s" --[[nameof(s)]]))
      end

      local bytes
      local default
      default, bytes = TryParseHexString(s)
      if not default then
        System.throw(System.FormatException("String should contain only hexadecimal digits."))
      end

      return bytes
    end
    -- <summary>
    -- Converts from number of milliseconds since Unix epoch to DateTime.
    -- </summary>
    -- <returns>A DateTime.</returns>
    ToDateTimeFromMillisecondsSinceEpoch = function (millisecondsSinceEpoch)
      if millisecondsSinceEpoch < MongoDBBson.BsonConstants.getDateTimeMinValueMillisecondsSinceEpoch() or millisecondsSinceEpoch > MongoDBBson.BsonConstants.getDateTimeMaxValueMillisecondsSinceEpoch() then
        local message = System.String.Format("The value {0} for the BsonDateTime MillisecondsSinceEpoch is outside therange that can be converted to a .NET DateTime." --[["The value {0} for the BsonDateTime MillisecondsSinceEpoch is outside the"+
                    "range that can be converted to a .NET DateTime."]], millisecondsSinceEpoch)
        System.throw(System.ArgumentOutOfRangeException("millisecondsSinceEpoch", message))
      end

      -- MaxValue has to be handled specially to avoid rounding errors
      if millisecondsSinceEpoch == MongoDBBson.BsonConstants.getDateTimeMaxValueMillisecondsSinceEpoch() then
        return System.DateTime.SpecifyKind(System.DateTime.MaxValue, 1 --[[DateTimeKind.Utc]])
      else
        return MongoDBBson.BsonConstants.getUnixEpoch():AddTicks(millisecondsSinceEpoch * 10000)
      end
    end
    -- <summary>
    -- Converts a value to a hex character.
    -- </summary>
    -- <returns>The hex character.</returns>
    ToHexChar = function (value)
      return System.toUInt16(value + ((value < 10) and 48 --[['0']] or 87 --[['a' - 10]]))
    end
    -- <summary>
    -- Converts a byte array to a hex string.
    -- </summary>
    -- <returns>A hex string.</returns>
    ToHexString = function (bytes)
      if bytes == nil then
        System.throw(System.ArgumentNullException("bytes"))
      end

      local length = #bytes
      local c = ArrayChar:new(length * 2)

      do
        local i = 0 local j = 0
        while i < length do
          local b = bytes:get(i)
          local default = j
          j = default + 1
          c:set(default, ToHexChar(System.sr(b, 4)))
          local extern = j
          j = extern + 1
          c:set(extern, ToHexChar(System.band(b, 0x0f)))
          i = i + 1
        end
      end

      return System.String(c)
    end
    -- <summary>
    -- Converts a DateTime to local time (with special handling for MinValue and MaxValue).
    -- </summary>
    -- <returns>The DateTime in local time.</returns>
    ToLocalTime = function (dateTime)
      if dateTime == System.DateTime.MinValue then
        return System.DateTime.SpecifyKind(System.DateTime.MinValue, 2 --[[DateTimeKind.Local]])
      elseif dateTime == System.DateTime.MaxValue then
        return System.DateTime.SpecifyKind(System.DateTime.MaxValue, 2 --[[DateTimeKind.Local]])
      else
        return dateTime:ToLocalTime()
      end
    end
    -- <summary>
    -- Converts a DateTime to number of milliseconds since Unix epoch.
    -- </summary>
    -- <returns>Number of seconds since Unix epoch.</returns>
    ToMillisecondsSinceEpoch = function (dateTime)
      local utcDateTime = ToUniversalTime(dateTime)
      return System.div((utcDateTime - MongoDBBson.BsonConstants.getUnixEpoch()):getTicks(), 10000)
    end
    -- <summary>
    -- Converts a DateTime to UTC (with special handling for MinValue and MaxValue).
    -- </summary>
    -- <returns>The DateTime in UTC.</returns>
    ToUniversalTime = function (dateTime)
      if dateTime == System.DateTime.MinValue then
        return System.DateTime.SpecifyKind(System.DateTime.MinValue, 1 --[[DateTimeKind.Utc]])
      elseif dateTime == System.DateTime.MaxValue then
        return System.DateTime.SpecifyKind(System.DateTime.MaxValue, 1 --[[DateTimeKind.Utc]])
      else
        return dateTime:ToUniversalTime()
      end
    end
    -- <summary>
    -- Tries to parse a hex string to a byte array.
    -- </summary>
    -- <param name="bytes">A byte array.</param>
    -- <returns>True if the hex string was successfully parsed.</returns>
    TryParseHexString = function (s, bytes)
      bytes = nil

      if s == nil then
        return false, bytes
      end

      local buffer = ArrayByte:new(System.div((#s + 1), 2))

      local i = 0
      local j = 0

      if (System.mod(#s, 2)) == 1 then
        -- if s has an odd length assume an implied leading "0"
        local y
        local default = i
        i = default + 1
        local extern
        extern, y = TryParseHexChar(s:get(default))
        if not extern then
          return false, bytes
        end
        local ref = j
        j = ref + 1
        buffer:set(ref, System.toByte(y))
      end

      while i < #s do
        local x, y
        local default = i
        i = default + 1
        local extern
        extern, x = TryParseHexChar(s:get(default))
        if not extern then
          return false, bytes
        end
        local ref = i
        i = ref + 1
        local out
        out, y = TryParseHexChar(s:get(ref))
        if not out then
          return false, bytes
        end
        local try = j
        j = try + 1
        buffer:set(try, System.toByte(System.bor((System.sl(x, 4)), y)))
      end

      bytes = buffer
      return true, bytes
    end
    TryParseHexChar = function (c, value)
      if c >= 48 --[['0']] and c <= 57 --[['9']] then
        value = c - 48 --[['0']]
        return true, value
      end

      if c >= 97 --[['a']] and c <= 102 --[['f']] then
        value = 10 + (c - 97 --[['a']])
        return true, value
      end

      if c >= 65 --[['A']] and c <= 70 --[['F']] then
        value = 10 + (c - 65 --[['A']])
        return true, value
      end

      value = 0
      return false, value
    end
    return {
      GetFriendlyTypeName = GetFriendlyTypeName,
      ParseHexString = ParseHexString,
      ToDateTimeFromMillisecondsSinceEpoch = ToDateTimeFromMillisecondsSinceEpoch,
      ToHexChar = ToHexChar,
      ToHexString = ToHexString,
      ToLocalTime = ToLocalTime,
      ToMillisecondsSinceEpoch = ToMillisecondsSinceEpoch,
      ToUniversalTime = ToUniversalTime,
      TryParseHexString = TryParseHexString
    }
  end)
end)
