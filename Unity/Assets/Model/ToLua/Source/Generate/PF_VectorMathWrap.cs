//this source code was auto-generated by tolua#, do not modify it
using System;
using LuaInterface;

public class PF_VectorMathWrap
{
	public static void Register(LuaState L)
	{
		L.BeginStaticLibs("VectorMath");
		L.RegFunction("ComplexMultiply", ComplexMultiply);
		L.RegFunction("ComplexMultiplyConjugate", ComplexMultiplyConjugate);
		L.RegFunction("ClosestPointOnLine", ClosestPointOnLine);
		L.RegFunction("ClosestPointOnLineFactor", ClosestPointOnLineFactor);
		L.RegFunction("ClosestPointOnSegment", ClosestPointOnSegment);
		L.RegFunction("ClosestPointOnSegmentXZ", ClosestPointOnSegmentXZ);
		L.RegFunction("SqrDistancePointSegmentApproximate", SqrDistancePointSegmentApproximate);
		L.RegFunction("SqrDistancePointSegment", SqrDistancePointSegment);
		L.RegFunction("SqrDistanceSegmentSegment", SqrDistanceSegmentSegment);
		L.RegFunction("SqrDistanceXZ", SqrDistanceXZ);
		L.RegFunction("SignedTriangleAreaTimes2XZ", SignedTriangleAreaTimes2XZ);
		L.RegFunction("RightXZ", RightXZ);
		L.RegFunction("SideXZ", SideXZ);
		L.RegFunction("RightOrColinear", RightOrColinear);
		L.RegFunction("RightOrColinearXZ", RightOrColinearXZ);
		L.RegFunction("IsClockwiseMarginXZ", IsClockwiseMarginXZ);
		L.RegFunction("IsClockwiseXZ", IsClockwiseXZ);
		L.RegFunction("IsClockwiseOrColinearXZ", IsClockwiseOrColinearXZ);
		L.RegFunction("IsClockwiseOrColinear", IsClockwiseOrColinear);
		L.RegFunction("IsColinear", IsColinear);
		L.RegFunction("IsColinearXZ", IsColinearXZ);
		L.RegFunction("IsColinearAlmostXZ", IsColinearAlmostXZ);
		L.RegFunction("SegmentsIntersect", SegmentsIntersect);
		L.RegFunction("SegmentsIntersectXZ", SegmentsIntersectXZ);
		L.RegFunction("LineDirIntersectionPointXZ", LineDirIntersectionPointXZ);
		L.RegFunction("RaySegmentIntersectXZ", RaySegmentIntersectXZ);
		L.RegFunction("LineIntersectionFactorXZ", LineIntersectionFactorXZ);
		L.RegFunction("LineRayIntersectionFactorXZ", LineRayIntersectionFactorXZ);
		L.RegFunction("LineIntersectionPointXZ", LineIntersectionPointXZ);
		L.RegFunction("LineIntersectionPoint", LineIntersectionPoint);
		L.RegFunction("SegmentIntersectionPointXZ", SegmentIntersectionPointXZ);
		L.RegFunction("LineCircleIntersectionFactor", LineCircleIntersectionFactor);
		L.RegFunction("Normalize", Normalize);
		L.RegFunction("ClampMagnitudeXZ", ClampMagnitudeXZ);
		L.RegFunction("MagnitudeXZ", MagnitudeXZ);
		L.EndStaticLibs();
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ComplexMultiply(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
			UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
			UnityEngine.Vector2 o = PF.VectorMath.ComplexMultiply(arg0, arg1);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ComplexMultiplyConjugate(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
			UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
			UnityEngine.Vector2 o = PF.VectorMath.ComplexMultiplyConjugate(arg0, arg1);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ClosestPointOnLine(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			UnityEngine.Vector3 o = PF.VectorMath.ClosestPointOnLine(arg0, arg1, arg2);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ClosestPointOnLineFactor(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				float o = PF.VectorMath.ClosestPointOnLineFactor(arg0, arg1, arg2);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				float o = PF.VectorMath.ClosestPointOnLineFactor(arg0, arg1, arg2);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int2, PF.Int2, PF.Int2>(L, 1))
			{
				PF.Int2 arg0 = StackTraits<PF.Int2>.To(L, 1);
				PF.Int2 arg1 = StackTraits<PF.Int2>.To(L, 2);
				PF.Int2 arg2 = StackTraits<PF.Int2>.To(L, 3);
				float o = PF.VectorMath.ClosestPointOnLineFactor(arg0, arg1, arg2);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.ClosestPointOnLineFactor");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ClosestPointOnSegment(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			UnityEngine.Vector3 o = PF.VectorMath.ClosestPointOnSegment(arg0, arg1, arg2);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ClosestPointOnSegmentXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			UnityEngine.Vector3 o = PF.VectorMath.ClosestPointOnSegmentXZ(arg0, arg1, arg2);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SqrDistancePointSegmentApproximate(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3)
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
				float o = PF.VectorMath.SqrDistancePointSegmentApproximate(arg0, arg1, arg2);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else if (count == 6)
			{
				int arg0 = (int)LuaDLL.luaL_checknumber(L, 1);
				int arg1 = (int)LuaDLL.luaL_checknumber(L, 2);
				int arg2 = (int)LuaDLL.luaL_checknumber(L, 3);
				int arg3 = (int)LuaDLL.luaL_checknumber(L, 4);
				int arg4 = (int)LuaDLL.luaL_checknumber(L, 5);
				int arg5 = (int)LuaDLL.luaL_checknumber(L, 6);
				float o = PF.VectorMath.SqrDistancePointSegmentApproximate(arg0, arg1, arg2, arg3, arg4, arg5);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.SqrDistancePointSegmentApproximate");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SqrDistancePointSegment(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			float o = PF.VectorMath.SqrDistancePointSegment(arg0, arg1, arg2);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SqrDistanceSegmentSegment(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 4);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
			float o = PF.VectorMath.SqrDistanceSegmentSegment(arg0, arg1, arg2, arg3);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SqrDistanceXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			float o = PF.VectorMath.SqrDistanceXZ(arg0, arg1);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SignedTriangleAreaTimes2XZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				long o = PF.VectorMath.SignedTriangleAreaTimes2XZ(arg0, arg1, arg2);
				LuaDLL.tolua_pushint64(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				float o = PF.VectorMath.SignedTriangleAreaTimes2XZ(arg0, arg1, arg2);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.SignedTriangleAreaTimes2XZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int RightXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				bool o = PF.VectorMath.RightXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				bool o = PF.VectorMath.RightXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.RightXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SideXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
			PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
			PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
			PF.Side o = PF.VectorMath.SideXZ(arg0, arg1, arg2);
			LuaDLL.lua_pushinteger(L, (int)o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int RightOrColinear(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2>(L, 1))
			{
				UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
				UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
				UnityEngine.Vector2 arg2 = ToLua.ToVector2(L, 3);
				bool o = PF.VectorMath.RightOrColinear(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int2, PF.Int2, PF.Int2>(L, 1))
			{
				PF.Int2 arg0 = StackTraits<PF.Int2>.To(L, 1);
				PF.Int2 arg1 = StackTraits<PF.Int2>.To(L, 2);
				PF.Int2 arg2 = StackTraits<PF.Int2>.To(L, 3);
				bool o = PF.VectorMath.RightOrColinear(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.RightOrColinear");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int RightOrColinearXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				bool o = PF.VectorMath.RightOrColinearXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				bool o = PF.VectorMath.RightOrColinearXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.RightOrColinearXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsClockwiseMarginXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			bool o = PF.VectorMath.IsClockwiseMarginXZ(arg0, arg1, arg2);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsClockwiseXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				bool o = PF.VectorMath.IsClockwiseXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				bool o = PF.VectorMath.IsClockwiseXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.IsClockwiseXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsClockwiseOrColinearXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
			PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
			PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
			bool o = PF.VectorMath.IsClockwiseOrColinearXZ(arg0, arg1, arg2);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsClockwiseOrColinear(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			PF.Int2 arg0 = StackTraits<PF.Int2>.Check(L, 1);
			PF.Int2 arg1 = StackTraits<PF.Int2>.Check(L, 2);
			PF.Int2 arg2 = StackTraits<PF.Int2>.Check(L, 3);
			bool o = PF.VectorMath.IsClockwiseOrColinear(arg0, arg1, arg2);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsColinear(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				bool o = PF.VectorMath.IsColinear(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2>(L, 1))
			{
				UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
				UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
				UnityEngine.Vector2 arg2 = ToLua.ToVector2(L, 3);
				bool o = PF.VectorMath.IsColinear(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.IsColinear");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsColinearXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 3 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				bool o = PF.VectorMath.IsColinearXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 3 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				bool o = PF.VectorMath.IsColinearXZ(arg0, arg1, arg2);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.IsColinearXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int IsColinearAlmostXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 3);
			PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
			PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
			PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
			bool o = PF.VectorMath.IsColinearAlmostXZ(arg0, arg1, arg2);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SegmentsIntersect(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 4);
			PF.Int2 arg0 = StackTraits<PF.Int2>.Check(L, 1);
			PF.Int2 arg1 = StackTraits<PF.Int2>.Check(L, 2);
			PF.Int2 arg2 = StackTraits<PF.Int2>.Check(L, 3);
			PF.Int2 arg3 = StackTraits<PF.Int2>.Check(L, 4);
			bool o = PF.VectorMath.SegmentsIntersect(arg0, arg1, arg2, arg3);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SegmentsIntersectXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 4 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3, PF.Int3>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				PF.Int3 arg3 = StackTraits<PF.Int3>.To(L, 4);
				bool o = PF.VectorMath.SegmentsIntersectXZ(arg0, arg1, arg2, arg3);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else if (count == 4 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				bool o = PF.VectorMath.SegmentsIntersectXZ(arg0, arg1, arg2, arg3);
				LuaDLL.lua_pushboolean(L, o);
				return 1;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.SegmentsIntersectXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineDirIntersectionPointXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 4)
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				UnityEngine.Vector3 o = PF.VectorMath.LineDirIntersectionPointXZ(arg0, arg1, arg2, arg3);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 5)
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				bool arg4;
				UnityEngine.Vector3 o = PF.VectorMath.LineDirIntersectionPointXZ(arg0, arg1, arg2, arg3, out arg4);
				ToLua.Push(L, o);
				LuaDLL.lua_pushboolean(L, arg4);
				return 2;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.LineDirIntersectionPointXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int RaySegmentIntersectXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 4);
			PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
			PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
			PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
			PF.Int3 arg3 = StackTraits<PF.Int3>.Check(L, 4);
			bool o = PF.VectorMath.RaySegmentIntersectXZ(arg0, arg1, arg2, arg3);
			LuaDLL.lua_pushboolean(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineIntersectionFactorXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 4)
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				float o = PF.VectorMath.LineIntersectionFactorXZ(arg0, arg1, arg2, arg3);
				LuaDLL.lua_pushnumber(L, o);
				return 1;
			}
			else if (count == 6 && TypeChecker.CheckTypes<UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3, LuaInterface.LuaOut<float>, LuaInterface.LuaOut<float>>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				float arg4;
				float arg5;
				bool o = PF.VectorMath.LineIntersectionFactorXZ(arg0, arg1, arg2, arg3, out arg4, out arg5);
				LuaDLL.lua_pushboolean(L, o);
				LuaDLL.lua_pushnumber(L, arg4);
				LuaDLL.lua_pushnumber(L, arg5);
				return 3;
			}
			else if (count == 6 && TypeChecker.CheckTypes<PF.Int3, PF.Int3, PF.Int3, PF.Int3, LuaInterface.LuaOut<float>, LuaInterface.LuaOut<float>>(L, 1))
			{
				PF.Int3 arg0 = StackTraits<PF.Int3>.To(L, 1);
				PF.Int3 arg1 = StackTraits<PF.Int3>.To(L, 2);
				PF.Int3 arg2 = StackTraits<PF.Int3>.To(L, 3);
				PF.Int3 arg3 = StackTraits<PF.Int3>.To(L, 4);
				float arg4;
				float arg5;
				bool o = PF.VectorMath.LineIntersectionFactorXZ(arg0, arg1, arg2, arg3, out arg4, out arg5);
				LuaDLL.lua_pushboolean(L, o);
				LuaDLL.lua_pushnumber(L, arg4);
				LuaDLL.lua_pushnumber(L, arg5);
				return 3;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.LineIntersectionFactorXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineRayIntersectionFactorXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 4);
			PF.Int3 arg0 = StackTraits<PF.Int3>.Check(L, 1);
			PF.Int3 arg1 = StackTraits<PF.Int3>.Check(L, 2);
			PF.Int3 arg2 = StackTraits<PF.Int3>.Check(L, 3);
			PF.Int3 arg3 = StackTraits<PF.Int3>.Check(L, 4);
			float o = PF.VectorMath.LineRayIntersectionFactorXZ(arg0, arg1, arg2, arg3);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineIntersectionPointXZ(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 4)
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				UnityEngine.Vector3 o = PF.VectorMath.LineIntersectionPointXZ(arg0, arg1, arg2, arg3);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 5)
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
				UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
				UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
				bool arg4;
				UnityEngine.Vector3 o = PF.VectorMath.LineIntersectionPointXZ(arg0, arg1, arg2, arg3, out arg4);
				ToLua.Push(L, o);
				LuaDLL.lua_pushboolean(L, arg4);
				return 2;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.LineIntersectionPointXZ");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineIntersectionPoint(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 4)
			{
				UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
				UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
				UnityEngine.Vector2 arg2 = ToLua.ToVector2(L, 3);
				UnityEngine.Vector2 arg3 = ToLua.ToVector2(L, 4);
				UnityEngine.Vector2 o = PF.VectorMath.LineIntersectionPoint(arg0, arg1, arg2, arg3);
				ToLua.Push(L, o);
				return 1;
			}
			else if (count == 5)
			{
				UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
				UnityEngine.Vector2 arg1 = ToLua.ToVector2(L, 2);
				UnityEngine.Vector2 arg2 = ToLua.ToVector2(L, 3);
				UnityEngine.Vector2 arg3 = ToLua.ToVector2(L, 4);
				bool arg4;
				UnityEngine.Vector2 o = PF.VectorMath.LineIntersectionPoint(arg0, arg1, arg2, arg3, out arg4);
				ToLua.Push(L, o);
				LuaDLL.lua_pushboolean(L, arg4);
				return 2;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.LineIntersectionPoint");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int SegmentIntersectionPointXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 5);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			UnityEngine.Vector3 arg3 = ToLua.ToVector3(L, 4);
			bool arg4;
			UnityEngine.Vector3 o = PF.VectorMath.SegmentIntersectionPointXZ(arg0, arg1, arg2, arg3, out arg4);
			ToLua.Push(L, o);
			LuaDLL.lua_pushboolean(L, arg4);
			return 2;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int LineCircleIntersectionFactor(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 4);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			UnityEngine.Vector3 arg1 = ToLua.ToVector3(L, 2);
			UnityEngine.Vector3 arg2 = ToLua.ToVector3(L, 3);
			float arg3 = (float)LuaDLL.luaL_checknumber(L, 4);
			float o = PF.VectorMath.LineCircleIntersectionFactor(arg0, arg1, arg2, arg3);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int Normalize(IntPtr L)
	{
		try
		{
			int count = LuaDLL.lua_gettop(L);

			if (count == 2 && TypeChecker.CheckTypes<UnityEngine.Vector3, LuaInterface.LuaOut<float>>(L, 1))
			{
				UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
				float arg1;
				UnityEngine.Vector3 o = PF.VectorMath.Normalize(arg0, out arg1);
				ToLua.Push(L, o);
				LuaDLL.lua_pushnumber(L, arg1);
				return 2;
			}
			else if (count == 2 && TypeChecker.CheckTypes<UnityEngine.Vector2, LuaInterface.LuaOut<float>>(L, 1))
			{
				UnityEngine.Vector2 arg0 = ToLua.ToVector2(L, 1);
				float arg1;
				UnityEngine.Vector2 o = PF.VectorMath.Normalize(arg0, out arg1);
				ToLua.Push(L, o);
				LuaDLL.lua_pushnumber(L, arg1);
				return 2;
			}
			else
			{
				return LuaDLL.luaL_throw(L, "invalid arguments to method: PF.VectorMath.Normalize");
			}
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int ClampMagnitudeXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 2);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			float arg1 = (float)LuaDLL.luaL_checknumber(L, 2);
			UnityEngine.Vector3 o = PF.VectorMath.ClampMagnitudeXZ(arg0, arg1);
			ToLua.Push(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}

	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]
	static int MagnitudeXZ(IntPtr L)
	{
		try
		{
			ToLua.CheckArgsCount(L, 1);
			UnityEngine.Vector3 arg0 = ToLua.ToVector3(L, 1);
			float o = PF.VectorMath.MagnitudeXZ(arg0);
			LuaDLL.lua_pushnumber(L, o);
			return 1;
		}
		catch (Exception e)
		{
			return LuaDLL.toluaL_exception(L, e);
		}
	}
}

